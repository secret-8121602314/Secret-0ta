app tsx 

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { ConnectionStatus, Conversation, Conversations, Insight, UserTier, Usage, ContextMenuState, ContextMenuItem, PendingInsightModification } from './services/types';
import { canAccessDeveloperFeatures } from './config/developer';
import ConnectionModal from './components/ConnectionModal';
import HandsFreeModal from './components/HandsFreeModal';
import DesktopIcon from './components/DesktopIcon';
import SplashScreen from './components/SplashScreen';
import InitialSplashScreen from './components/InitialSplashScreen';
import HowToUseSplashScreen from './components/HowToUseSplashScreen';
import LoginSplashScreen from './components/LoginSplashScreen';
import Logo from './components/Logo';
import ChatMessageComponent from './components/ChatMessage';
import ChatInput from './components/ChatInput';
import SuggestedPrompts from './components/SuggestedPrompts';
import { useChat } from './hooks/useChat';
import { useConnection } from './hooks/useConnection';
import { useTutorial } from './hooks/useTutorial';
import { profileService } from './services/profileService';
import { longTermMemoryService } from './services/longTermMemoryService';
import { contextManagementService } from './services/contextManagementService';
import ConversationTabs from './components/ConversationTabs';
import ContactUsModal from './components/ContactUsModal';
import HandsFreeToggle from './components/HandsFreeToggle';
import { ttsService } from './services/ttsService';
import { unifiedUsageService } from './services/unifiedUsageService';
import { addFeedback } from './services/feedbackService';
import UpgradeSplashScreen from './components/UpgradeSplashScreen';
import ProFeaturesSplashScreen from './components/ProFeaturesSplashScreen';
import SubTabs from './components/SubTabs';
import UITutorial from './components/UITutorial';
import MainViewContainer from './components/MainViewContainer';

import CreditIndicator from './components/CreditIndicator';
import CreditModal from './components/CreditModal';
import ContextMenu from './components/ContextMenu';
import ConfirmationModal from './components/ConfirmationModal';
import InsightActionModal from './components/InsightActionModal';
import TrashIcon from './components/TrashIcon';
import PinIcon from './components/PinIcon';
import FeedbackModal from './components/FeedbackModal';
import SettingsIcon from './components/SettingsIcon';
import SettingsModal from './components/SettingsModal';
import AdBanner from './components/AdBanner';

import PolicyModal from './components/PolicyModal';
import AboutPage from './components/AboutPage';
import PrivacyPolicyPage from './components/PrivacyPolicyPage';
import RefundPolicyPage from './components/RefundPolicyPage';
import EditIcon from './components/EditIcon';
import LogoutIcon from './components/LogoutIcon';
import UserIcon from './components/UserIcon';
import { authService, AuthState, supabase } from './services/supabase';
import AuthModal from './components/AuthModal';
import ErrorBoundary from './components/ErrorBoundary';
import AuthCallbackHandler from './components/AuthCallbackHandler';
import PWAInstallBanner from './components/PWAInstallBanner';
import { pwaNavigationService, PWANavigationState } from './services/pwaNavigationService';
import { smartNotificationService } from './services/smartNotificationService';
import { pwaAnalyticsService } from './services/pwaAnalyticsService';
import { offlineStorageService } from './services/offlineStorageService';
import { pushNotificationService } from './services/pushNotificationService';
import { appShortcutsService } from './services/appShortcutsService';
import { performanceMonitoringService } from './services/performanceMonitoringService';


import DailyCheckinBanner from './components/DailyCheckinBanner';


import AchievementNotification from './components/AchievementNotification';
import dailyEngagementService, { Achievement } from './services/dailyEngagementService';
import { PlayerProfileSetupModal } from './components/PlayerProfileSetupModal';
import { playerProfileService } from './services/playerProfileService';
import { suggestedPromptsService } from './services/suggestedPromptsService';
import { ProactiveInsightsPanel } from './components/ProactiveInsightsPanel';
import { useEnhancedInsights } from './hooks/useEnhancedInsights';
import { proactiveInsightService } from './services/proactiveInsightService';
import { databaseService } from './services/databaseService';
import { supabaseDataService } from './services/supabaseDataService';
import ScreenshotButton from './components/ScreenshotButton';
import CharacterImmersionTest from './components/CharacterImmersionTest';
import OtakuDiaryModal from './components/OtakuDiaryModal';
import WishlistModal from './components/WishlistModal';
import CachePerformanceDashboard from './components/CachePerformanceDashboard';


// A data URL for a 1-second silent WAV file. This prevents needing to host an asset
// and is used to keep the app process alive in the background for TTS.
const SILENT_AUDIO_URL = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=";

// Cache clearing function for first run experience testing
const clearFirstRunCache = () => {
  const keysToClear = [
    'otakonOnboardingComplete',
    'otakon_profile_setup_completed',
    'otakon_first_run_completed',
    'otakon_welcome_message_shown',
    'otakon_first_welcome_shown',
    'otakon_has_conversations',
    'otakon_has_interacted_with_chat',
    'otakon_last_welcome_time',
    'otakon_app_closed_time',
    'otakon_tutorial_completed',
    'otakon_tutorial_step',
    'otakon_tutorial_shown',
    'otakonAuthMethod',
    'otakonHasConnectedBefore',
    'otakonGlobalPWAInstalled',
    'otakonInstallDismissed',
    'otakon_screenshot_mode',
    'otakon_screenshot_hint_seen',
    'otakonPreferredVoiceURI',
    'otakonSpeechRate',
    'lastSuggestedPromptsShown',
    'otakon_used_suggested_prompts',
    'otakonConversations',
    'otakonUsage'
  ];

  let clearedCount = 0;
  keysToClear.forEach(key => {
    if (localStorage.getItem(key)) {
      localStorage.removeItem(key);
      clearedCount++;
    }
  });

  // Clear service worker cache
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then(registrations => {
      registrations.forEach(registration => registration.unregister());
    });
  }

  if ('caches' in window) {
    caches.keys().then(cacheNames => {
      cacheNames.forEach(cacheName => caches.delete(cacheName));
    });
  }

  console.log(`ðŸ§¹ Cleared ${clearedCount} localStorage keys and service worker cache`);
  console.log('ðŸ”„ First run experience cache has been reset. Refresh to see changes.');
  
  // Force reload to apply changes
  window.location.reload();
};

type ImageFile = { base64: string; mimeType: string; dataUrl: string };
type FeedbackModalState = {
    type: 'message' | 'insight';
    conversationId: string;
    targetId: string; // messageId or insightId
    originalText: string;
};
type ActiveModal = 'about' | 'privacy' | 'refund' | 'contact' | null;


const AppComponent: React.FC = () => {
    const [view, setView] = useState<'landing' | 'app'>('app');
    const [onboardingStatus, setOnboardingStatus] = useState<'login' | 'initial' | 'features' | 'pro-features' | 'how-to-use' | 'tier-splash' | 'complete'>(() => {
        // Check if localStorage is available before accessing it
        if (typeof window !== 'undefined' && window.localStorage) {
            // Check for developer mode first
            const isDeveloperMode = localStorage.getItem('otakon_developer_mode') === 'true';
            const authMethod = localStorage.getItem('otakonAuthMethod');
            const isDeveloperAuth = authMethod === 'skip';
            
            if (isDeveloperMode || isDeveloperAuth) {
                console.log('ðŸ”§ Developer mode detected on app startup, skipping login');
                return 'complete';
            }
            
            // For authenticated users, check if they've completed onboarding
            const hasCompletedOnboarding = localStorage.getItem('otakonOnboardingComplete');
            const hasCompletedProfileSetup = localStorage.getItem('otakon_profile_setup_completed');
            
            if (hasCompletedOnboarding && hasCompletedProfileSetup) {
                console.log('ðŸ”§ Returning user detected on app startup, skipping login');
                return 'complete';
            }
            
            // Default to login for new users
            return 'login';
        }
        return 'login';
    });
    const [isConnectionModalOpen, setIsConnectionModalOpen] = useState(false);
    const [isHandsFreeModalOpen, setIsHandsFreeModalOpen] = useState(false);
    const [isCacheDashboardOpen, setIsCacheDashboardOpen] = useState(false);
    const [isCreditModalOpen, setIsCreditModalOpen] = useState(false);
    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
    const [hasRestored, setHasRestored] = useState(false);
    const [isHandsFreeMode, setIsHandsFreeMode] = useState(false);
    const [isManualUploadMode, setIsManualUploadMode] = useState(false);
    const [showUpgradeScreen, setShowUpgradeScreen] = useState(false);
    const [usage, setUsage] = useState<Usage>({
        textCount: 0,
        imageCount: 0,
        textLimit: 55,
        imageLimit: 25,
        tier: 'free'
    });
    const [activeSubView, setActiveSubView] = useState('chat');
    const [imagesForReview, setImagesForReview] = useState<ImageFile[]>([]);
    const [activeModal, setActiveModal] = useState<ActiveModal>(null);
    
    // Authentication State
    const [authState, setAuthState] = useState<AuthState>(() => authService.getAuthState());
    const [isAuthModalOpen, setIsAuthModalOpen] = useState(false);
    
    // PWA Navigation State
    const [pwaNavigationState, setPwaNavigationState] = useState<PWANavigationState>(() => pwaNavigationService.getNavigationState());
    
    // OAuth Callback State
    const [isOAuthCallback, setIsOAuthCallback] = useState(false);
    
    
    // Interactivity State
    const [contextMenu, setContextMenu] = useState<ContextMenuState | null>(null);
    const [confirmationModal, setConfirmationModal] = useState<{ title: string; message: string; onConfirm: () => void; } | null>(null);
    const [feedbackModalState, setFeedbackModalState] = useState<FeedbackModalState | null>(null);
    const [chatInputValue, setChatInputValue] = useState('');

    // Daily Engagement State
    const [showDailyCheckin, setShowDailyCheckin] = useState(false);

    const [currentAchievement, setCurrentAchievement] = useState<Achievement | null>(null);

    
    // Player Profile Setup State
    const [showProfileSetup, setShowProfileSetup] = useState(false);
    const [isFirstTime, setIsFirstTime] = useState(() => {
        // Default to true for first-time users, will be updated by Supabase check
        return true;
    });
    const [isOtakuDiaryModalOpen, setIsOtakuDiaryModalOpen] = useState(false);
    const [otakuDiaryGameInfo, setOtakuDiaryGameInfo] = useState<{ id: string; title: string } | null>(null);
    
    // Enhanced Features State
    const [showProactiveInsights, setShowProactiveInsights] = useState(false);
    const [databaseSyncStatus, setDatabaseSyncStatus] = useState<'idle' | 'syncing' | 'success' | 'error'>('idle');
    const [lastDatabaseSync, setLastDatabaseSync] = useState<number>(Date.now());
    const [lastSuggestedPromptsShown, setLastSuggestedPromptsShown] = useState<number>(0);
    
    // Welcome message session tracking to prevent duplicates
    const [welcomeMessageShownThisSession, setWelcomeMessageShownThisSession] = useState<boolean>(false);
    
    // Wishlist modal state
    const [isWishlistModalOpen, setIsWishlistModalOpen] = useState(false);
    
    // Track processed batches to prevent duplicates
    const processedBatches = useRef(new Set<string>());
    
    // Track processed single shots to prevent duplicates
    const processedSingleShots = useRef(new Set<string>());
    
    // Track when stop was last pressed to prevent immediate restart
    const lastStopTime = useRef<number>(0);
    const STOP_COOLDOWN_MS = 2000; // 2 second cooldown after stop
    
    // Track if cooldown message has been shown to prevent spam
    const cooldownMessageShown = useRef<boolean>(false);
    
    // Global stop flag to prevent new analysis from starting
    const isStopped = useRef<boolean>(false);
    
    // Ref to store the stop timeout for proper cleanup
    const stopTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    
    // Note: Suggested prompts now reset automatically every 24 hours via suggestedPromptsService

    // Cleanup deduplication sets periodically to prevent memory issues
    useEffect(() => {
        const cleanupInterval = setInterval(() => {
            if (processedBatches.current.size > 100) { 
                processedBatches.current.clear(); 
                console.log("ðŸ§¹ Cleaned up processed batches set"); 
            }
            if (processedSingleShots.current.size > 100) { 
                processedSingleShots.current.clear(); 
                console.log("ðŸ§¹ Cleaned up processed single shots set"); 
            }
        }, 60000); // Clean up every minute
        
        return () => {
            clearInterval(cleanupInterval);
            // Also clear the stop timeout on cleanup
            if (stopTimeoutRef.current) {
                clearTimeout(stopTimeoutRef.current);
                stopTimeoutRef.current = null;
            }
        };
    }, []);
    
    // Note: Old multi-shot state variables removed - PC client now sends screenshot_batch messages

    const chatInputRef = useRef<HTMLTextAreaElement>(null);
    const chatEndRef = useRef<HTMLDivElement>(null);
    const chatContainerRef = useRef<HTMLDivElement>(null);
    const silentAudioRef = useRef<HTMLAudioElement>(null);

    // Function to check current localStorage state (for debugging)
    const checkLocalStorageState = useCallback(() => {
        console.log('ðŸ” Current localStorage state:', {
            otakon_profile_setup_completed: localStorage.getItem('otakon_profile_setup_completed'),
            otakon_welcome_message_shown: localStorage.getItem('otakon_welcome_message_shown'),
            otakon_first_welcome_shown: localStorage.getItem('otakon_first_welcome_shown'),
            otakon_has_conversations: localStorage.getItem('otakon_has_conversations'),
            otakonOnboardingComplete: localStorage.getItem('otakonOnboardingComplete'),
            isFirstTime,
            view,
            onboardingStatus
        });
    }, [view, onboardingStatus, isFirstTime]);

    const refreshUsage = useCallback(async () => {
        try {
            // Add a small delay to ensure any pending backend updates have propagated
            await new Promise(resolve => setTimeout(resolve, 150));
            
            // Get the current tier directly without calling getUsage (which calls checkAndResetUsage)
            const currentTier = await unifiedUsageService.getCurrentTier();
            
            // Get the current usage data
            const syncedUsage = await unifiedUsageService.getUsage();
            
            // Ensure the tier is correct
            const updatedUsage = {
                ...syncedUsage,
                tier: currentTier
            };
            
            console.log('ðŸ”„ Refreshing usage with verified tier:', currentTier);
            setUsage(updatedUsage);
        } catch (error) {
            console.warn('Failed to refresh usage:', error);
        }
    }, []);

    // Authentication effect
    useEffect(() => {
        const unsubscribe = authService.subscribe((newAuthState) => {
            // Only log significant auth state changes to reduce console noise
            const hasUserChanged = !!authState.user !== !!newAuthState.user;
            const loadingChanged = authState.loading !== newAuthState.loading;
            
            if (hasUserChanged || loadingChanged) {
                console.log('ðŸ“¨ App received auth state update:', { 
                    hasUser: !!newAuthState.user, 
                    loading: newAuthState.loading,
                    error: newAuthState.error?.message 
                });
            }
            setAuthState(newAuthState);
            
            // If user is authenticated and we're still on login screen, transition
            if (newAuthState.user && !newAuthState.loading && onboardingStatus === 'login') {
                console.log('User authenticated, transitioning from login screen...');
                setOnboardingStatus('initial');
            }
        });
        return () => {
            if (typeof unsubscribe === 'function') {
                unsubscribe();
            }
        };
    }, [onboardingStatus]);

    // NEW: Long-term session restoration on app startup - MOVED TO AFTER useChat

    // Handle authentication success - transition from login to initial splash screen
    useEffect(() => {
        console.log('Auth state change detected:', { 
            hasUser: !!authState.user, 
            loading: authState.loading, 
            onboardingStatus,
            authMethod: localStorage.getItem('otakonAuthMethod'),
            isDeveloperMode: localStorage.getItem('otakon_developer_mode') === 'true'
        });
        
        // Check for developer mode first
        const isDeveloperMode = localStorage.getItem('otakon_developer_mode') === 'true';
        const authMethod = localStorage.getItem('otakonAuthMethod');
        const isDeveloperAuth = authMethod === 'skip';
        
        if ((isDeveloperMode || isDeveloperAuth) && onboardingStatus === 'login') {
            console.log('ðŸ”§ Developer mode detected on login screen, transitioning to app');
            setOnboardingStatus('complete');
            setView('app');
        }
        // Only transition if user just became authenticated and we're on login screen
        else if (authState.user && !authState.loading && onboardingStatus === 'login') {
            console.log('User authenticated on login screen, checking for recent auth...');
            
            // Check if this is a fresh authentication (not a page reload with existing session)
            const authMethod = localStorage.getItem('otakonAuthMethod');
            const hasRecentAuth = authMethod && (authMethod === 'google' || authMethod === 'discord');
            
            console.log('Auth method check:', { authMethod, hasRecentAuth });
            
            if (hasRecentAuth) {
                console.log('Authentication successful, transitioning to initial splash screen...');
                
                // Clear the auth method to prevent re-triggering
                localStorage.removeItem('otakonAuthMethod');
                
                // Check if user has already completed onboarding
                const hasCompletedOnboarding = localStorage.getItem('otakonOnboardingComplete');
                const hasCompletedProfileSetup = localStorage.getItem('otakon_profile_setup_completed');
                
                console.log('Onboarding check:', { hasCompletedOnboarding, hasCompletedProfileSetup });
                
                // Check if we should show splash screens after logout
                const shouldShowSplashAfterLogin = localStorage.getItem('otakon_show_splash_after_login');
                
                if (shouldShowSplashAfterLogin === 'true') {
                    // Clear the flag and show initial splash screens
                    localStorage.removeItem('otakon_show_splash_after_login');
                    console.log('Fresh login after logout detected, showing initial splash screens');
                    setOnboardingStatus('initial');
                    setView('app');
                } else if (hasCompletedOnboarding && hasCompletedProfileSetup) {
                    // Returning user - skip to complete status
                    console.log('Returning user, skipping to complete status');
                    setOnboardingStatus('complete');
                    setView('app');
                } else {
                    // New user - go to initial splash screen
                    console.log('New user, going to initial splash screen');
                    setOnboardingStatus('initial');
                    setView('app');
                }
            } else {
                console.log('No recent auth method found, staying on login screen');
            }
        }
    }, [authState.user, authState.loading, onboardingStatus]);

    // Fallback: Check for OAuth completion after a delay (in case auth state change is delayed)
    useEffect(() => {
        if (onboardingStatus === 'login' && !authState.loading) {
            const authMethod = localStorage.getItem('otakonAuthMethod');
            if (authMethod && (authMethod === 'google' || authMethod === 'discord')) {
                console.log('Fallback: Checking for delayed OAuth completion...');
                
                const checkAuthCompletion = setTimeout(async () => {
                    console.log('Fallback: Checking auth state after delay...');
                    
                    // Check if we have OAuth parameters in the URL
                    const hashParams = new URLSearchParams(window.location.hash.substring(1));
                    const hasOAuthParams = hashParams.has('access_token') || hashParams.has('refresh_token');
                    
                    if (hasOAuthParams) {
                        console.log('Fallback: OAuth parameters still in URL, forcing completion...');
                        
                        // Try to get user directly
                        const { data: { user }, error } = await supabase.auth.getUser();
                        if (user) {
                            console.log('Fallback: User found, transitioning...');
                            localStorage.removeItem('otakonAuthMethod');
                            setOnboardingStatus('initial');
                            setView('app');
                        } else {
                            console.log('Fallback: No user found, but OAuth params exist - forcing transition anyway');
                            localStorage.removeItem('otakonAuthMethod');
                            setOnboardingStatus('initial');
                            setView('app');
                        }
                    } else if (authState.user && onboardingStatus === 'login') {
                        console.log('Fallback: OAuth completed, transitioning...');
                        localStorage.removeItem('otakonAuthMethod');
                        
                        const hasCompletedOnboarding = localStorage.getItem('otakonOnboardingComplete');
                        const hasCompletedProfileSetup = localStorage.getItem('otakon_profile_setup_completed');
                        
                        // For OAuth fallback, always start with initial splash screen
                        console.log('OAuth fallback - ensuring first-time experience');
                        setOnboardingStatus('initial');
                        setView('app');
                    }
                }, 3000); // Wait 3 seconds for auth state to update
                
                return () => clearTimeout(checkAuthCompletion);
            }
        }
    }, [onboardingStatus, authState.user, authState.loading]);

    // Load usage data on mount
    useEffect(() => {
        const loadUsageData = async () => {
            try {
                const usageData = await unifiedUsageService.getUsage();
                setUsage(usageData);
            } catch (error) {
                console.warn('Failed to load usage data:', error);
            }
        };
        
        loadUsageData();
    }, []);

    
    // PWA Navigation effect - handle post-install navigation
    useEffect(() => {
        if (pwaNavigationState.isRunningInPWA) {
            const recommendedPath = pwaNavigationService.getRecommendedNavigationPath();
            
            if (recommendedPath === 'login' && onboardingStatus !== 'login') {
                // PWA installed, user not logged in - show login
                setOnboardingStatus('login');
                setView('app');
            } else if (recommendedPath === 'chat' && onboardingStatus !== 'complete') {
                // PWA installed, user logged in - go to main app
                setOnboardingStatus('complete');
                setView('app');
            }
        }
    }, [pwaNavigationState, onboardingStatus]);

    // Initialize suggested prompts cooldown from localStorage
    useEffect(() => {
        const stored = localStorage.getItem('lastSuggestedPromptsShown');
        if (stored) {
            setLastSuggestedPromptsShown(parseInt(stored, 10));
        }
        
        // Debug: Check localStorage state on mount
        if (import.meta.env.DEV) {
            setTimeout(() => {
                checkLocalStorageState();
            }, 1000);
            

        }
    }, [checkLocalStorageState]);
    
    // Handle app visibility changes to track when user returns after 12+ hours
    useEffect(() => {
        const handleVisibilityChange = async () => {
            if (!document.hidden) {
                // App became visible - check if we should show welcome message
                const lastWelcomeTime = localStorage.getItem('otakon_last_welcome_time');
                const appClosedTime = localStorage.getItem('otakon_app_closed_time');
                
                if (lastWelcomeTime || appClosedTime) {
                    const timeSinceLastWelcome = lastWelcomeTime ? Date.now() - parseInt(lastWelcomeTime, 10) : 0;
                    const timeSinceAppClosed = appClosedTime ? Date.now() - parseInt(appClosedTime, 10) : 0;
                    const TWELVE_HOURS_MS = 12 * 60 * 60 * 1000;
                    
                    if (timeSinceLastWelcome >= TWELVE_HOURS_MS || timeSinceAppClosed >= TWELVE_HOURS_MS) {
                        // Reset welcome message tracking to show it again
                        localStorage.removeItem('otakon_welcome_message_shown');
                        console.log('ðŸ”„ App returned after 12+ hours - welcome message will show again');
                    }
                }
                
                // Check if user has completed first run experience (created game conversations)
                if (!localStorage.getItem('otakon_first_run_completed')) {
                    const hasGameConversations = Object.values(conversations).some(conv => 
                        conv.id !== 'everything-else' && conv.title && conv.title !== 'New Game'
                    );
                    
                    if (hasGameConversations) {
                        localStorage.setItem('otakon_first_run_completed', 'true');
                        
                        // Also mark in Supabase if possible
                        try {
                            await playerProfileService.markFirstRunCompleted();
                            console.log('ðŸŽ® First run experience completed - marked in both localStorage and Supabase');
                        } catch (error) {
                            console.warn('Failed to mark first run completed in Supabase:', error);
                            console.log('ðŸŽ® First run experience completed - marked in localStorage only');
                        }
                    }
                }
            }
        };
        
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        // Track when user closes the app
        const handleBeforeUnload = () => {
            localStorage.setItem('otakon_app_closed_time', Date.now().toString());
        };
        
        window.addEventListener('beforeunload', handleBeforeUnload);
        
        return () => {
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            window.removeEventListener('beforeunload', handleBeforeUnload);
        };
    }, []);





    // PWA Post-install handler
    useEffect(() => {
        if (pwaNavigationState.isPWAInstalled && !pwaNavigationState.isRunningInPWA) {
            // PWA was just installed, handle post-install flow
            console.log('PWA Navigation: PWA just installed, handling post-install flow');
            
            // Check if user is already logged in
            if (authState.user && !authState.loading) {
                // User is logged in, go directly to main app
                setOnboardingStatus('complete');
                setView('app');
            } else {
                // User not logged in, show login
                setOnboardingStatus('login');
                setView('app');
            }
        }
    }, [pwaNavigationState.isPWAInstalled, pwaNavigationState.isRunningInPWA, authState.user, authState.loading]);
    
    // Initialize performance monitoring
    useEffect(() => {
        performanceMonitoringService.initialize();
        console.log('ðŸš€ Performance monitoring initialized');
    }, []);

    // Check for OAuth callback on component mount
    useEffect(() => {
        const checkOAuthCallback = async () => {
            // First, try the auth service's OAuth callback handler
            const callbackHandled = await authService.handleOAuthCallback();
            if (callbackHandled) {
                console.log('âœ… OAuth callback handled by auth service');
                return;
            }
            
            // Check if we're returning from an OAuth flow
            const urlParams = new URLSearchParams(window.location.search);
            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            
            console.log('Checking for OAuth callback...', {
                url: window.location.href,
                search: window.location.search,
                hash: window.location.hash,
                urlParams: Object.fromEntries(urlParams),
                hashParams: Object.fromEntries(hashParams)
            });
            
            // Check for Supabase OAuth callback parameters (both query params and hash params)
            const hasAuthParams = urlParams.has('access_token') || 
                                urlParams.has('refresh_token') || 
                                urlParams.has('error') ||
                                urlParams.has('code') ||
                                hashParams.has('access_token') ||
                                hashParams.has('refresh_token') ||
                                hashParams.has('error') ||
                                hashParams.has('code') ||
                                window.location.pathname.includes('auth/callback');
            
            if (hasAuthParams) {
                console.log('OAuth callback detected, parameters:', Object.fromEntries([...urlParams, ...hashParams]));
                setIsOAuthCallback(true);
                
                // Clear the URL immediately to prevent multiple processing
                console.log('Clearing OAuth parameters from URL...');
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Extract tokens before clearing URL
                const accessToken = hashParams.get('access_token') || urlParams.get('access_token');
                const refreshToken = hashParams.get('refresh_token') || urlParams.get('refresh_token');
                
                // Force Supabase to process the OAuth callback
                console.log('Forcing Supabase to process OAuth callback...');
                try {
                    // Wait a moment for Supabase to process the OAuth response
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // First, try to get the current session
                    const { data: { session }, error } = await supabase.auth.getSession();
                    console.log('Initial session check:', { session: !!session, error });
                    
                    if (error) {
                        console.error('Error getting session after OAuth callback:', error);
                    } else if (session) {
                        console.log('Session found after OAuth callback:', session);
                        // Force the auth state to update
                        console.log('Forcing auth state update...');
                        // Trigger a manual auth state change
                        setTimeout(() => {
                            console.log('Manual auth state update triggered');
                        }, 100);
                    } else {
                        console.log('No session found, trying to process OAuth callback...');
                        // Try to process the OAuth callback with the tokens from URL
                        if (accessToken && refreshToken) {
                            console.log('Processing OAuth callback with tokens...');
                            const { data, error: setSessionError } = await supabase.auth.setSession({
                                access_token: accessToken,
                                refresh_token: refreshToken
                            });
                            
                            if (setSessionError) {
                                console.error('Error setting session:', setSessionError);
                            } else if (data.session) {
                                console.log('Session set successfully:', data.session);
                                // Force transition
                                localStorage.removeItem('otakonAuthMethod');
                                setOnboardingStatus('initial');
                                setView('app');
                                setAuthState({ user: data.user, session: data.session, loading: false, error: null });
                            }
                        } else {
                            console.log('No tokens available for session processing');
                        }
                    }
                    
                    // Also try to get the user directly
                    const { data: { user }, error: userError } = await supabase.auth.getUser();
                    console.log('Direct user check:', { user: !!user, error: userError });
                    
                    if (user) {
                        console.log('User found directly:', user);
                        // Force transition since we have a user
                        console.log('User found, forcing transition to initial splash screen...');
                        localStorage.removeItem('otakonAuthMethod');
                        setOnboardingStatus('initial');
                        setView('app');
                        
                        // Force auth state update
                        setAuthState({ user, session, loading: false, error: null });
                    } else {
                        // If no user found, try to manually process the OAuth callback
                        console.log('No user found, trying manual OAuth processing...');
                        
                        if (accessToken) {
                            console.log('Access token found in URL, attempting manual session creation...');
                            try {
                                // Try to set the session manually
                                const { data, error } = await supabase.auth.setSession({
                                    access_token: accessToken,
                                    refresh_token: refreshToken || ''
                                });
                                
                                if (error) {
                                    console.error('Error setting session manually:', error);
                                } else if (data.session) {
                                    console.log('Session set manually successfully:', data.session);
                                    // Force transition
                                    localStorage.removeItem('otakonAuthMethod');
                                    setOnboardingStatus('initial');
                                    setView('app');
                                    
                                    // Force auth state update
                                    setAuthState({ user: data.session.user, session: data.session, loading: false, error: null });
                                }
                            } catch (error) {
                                console.error('Error in manual session creation:', error);
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('Error processing OAuth callback:', error);
                }
            } else {
                console.log('No OAuth callback parameters found');
            }
        };
        
        // Only check for OAuth callback if we're on the login screen
        if (onboardingStatus === 'login') {
            checkOAuthCallback();
        }
    }, [onboardingStatus]);

    // Direct app access - no migration needed
    useEffect(() => {
        // Check for developer mode first
        const isDeveloperMode = localStorage.getItem('otakon_developer_mode') === 'true';
        const authMethod = localStorage.getItem('otakonAuthMethod');
        const isDeveloperAuth = authMethod === 'skip';
        
        if (isDeveloperMode || isDeveloperAuth) {
            console.log('ðŸ”§ Developer mode detected, going directly to main app');
            setOnboardingStatus('complete');
            setView('app');
        } else if (authState.user && !authState.loading) {
            console.log('âœ… User authenticated, going directly to main app (no migration needed)');
            setOnboardingStatus('complete');
            setView('app');
        }
    }, [authState.user, authState.loading]);

    // Sync usage with Supabase when authenticated
    useEffect(() => {
        if (authState.user && !authState.loading) {
            refreshUsage();
        }
    }, [authState.user, authState.loading]);

    useEffect(() => {
        ttsService.init(); // Initialize TTS service on app load.

        const handler = (e: Event) => {
            e.preventDefault();
            console.log('beforeinstallprompt event captured.');
            // setInstallPrompt(e); // This line is removed
        };
        window.addEventListener('beforeinstallprompt', handler);
        return () => window.removeEventListener('beforeinstallprompt', handler);
    }, []);

    // Initialize PWA-related services
    useEffect(() => {
        const initializePWAServices = async () => {
            try {
                // Initialize offline storage
                if (offlineStorageService.isAvailable()) {
                    await offlineStorageService.initialize();
                    console.log('Offline storage initialized');
                }

                // Initialize app shortcuts
                if (appShortcutsService.isSupported()) {
                    await appShortcutsService.installShortcuts();
                    console.log('App shortcuts initialized');
                }

                // Track session start
                pwaAnalyticsService.trackSessionStart();
                console.log('PWA analytics initialized');

                // Note: Notification services are initialized on-demand, not at startup
                // to avoid confusing permission requests
                // 
                // IMPORTANT: Otakon does NOT need browser screen/audio permissions!
                // Screenshots are captured by the external PC client and sent via WebSocket.
                // The browser only displays the UI and processes chat responses.
                
            } catch (error) {
                console.error('Failed to initialize PWA services:', error);
            }
        };

        initializePWAServices();
    }, []);

    // Daily Engagement Effects
    useEffect(() => {
        console.log('Daily Engagement Effect - view:', view, 'onboardingStatus:', onboardingStatus, 'usage.tier:', usage.tier);
        
        // Show daily engagement during app usage
        if (view === 'app') {
            console.log('Checking daily engagement conditions...');
            
            // Check if we should show daily check-in (unchanged behavior)
            const shouldShowCheckin = dailyEngagementService.shouldShowDailyCheckin();
            console.log('Should show daily checkin:', shouldShowCheckin);
            if (shouldShowCheckin) {
                console.log('Setting showDailyCheckin to true');
                setShowDailyCheckin(true);
            }
            
            // Session continuation is handled after conversations are available
            

        }
    }, [view, onboardingStatus, usage.tier]);

    // Player Profile Setup Check - Only run once per session
    useEffect(() => {
        if (view === 'app' && onboardingStatus === 'complete') {
            // Check if user has already completed profile setup in this session
            const hasCheckedThisSession = sessionStorage.getItem('otakon_profile_checked_this_session') === 'true';
            
            if (!hasCheckedThisSession) {
                // Mark that we've checked this session to prevent repeated checks
                sessionStorage.setItem('otakon_profile_checked_this_session', 'true');
                
                console.log('ðŸ” Starting profile setup check');
                
                // Check if user needs profile setup using Supabase
                const checkProfileSetup = async () => {
                    try {
                        const needsProfile = await playerProfileService.needsProfileSetup();
                        console.log('ðŸ” Profile setup check result:', { needsProfile, isFirstTime });
                        
                        if (needsProfile) {
                            console.log('âœ… User needs profile setup - showing modal');
                            setIsFirstTime(true);
                            setShowProfileSetup(true);
                        } else {
                            console.log('âœ… User doesn\'t need profile setup - profile already exists');
                            // Profile already exists in Supabase, no need to mark anything
                        }
                    } catch (error) {
                        console.error('âŒ Error checking profile setup:', error);
                        // Fallback: show profile setup if there's an error
                        setIsFirstTime(true);
                        setShowProfileSetup(true);
                    }
                };
                checkProfileSetup();
            } else {
                console.log('ðŸ” Profile setup check skipped - already checked this session');
            }
        }
    }, [view, onboardingStatus]);

    const {
        conversations,
        conversationsOrder,
        reorderConversations,
        activeConversationId,
        activeConversation,
        loadingMessages,
        isCooldownActive,
        sendMessage,
        stopMessage,
        resetConversations,
        addSystemMessage,
        restoreHistory,
        switchConversation,
        fetchInsightContent,
        markInsightAsRead,
        saveConversationsToLocalStorage,
        pinConversation,
        deleteConversation,
        deleteInsight,
        reorderInsights,
        pendingModification,
        setPendingModification,
        overwriteInsight,
        createNewInsight,
        updateMessageFeedback,
        updateInsightFeedback,
        retryMessage,
        updateConversation, // ðŸ”¥ ADDED: For enhanced insights integration

    } = useChat(isHandsFreeMode);
    
    // NEW: Long-term session restoration on app startup
    useEffect(() => {
        const restoreLongTermSessions = async () => {
            if (authState.user && !authState.loading) {
                try {
                    console.log('ðŸ§  Restoring long-term sessions...');
                    
                    // Use statically imported services
                    
                    // Restore sessions for all active conversations
                    for (const [conversationId, conversation] of Object.entries(conversations)) {
                        if (conversationId !== 'everything-else') {
                            try {
                                // Initialize long-term session
                                await longTermMemoryService.initializeLongTermSession(conversationId, conversationId);
                                
                                // Restore context from database
                                await contextManagementService.restoreLongTermSession(conversationId);
                                
                                console.log(`âœ… Restored long-term session for: ${conversationId}`);
                            } catch (error) {
                                console.warn(`âš ï¸ Failed to restore session for ${conversationId}:`, error);
                            }
                        }
                    }
                    
                    console.log('ðŸ§  Long-term session restoration completed');
                } catch (error) {
                    console.error('âŒ Failed to restore long-term sessions:', error);
                }
            }
        };

        restoreLongTermSessions();
    }, [authState.user, authState.loading, conversations]);
    
    // Tutorial hook for first-time users
    const {
        isTutorialOpen,
        hasCompletedTutorial,
        shouldShowTutorial,
        openTutorial,
        closeTutorial,
        completeTutorial,
        skipTutorial
    } = useTutorial();
    
    // Helper function to get time-based greeting
    const getTimeGreeting = useCallback(() => {
        const currentHour = new Date().getHours();
        if (currentHour < 12) {
            return 'Good morning! ';
        } else if (currentHour < 17) {
            return 'Good afternoon! ';
        } else {
            return 'Good evening! ';
        }
    }, []);
    
    // Track first-time experience and show welcome message using Supabase
    useEffect(() => {
        const checkFirstTimeExperience = async () => {
            try {
                // Check if we should show welcome message using Supabase
                const shouldShow = await supabaseDataService.shouldShowWelcomeMessage();
                console.log('ðŸ” Supabase welcome message check:', { shouldShow, isFirstTime });
                
                if (shouldShow && isFirstTime) {
                    // Show welcome message for first-time users
                    const timeGreeting = getTimeGreeting();
                    
                    // Get user's first name for personalization
                    let firstName = '';
                    try {
                        const fullName = await profileService.getName();
                        if (fullName) {
                            const first = fullName.trim().split(' ')[0];
                            firstName = first ? `, ${first}` : '';
                        }
                    } catch (error) {
                        console.warn('Failed to get user name for welcome message:', error);
                    }
                    
                    const welcomeMessage = `${timeGreeting}Welcome to Otagon${firstName}!\n\n**Your Personal Gaming Companion**\n\n**What I can help you with:**\nâ€¢ Upload screenshots from games you're playing\nâ€¢ Get spoiler-free guidance and hints\nâ€¢ Discover secrets and strategies\nâ€¢ Track your gaming progress\nâ€¢ Answer questions about any game\n\n**Let's get started!** Upload a screenshot from a game you're currently playing, or just tell me what you'd like help with.`;
                    
                    console.log('Adding first-time welcome message:', welcomeMessage);
                    addSystemMessage(welcomeMessage, 'everything-else', false);
                    
                    // Update welcome message shown in Supabase
                    await supabaseDataService.updateWelcomeMessageShown('first_time');
                    
                    // Mark as no longer first-time
                    setIsFirstTime(false);
                }
                
                // Check if user has had conversations before
                const hasConversations = Object.keys(conversations).length > 1 || // More than just 'everything-else'
                    Object.values(conversations).some(conv => conv.messages && conv.messages.length > 0);
                
                if (hasConversations && isFirstTime) {
                    // User has had conversations, mark as no longer first-time
                    setIsFirstTime(false);
                    console.log('ðŸŽ¯ User has had conversations - no longer first-time');
                }
            } catch (error) {
                console.error('Error checking first-time experience:', error);
                // Fallback: show welcome message if there's an error
                if (isFirstTime) {
                    const timeGreeting = getTimeGreeting();
                    const welcomeMessage = `${timeGreeting}Welcome to Otagon!\n\n**Your Personal Gaming Companion**\n\n**What I can help you with:**\nâ€¢ Upload screenshots from games you're playing\nâ€¢ Get spoiler-free guidance and hints\nâ€¢ Discover secrets and strategies\nâ€¢ Track your gaming progress\nâ€¢ Answer questions about any game\n\n**Let's get started!** Upload a screenshot from a game you're currently playing, or just tell me what you'd like help with.`;
                    
                    console.log('Fallback: Adding first-time welcome message:', welcomeMessage);
                    addSystemMessage(welcomeMessage, 'everything-else', false);
                    setIsFirstTime(false);
                }
            }
        };
        
        checkFirstTimeExperience();
    }, [conversations, isFirstTime, addSystemMessage, getTimeGreeting]);
    
    // Enhanced Insights Hook
    const enhancedInsights = useEnhancedInsights(
        activeConversationId,
        activeConversation?.id,
        activeConversation?.genre,
        activeConversation?.progress,
        // ðŸ”¥ CRITICAL INTEGRATION: Connect enhanced insights to main conversation system
        (newInsights, newInsightsOrder) => {
            if (activeConversation && activeConversation.id !== 'everything-else') {
                console.log('ðŸ”„ Enhanced insights callback triggered for conversation:', activeConversation.id);
                console.log('ðŸ”„ New insights received:', newInsights);
                console.log('ðŸ”„ New insights order:', newInsightsOrder);
                
                // Always ensure Otaku Diary tab exists and is preserved
                const otakuDiaryInsight = {
                    id: 'otaku-diary',
                    title: 'ðŸ“– Otaku Diary',
                    content: 'ðŸ“ **Your Personal Game Diary**\n\nâœ¨ Track your tasks and favorite moments\n\nðŸŽ¯ **Features:**\nâ€¢ Create and manage to-do lists\nâ€¢ Save favorite AI responses and insights\nâ€¢ Track your gaming progress\nâ€¢ Organize your thoughts and discoveries\n\nðŸš€ **Available for all users!**',
                    status: 'loaded' as const,
                    isNew: false,
                    lastUpdated: Date.now()
                };
                
                // Start with existing insights to preserve Otaku Diary
                const existingInsights = activeConversation.insights || {};
                
                // Add enhanced insights, but ensure Otaku Diary is preserved
                const updatedInsights = { 
                    ...existingInsights,  // Keep existing insights (including Otaku Diary)
                    ...newInsights,       // Add enhanced insights
                    'otaku-diary': otakuDiaryInsight // Always ensure Otaku Diary exists
                };
                
                // Create insights order with Otaku Diary first, then existing insights, then enhanced insights
                const existingOrder = activeConversation.insightsOrder || [];
                const enhancedOrder = newInsightsOrder.filter(id => id !== 'otaku-diary'); // Remove Otaku Diary from enhanced order
                const updatedInsightsOrder = ['otaku-diary', ...existingOrder.filter(id => id !== 'otaku-diary'), ...enhancedOrder];
                
                // Remove duplicates from insightsOrder
                const uniqueInsightsOrder = [...new Set(updatedInsightsOrder)];
                
                console.log('ðŸ”„ Final updated insights:', updatedInsights);
                console.log('ðŸ”„ Final updated insights order:', uniqueInsightsOrder);
                
                // Update the conversation with new insights
                updateConversation(activeConversation.id, (convo) => ({
                    ...convo,
                    insights: updatedInsights,
                    insightsOrder: uniqueInsightsOrder
                }));
                
                console.log(`ðŸ”„ Integrated ${Object.keys(newInsights).length} enhanced insights to conversation: ${activeConversation.id} (Otaku Diary preserved and prioritized)`);
            }
        }
    );
    
    // ðŸ”¥ CRITICAL INTEGRATION: Ensure all game conversations have Otaku Diary tab
    useEffect(() => {
        if (activeConversation && activeConversation.id !== 'everything-else') {
            // Add a safeguard to prevent running this effect too many times for the same conversation
            const hasRunKey = `otaku-diary-check-${activeConversation.id}`;
            if (sessionStorage.getItem(hasRunKey)) {
                console.log(`âœ… Otaku Diary check already completed for conversation: ${activeConversation.id}`);
                return;
            }
            
            console.log(`ðŸ” Checking Otaku Diary for conversation: ${activeConversation.id}`);
            console.log(`ðŸ” Current insights:`, activeConversation.insights);
            console.log(`ðŸ” Current insightsOrder:`, activeConversation.insightsOrder);
            console.log(`ðŸ” Current activeSubView:`, activeSubView);
            
            const hasOtakuDiary = activeConversation.insights?.['otaku-diary'];
            
            if (!hasOtakuDiary) {
                console.log(`ðŸ”„ Adding missing Otaku Diary tab to conversation: ${activeConversation.id}`);
                
                // Create Otaku Diary tab
                const otakuDiaryInsight = {
                    id: 'otaku-diary',
                    title: 'ðŸ“– Otaku Diary',
                    content: 'ðŸ“ **Your Personal Game Diary**\n\nâœ¨ Track your tasks and favorite moments\n\nðŸŽ¯ **Features:**\nâ€¢ Create and manage to-do lists\nâ€¢ Save favorite AI responses and insights\nâ€¢ Track your gaming progress\nâ€¢ Organize your thoughts and discoveries\n\nðŸš€ **Available for all users!**',
                    status: 'loaded' as const,
                    isNew: false,
                    lastUpdated: Date.now()
                };
                
                // Update conversation with Otaku Diary tab
                const updatedInsights = { ...(activeConversation.insights || {}), 'otaku-diary': otakuDiaryInsight };
                const updatedInsightsOrder = ['otaku-diary', ...(activeConversation.insightsOrder || []).filter(id => id !== 'otaku-diary')];
                
                // Remove duplicates from insightsOrder
                const uniqueInsightsOrder = [...new Set(updatedInsightsOrder)];
                
                updateConversation(activeConversation.id, (convo) => ({
                    ...convo,
                    insights: updatedInsights,
                    insightsOrder: uniqueInsightsOrder
                }));
                
                console.log(`âœ… Added Otaku Diary tab to conversation: ${activeConversation.id}`);
                console.log(`âœ… Updated insights:`, updatedInsights);
                console.log(`âœ… Updated insightsOrder:`, uniqueInsightsOrder);
            } else {
                console.log(`âœ… Otaku Diary tab already exists for conversation: ${activeConversation.id}`);
            }
            
            // Mark this check as completed
            sessionStorage.setItem(hasRunKey, 'true');
        }
    }, [activeConversation?.id]); // Only depend on the ID, not the entire object or updateConversation
    
    // ðŸ”¥ AGGRESSIVE INTEGRATION: Force Otaku Diary tab creation for all game conversations
    useEffect(() => {
        // Only run this effect once when conversations are first loaded, not on every change
        if (Object.keys(conversations).length === 0) return;
        
        // Add a safeguard to prevent running this effect too many times
        const hasRunKey = `otaku-diary-integration-${Object.keys(conversations).length}`;
        if (sessionStorage.getItem(hasRunKey)) {
            console.log('âœ… Otaku Diary integration already completed for current conversation set');
            return;
        }
        
        // Get all game conversations (excluding 'everything-else')
        const gameConversations = Object.values(conversations).filter(conv => conv.id !== 'everything-else');
        
        // Check if any conversations need Otaku Diary tabs
        const conversationsNeedingOtakuDiary = gameConversations.filter(conversation => 
            !conversation.insights?.['otaku-diary']
        );
        
        if (conversationsNeedingOtakuDiary.length === 0) {
            console.log('âœ… All game conversations already have Otaku Diary tabs');
            sessionStorage.setItem(hasRunKey, 'true');
            return;
        }
        
        console.log(`ðŸ”„ Adding Otaku Diary tabs to ${conversationsNeedingOtakuDiary.length} conversations`);
        
        conversationsNeedingOtakuDiary.forEach(conversation => {
            console.log(`ðŸ”„ Force-adding Otaku Diary tab to conversation: ${conversation.id}`);
            
            // Create Otaku Diary tab
            const otakuDiaryInsight = {
                id: 'otaku-diary',
                title: 'ðŸ“– Otaku Diary',
                content: 'ðŸ“ **Your Personal Game Diary**\n\nâœ¨ Track your tasks and favorite moments\n\nðŸŽ¯ **Features:**\nâ€¢ Create and manage to-do lists\nâ€¢ Save favorite AI responses and insights\nâ€¢ Track your gaming progress\nâ€¢ Organize your thoughts and discoveries\n\nðŸš€ **Available for all users!**',
                status: 'loaded' as const,
                isNew: false,
                lastUpdated: Date.now()
            };
            
            // Update conversation with Otaku Diary tab
            const updatedInsights = { ...(conversation.insights || {}), 'otaku-diary': otakuDiaryInsight };
            const updatedInsightsOrder = ['otaku-diary', ...(conversation.insightsOrder || []).filter(id => id !== 'otaku-diary')];
            
            // Remove duplicates from insightsOrder
            const uniqueInsightsOrder = [...new Set(updatedInsightsOrder)];
            
            updateConversation(conversation.id, (convo) => ({
                ...convo,
                insights: updatedInsights,
                insightsOrder: uniqueInsightsOrder
            }));
            
            console.log(`âœ… Force-added Otaku Diary tab to conversation: ${conversation.id}`);
        });
        
        // Mark this integration as completed
        sessionStorage.setItem(hasRunKey, 'true');
    }, [conversations]); // Remove updateConversation dependency to prevent infinite loop
    
    // Enhanced suggested prompts logic that can access conversations
    const shouldShowSuggestedPromptsEnhanced = useCallback((): boolean => {
        // Only show suggested prompts based on normal logic, not development mode
        
        // Show prompts if:
        // 1. First run experience (isFirstTime is true)
        // 2. No messages in conversation (first time or cleared)
        // 3. User hasn't interacted with chat yet (no text queries or images)
        // 4. Game pill hasn't been created yet (keep available in "Everything Else" tab)
        // 5. No loading messages (hide when user is actively interacting)
        
        const hasInteractedWithChat = localStorage.getItem('otakon_has_interacted_with_chat') === 'true';
        const hasGamePill = Object.keys(conversations).some(id => id !== 'everything-else');
        const hasLoadingMessages = loadingMessages.length > 0;
        
        // Don't show prompts if there are loading messages (user is actively interacting)
        if (hasLoadingMessages) {
            return false;
        }
        
        return isFirstTime || 
               lastSuggestedPromptsShown === 0 || 
               (!hasInteractedWithChat && !hasGamePill);
    }, [lastSuggestedPromptsShown, isFirstTime, conversations, loadingMessages]);
    
    // Function to reset interaction state for testing purposes
    const resetInteractionState = useCallback(() => {
        localStorage.removeItem('otakon_has_interacted_with_chat');
        localStorage.removeItem('otakon_profile_setup_completed');
        localStorage.removeItem('otakon_welcome_message_shown');
        localStorage.removeItem('otakon_last_session_date');
        localStorage.removeItem('otakon_developer_mode'); // Clear developer mode flag
        localStorage.removeItem('otakonAuthMethod'); // Clear auth method
        localStorage.removeItem('otakonOnboardingComplete'); // Clear onboarding completion
        setLastSuggestedPromptsShown(0);
        
        // Reset suggested prompts so all 4 are available again
        suggestedPromptsService.resetUsedPrompts();
        
        // Reset welcome message tracking for testing
        try {
            supabaseDataService.resetWelcomeMessageTracking();
            console.log('ðŸ”„ Welcome message tracking reset for testing');
        } catch (error) {
            console.warn('Failed to reset welcome message tracking:', error);
        }
        
        console.log('ðŸ”„ Interaction state reset - suggested prompts and welcome message will be visible again');
    }, []);
    
    // Database synchronization function
    const syncToDatabase = useCallback(async () => {
        if (!authState.user) return;
        
        try {
            setDatabaseSyncStatus('syncing');
            
            // Sync player profile
            const profile = await playerProfileService.getProfile();
            if (profile) {
                await databaseService.syncPlayerProfile(profile);
            }
            
            // Sync game contexts for all conversations
            // Use current conversations state directly to avoid circular dependency
            const currentConversations = conversations;
            for (const [conversationId, conversation] of Object.entries(currentConversations)) {
                if (conversation.id !== 'everything-else') {
                    const gameContext = await playerProfileService.getGameContext(conversation.id);
                    if (gameContext) {
                        await databaseService.syncGameContext(conversation.id, gameContext);
                    }
                }
            }
            
            setDatabaseSyncStatus('success');
            setLastDatabaseSync(Date.now());
            
            // Reset status after 3 seconds
            setTimeout(() => setDatabaseSyncStatus('idle'), 3000);
            
        } catch (error) {
            console.error('Database sync failed:', error);
            setDatabaseSyncStatus('error');
            
            // Reset status after 5 seconds
            setTimeout(() => setDatabaseSyncStatus('idle'), 5000);
        }
    }, [authState.user]); // Remove conversations dependency to prevent circular dependency
    
    // Auto-sync to database when user is authenticated
    useEffect(() => {
        if (authState.user && databaseSyncStatus === 'idle') {
            // Sync after a short delay to ensure app is fully loaded
            const syncTimer = setTimeout(() => {
                syncToDatabase();
            }, 2000);
            
            return () => clearTimeout(syncTimer);
        }
    }, [authState.user, syncToDatabase]);
    
    // Function to log current stop flag status (for debugging)
    const logStopFlagStatus = useCallback(() => {
        const timeSinceLastStop = Date.now() - lastStopTime.current;
        console.log(`ðŸ“Š Stop Flag Status:`, {
            isStopped: isStopped.current,
            timeSinceLastStop: `${timeSinceLastStop}ms`,
            cooldownRemaining: Math.max(0, STOP_COOLDOWN_MS - timeSinceLastStop),
            hasTimeout: !!stopTimeoutRef.current,
            timeoutId: stopTimeoutRef.current
        });
    }, []);
    
    // Wrapper for stopMessage that records when stop is pressed
    const handleStopMessage = useCallback((messageId: string) => {
        console.log(`ðŸ›‘ Stop requested for message: ${messageId}`);
        
        // Clear any existing stop timeout
        if (stopTimeoutRef.current) {
            clearTimeout(stopTimeoutRef.current);
            stopTimeoutRef.current = null;
        }
        
        lastStopTime.current = Date.now();
        isStopped.current = true; // Set global stop flag
        console.log(`â° Stop cooldown started, will prevent new analysis for ${STOP_COOLDOWN_MS}ms`);
        console.log(`ðŸš« Global stop flag set - no new analysis will start`);
        logStopFlagStatus(); // Log the status change
        stopMessage(messageId);
        
        // Reset the stop flag after cooldown period
        stopTimeoutRef.current = setTimeout(() => {
            isStopped.current = false;
            stopTimeoutRef.current = null;
            console.log(`âœ… Global stop flag reset - new analysis can start`);
            logStopFlagStatus(); // Log the status change
        }, STOP_COOLDOWN_MS);
    }, [stopMessage, logStopFlagStatus]);
    
    // Function to manually reset the stop flag (for debugging)
    const resetStopFlag = useCallback(() => {
        console.log(`ðŸ”„ Manually resetting stop flag`);
        if (stopTimeoutRef.current) {
            clearTimeout(stopTimeoutRef.current);
            stopTimeoutRef.current = null;
        }
        isStopped.current = false;
        lastStopTime.current = 0;
        console.log(`âœ… Stop flag manually reset`);
        logStopFlagStatus(); // Log the status change
    }, [logStopFlagStatus]);
    
     useEffect(() => {
        const handleBeforeUnload = () => {
            console.log('beforeunload event triggered. Forcing save of conversations.');
            saveConversationsToLocalStorage();
        };
        window.addEventListener('beforeunload', handleBeforeUnload);
        return () => {
            window.removeEventListener('beforeunload', handleBeforeUnload);
        };
    }, [saveConversationsToLocalStorage]);

    useEffect(() => {
        const disableHandsFree = () => {
            console.log("Hands-free mode disabled via media controls.");
            setIsHandsFreeMode(false);
        };
        
        const closeContextMenu = () => setContextMenu(null);
        window.addEventListener('otakon:disableHandsFree', disableHandsFree);
        window.addEventListener('focus', refreshUsage);
        window.addEventListener('click', closeContextMenu);
        window.addEventListener('scroll', closeContextMenu, true);


        return () => {
            window.removeEventListener('otakon:disableHandsFree', disableHandsFree);
            window.removeEventListener('focus', refreshUsage);
            window.removeEventListener('click', closeContextMenu);
            window.removeEventListener('scroll', closeContextMenu, true);
        };
    }, []);

    useEffect(() => {
        const audioEl = silentAudioRef.current;
        if (audioEl) {
            if (isHandsFreeMode) {
                audioEl.play().catch(error => {
                    console.warn("Silent audio playback failed to start:", error);
                    addSystemMessage("Could not activate background audio. If audio stops when the screen is off, please tap the screen and toggle Hands-Free mode again.");
                });
                console.log("Playing silent audio to maintain background execution for Hands-Free mode.");
            } else {
                audioEl.pause();
                audioEl.currentTime = 0;
                console.log("Paused silent audio.");
            }
        }
    }, [isHandsFreeMode, addSystemMessage]);

    // Helper function to display screenshots in chat
    const displayScreenshotInChat = useCallback((img: HTMLImageElement, index: number, total: number, processImmediate: boolean, timestamp: number) => {
        console.log(`ðŸ–¼ï¸ Displaying screenshot ${index}/${total} in chat`);
        
        // Create image data object for your app's format
        const imageData = {
            base64: img.src.split(',')[1] || img.src,
            mimeType: 'image/png',
            dataUrl: img.src,
            source: `connector_single_${index}`
        };
        
        // Add to images for review if not processing immediately
        if (!processImmediate) {
            setImagesForReview(prevImages => {
                const limit = usage.tier === 'pro' ? 5 : 1;
                const newImages = [...prevImages, imageData];
                if (newImages.length > limit) {
                    addSystemMessage(`You can add a maximum of ${limit} image(s) for review.`);
                    return newImages.slice(-limit);
                }
                return newImages;
            });
        }
        
        // If processing immediately, send for analysis
        if (processImmediate) {
            // Check if we're globally stopped
            if (isStopped.current) {
                console.log("ðŸš« Analysis blocked - global stop flag is active");
                addSystemMessage("Analysis is currently stopped. Please wait a moment before sending new screenshots.");
                return;
            }
            
            if (usage.tier === 'free' && loadingMessages.length > 0) {
                addSystemMessage("An analysis is already in progress. Please wait for it to complete before sending new screenshots.");
                return;
            }
            
            // Send message with image for AI analysis
            sendMessage('', [imageData], true);
        }
    }, [usage.tier, loadingMessages, addSystemMessage, sendMessage]);

    // Helper function to process screenshots automatically
    const processScreenshotAutomatically = useCallback(async (imageData: any, index: number, total: number) => {
        console.log(`ðŸ¤– Auto-processing screenshot ${index}/${total}`);
        
        // The image is already being processed by sendMessage above
        // This function can be used for additional processing if needed
        console.log(`âœ… Screenshot ${index}/${total} auto-processing initiated`);
    }, []);

    // Note: Old multi-shot grouping functions removed - PC client now sends screenshot_batch messages

    // Dedicated function for displaying multi-shot batches
    const displayMultiShotBatch = useCallback(async (imageDataArray: any[], processImmediate: boolean) => {
        console.log(`ðŸ”„ displayMultiShotBatch called with ${imageDataArray.length} images:`, imageDataArray);
        
        // âœ… CORRECT: Pass all images as separate ImageFile objects to sendMessage
        // sendMessage will group them together in one user message
        const formattedImageFiles = imageDataArray.map((imgData, index) => ({
            base64: imgData.base64,
            mimeType: imgData.mimeType || 'image/png',
            dataUrl: imgData.dataUrl,
            source: imgData.source
        }));
        
        console.log(`ðŸ”„ Processing multi-shot batch with ${formattedImageFiles.length} images:`, formattedImageFiles.map(f => f.source));
        console.log(`ðŸ”„ Formatted image files:`, formattedImageFiles.map(f => ({
            source: f.source,
            dataUrlLength: f.dataUrl?.length || 0,
            base64Length: f.base64?.length || 0
        })));
        
        // NEW: Track multishot timeline in screenshot timeline service
        if (activeConversationId && activeConversationId !== 'everything-else') {
            try {
                const { screenshotTimelineService } = await import('./services/screenshotTimelineService');
                await screenshotTimelineService.trackMultiScreenshot(
                    activeConversationId,
                    imageDataArray,
                    Date.now(),
                    activeConversationId, // gameId
                    activeConversation?.title, // gameName
                    false // isGameSwitch - will be updated later if game switch occurs
                );
                console.log(`ðŸ“¸ Tracked multi-shot timeline: ${imageDataArray.length} screenshots`);
            } catch (error) {
                console.warn('Failed to track multishot timeline:', error);
            }
        }
        
        // Use sendMessage to display the images grouped together in one message
        // sendMessage will create one userMessage with all images in the images array
        const isSingleScreenshot = formattedImageFiles.length === 1;
        const timelineMessage = isSingleScreenshot 
            ? `ðŸ“¸ Single screenshot uploaded`
            : `ðŸ“¸ Multi-shot timeline: ${formattedImageFiles.length} screenshots showing progression over the last 5 minutes`;
        const result = await sendMessage(timelineMessage, formattedImageFiles, true);
        
        if (processImmediate) {
            console.log(`ðŸš€ Multi-shot batch sent for AI analysis`);
        }
        
        console.log(`âœ… Multi-shot batch displayed successfully with ${formattedImageFiles.length} images grouped together`);
        
        // Verify the images were added to the conversation
        const currentConvo = conversations[activeConversationId];
        if (currentConvo && currentConvo.messages.length > 0) {
            const lastMessage = currentConvo.messages[currentConvo.messages.length - 2]; // User message (before AI placeholder)
            if (lastMessage && lastMessage.images && lastMessage.images.length > 0) {
                console.log(`âœ… Verified: ${lastMessage.images.length} images added to conversation`);
            } else {
                console.warn(`âš ï¸ Warning: No images found in last user message`);
            }
        }
    }, [sendMessage, conversations, activeConversationId]);

    const handleScreenshotReceived = useCallback(async (data: any) => {
        if (data.type === 'history_restore') {
            if (data.payload && Object.keys(data.payload).length > 0) {
                 console.log("Restoring conversation from server...");
                 restoreHistory(data.payload as Conversations);
            } else {
                 console.log("No history on server or empty history received.");
            }
            setHasRestored(true);
            return;
        } 
        
        // Handle screenshot_batch from enhanced connector
        else if (data.type === 'screenshot_batch') {
            setActiveSubView('chat');
            
            console.log("ðŸ“¸ Processing screenshot batch:", data);
            
            // Extract data from payload if it exists, otherwise use data directly
            const batchData = data.payload || data;
            
            // Check if we've already processed this batch (prevent duplicates)
            // Use a more robust key that includes the actual image content hash
            const firstImageHash = batchData.images?.[0]?.substring(batchData.images[0].length - 100) || 'no_images';
            const batchKey = `batch_${batchData.timestamp}_${batchData.images?.length}_${firstImageHash}`;
            
            if (processedBatches.current.has(batchKey)) {
                console.log("âš ï¸ Duplicate batch detected, skipping:", batchKey);
                return;
            }
            
            // Add to processed set BEFORE processing to prevent race conditions
            processedBatches.current.add(batchKey);
            
            // Clean up old entries to prevent memory leaks (keep only last 100)
            if (processedBatches.current.size > 100) {
                const entries = Array.from(processedBatches.current);
                processedBatches.current.clear();
                entries.slice(-50).forEach(entry => processedBatches.current.add(entry));
            }
            
            try {
                const { images, processImmediate } = batchData;
                
                if (!images || !Array.isArray(images) || images.length === 0) {
                    console.warn("âš ï¸ Invalid screenshot batch payload - no images");
                    return;
                }
                
                // Convert base64 strings to image data objects
                const imageDataArray = images.map((imageData: string, index: number) => {
                    // Handle both formats: base64 string or full data URL
                    let base64: string;
                    let dataUrl: string;
                    
                    console.log(`ðŸ“¸ Processing image ${index + 1}:`, {
                        originalLength: imageData.length,
                        startsWithDataUrl: imageData.startsWith('data:image/'),
                        firstChars: imageData.substring(0, 50),
                        lastChars: imageData.substring(imageData.length - 20)
                    });
                    
                    if (imageData.startsWith('data:image/')) {
                        // Already a data URL
                        dataUrl = imageData;
                        base64 = imageData.split(',')[1] || imageData;
                        console.log(`ðŸ“¸ Image ${index + 1}: Already data URL format`);
                    } else {
                        // Base64 string - convert to data URL
                        dataUrl = `data:image/png;base64,${imageData}`;
                        base64 = imageData;
                        console.log(`ðŸ“¸ Image ${index + 1}: Converted base64 to data URL`);
                    }
                    
                    return {
                        base64,
                        mimeType: 'image/png', // Connector sends PNG format
                        dataUrl,
                        source: `connector_batch_${index + 1}`
                    };
                });
                
                if (processImmediate) {
                    // Check if we're globally stopped
                    if (isStopped.current) {
                        // Check if the stop flag has been stuck for too long (more than 10 seconds)
                        const timeSinceLastStop = Date.now() - lastStopTime.current;
                        if (timeSinceLastStop > 10000) { // 10 seconds
                            console.log("âš ï¸ Stop flag stuck for too long, auto-resetting");
                            resetStopFlag();
                        } else {
                            console.log("ðŸš« Analysis blocked - global stop flag is active");
                            addSystemMessage("Analysis is currently stopped. Please wait a moment before sending new screenshots.");
                            return;
                        }
                    }
                    
                    // Auto-process mode - display and analyze immediately
                    // Allow multiple screenshots to be processed simultaneously for better UX
                    if (usage.tier === 'free' && loadingMessages.length > 0) {
                        // For free users, allow up to 1 concurrent analysis
                        console.log("âš ï¸ Free user - analysis in progress, but will queue multi-shot batch");
                        // Don't return, continue processing
                    }
                    
                    // Check if we're in cooldown period after stop was pressed
                    const timeSinceLastStop = Date.now() - lastStopTime.current;
                    if (timeSinceLastStop < STOP_COOLDOWN_MS) {
                        console.log(`âš ï¸ Stop cooldown active (${STOP_COOLDOWN_MS - timeSinceLastStop}ms remaining), skipping multi-shot batch`);
                        addSystemMessage("Please wait a moment after stopping before sending new screenshots.");
                        return;
                    }
                    
                    // Add system message to show batch receipt
                    addSystemMessage(`ðŸ“¸ Multi-shot batch received: ${imageDataArray.length} screenshots captured`);
                    
                    // Display the batch and send for analysis using our dedicated function
                    await displayMultiShotBatch(imageDataArray, true);
                } else {
                    // Manual review mode - just display the batch
                    await displayMultiShotBatch(imageDataArray, false);
                }
                
                setIsConnectionModalOpen(false);
                console.log("âœ… Screenshot batch processing completed successfully");
            } catch (e) {
                const errorText = e instanceof Error ? e.message : 'Unknown error processing screenshot batch.';
                console.error("âŒ Failed to process screenshot batch:", e);
                addSystemMessage(`Failed to process received screenshots. ${errorText}`);
            }
            return;
        }
        
        // Handle individual screenshot messages from PC client (single and multi-shot)
        else if (data.type === 'screenshot') {
            setActiveSubView('chat');
            
            console.log("ðŸ“¸ Processing individual screenshot:", data);
            
            // Extract data from payload if it exists, otherwise use data directly
            const screenshotData = data.payload || data;
            
            try {
                const { dataUrl, index, total, processImmediate, timestamp } = screenshotData;
                
                // Validate image data
                if (!dataUrl || !dataUrl.startsWith('data:image/')) {
                    console.error('âŒ Invalid image data received');
                    addSystemMessage('Invalid image data received from PC client.');
                    return;
                }
                
                // Create image data object
                const imageData = {
                    base64: dataUrl.split(',')[1] || dataUrl,
                    mimeType: 'image/png',
                    dataUrl: dataUrl,
                    source: `connector_single_${index + 1}`
                };
                
                // Check if we've already processed this screenshot (prevent duplicates)
                // Use a more robust key that includes the actual image content hash
                const imageHash = dataUrl.substring(dataUrl.length - 100); // Last 100 chars for uniqueness
                const singleShotKey = `screenshot_${index}_${total}_${timestamp || Date.now()}_${imageHash}`;
                
                if (processedSingleShots.current.has(singleShotKey)) {
                    console.log("âš ï¸ Duplicate single shot detected, skipping:", singleShotKey);
                    return;
                }
                
                // Add to processed set BEFORE processing to prevent race conditions
                processedSingleShots.current.add(singleShotKey);
                
                // Clean up old entries to prevent memory leaks (keep only last 100)
                if (processedSingleShots.current.size > 100) {
                    const entries = Array.from(processedSingleShots.current);
                    processedSingleShots.current.clear();
                    entries.slice(-50).forEach(entry => processedSingleShots.current.add(entry));
                }
                
                // Check if this is part of a multi-shot sequence
                if (total > 1) {
                    console.log(`ðŸ”„ Multi-shot detected: ${index + 1}/${total} - but PC client should send screenshot_batch instead`);
                    console.log(`âš ï¸ This individual screenshot handling is deprecated. PC client should send screenshot_batch.`);
                    console.log(`âŒ REJECTING individual screenshot with total > 1 - this should be a screenshot_batch message`);
                    
                    // Remove from processed set since we're rejecting it
                    processedSingleShots.current.delete(singleShotKey);
                    
                    // Don't add any system message to avoid spam
                    return;
                } else {
                    // Single screenshot - process normally
                    console.log(`ðŸ“¸ Single screenshot - processing normally`);
                    
                    if (processImmediate) {
                        // Check if we're globally stopped
                        if (isStopped.current) {
                            // Check if the stop flag has been stuck for too long (more than 10 seconds)
                            const timeSinceLastStop = Date.now() - lastStopTime.current;
                            if (timeSinceLastStop > 10000) { // 10 seconds
                                console.log(`âš ï¸ Stop flag stuck for ${timeSinceLastStop}ms, auto-resetting`);
                                resetStopFlag();
                            } else {
                                console.log(`ðŸš« Analysis blocked - global stop flag is active`);
                                addSystemMessage("Analysis is currently stopped. Please wait a moment before sending new screenshots.");
                                return;
                            }
                        }
                        
                        // Auto-process mode - allow multiple screenshots to be processed
                        if (usage.tier === 'free' && loadingMessages.length > 0) {
                            // For free users, allow up to 1 concurrent analysis
                            console.log(`âš ï¸ Free user - analysis in progress, but will queue single shot`);
                            // Don't return, continue processing
                        }
                        
                        // Check if we're in cooldown period after stop was pressed
                        const timeSinceLastStop = Date.now() - lastStopTime.current;
                        if (timeSinceLastStop < STOP_COOLDOWN_MS) {
                            console.log(`âš ï¸ Stop cooldown active (${STOP_COOLDOWN_MS - timeSinceLastStop}ms remaining), skipping single shot`);
                            // Only show cooldown message once to avoid spam
                            if (!cooldownMessageShown.current) {
                                addSystemMessage("Please wait a moment after stopping before sending new screenshots.");
                                cooldownMessageShown.current = true;
                                // Reset the flag after cooldown period
                                setTimeout(() => {
                                    cooldownMessageShown.current = false;
                                }, STOP_COOLDOWN_MS);
                            }
                            return;
                        }
                        
                        // NEW: Track single screenshot timeline
                        if (activeConversationId && activeConversationId !== 'everything-else') {
                            try {
                                const { screenshotTimelineService } = await import('./services/screenshotTimelineService');
                                await screenshotTimelineService.trackSingleScreenshot(
                                    activeConversationId,
                                    imageData,
                                    timestamp || Date.now(),
                                    activeConversationId, // gameId
                                    activeConversation?.title, // gameName
                                    false // isGameSwitch - will be updated later if game switch occurs
                                );
                                console.log(`ðŸ“¸ Tracked single screenshot timeline`);
                            } catch (error) {
                                console.warn('Failed to track single screenshot timeline:', error);
                            }
                        }
                        
                        // Process immediately - sendMessage will handle the display
                        await sendMessage('ðŸ“¸ Single screenshot showing current game state', [imageData], true);
                        
                    } else {
                        // Manual review mode
                        if (usage.tier === 'free' && imagesForReview.length > 0) {
                            // Only show this message once, don't spam the user
                            console.log(`âš ï¸ Manual review queue has images, skipping single shot`);
                            return;
                        }
                        
                        // NEW: Track single screenshot timeline for manual review
                        if (activeConversationId && activeConversationId !== 'everything-else') {
                            try {
                                const { screenshotTimelineService } = await import('./services/screenshotTimelineService');
                                await screenshotTimelineService.trackSingleScreenshot(
                                    activeConversationId,
                                    imageData,
                                    timestamp || Date.now(),
                                    activeConversationId, // gameId
                                    activeConversation?.title, // gameName
                                    false // isGameSwitch - will be updated later if game switch occurs
                                );
                                console.log(`ðŸ“¸ Tracked single screenshot timeline (manual review)`);
                            } catch (error) {
                                console.warn('Failed to track single screenshot timeline:', error);
                            }
                        }
                        
                        // Display in chat and add to review queue
                        displayScreenshotInChat(new Image(), 1, 1, false, timestamp);
                        setImagesForReview(prevImages => {
                            const limit = usage.tier === 'pro' ? 5 : 1;
                            const newImages = [...prevImages, imageData];
                            if (newImages.length > limit) {
                                addSystemMessage(`You can add a maximum of ${limit} image(s) for review.`);
                                return newImages.slice(-limit);
                            }
                            return newImages;
                        });
                    }
                }
                
                setIsConnectionModalOpen(false);
                console.log("âœ… Screenshot processing completed successfully");
                
            } catch (e) {
                const errorText = e instanceof Error ? e.message : 'Unknown error processing screenshot.';
                console.error("âŒ Failed to process screenshot:", e);
                addSystemMessage(`Failed to process received screenshot. ${errorText}`);
            }
            return;
        }
        
        // Handle other message types
        if (data.type === 'connection_test') {
            console.log('âœ… Connection test received from PC client');
            addSystemMessage("Connection test successful - PC client is ready!");
            return;
        } else if (data.type === 'partner_connected') {
            console.log("Partner PC client has connected.");
        } else {
            console.warn("Received unexpected WebSocket message:", data);
        }
    }, [sendMessage, addSystemMessage, restoreHistory, isManualUploadMode, usage.tier, imagesForReview, loadingMessages]);

    const {
        status: connectionStatus,
        error: connectionError,
        connect,
        disconnect,
        connectionCode,
        send,

        lastSuccessfulConnection,
        forceReconnect,
    } = useConnection(handleScreenshotReceived);
    
    const testConnection = useCallback(() => {
        if (send) {
            console.log("ðŸ§ª Testing WebSocket connection...");
            console.log("âœ… WebSocket is connected and ready");
            console.log(`Connection code: ${connectionCode}`);
            console.log(`Relay URL: wss://otakon-relay.onrender.com/${connectionCode}`);
            send({ type: 'test_connection' });
        } else {
            console.log("âŒ WebSocket not connected");
        }
    }, [send, connectionCode]);

    const prevLoadingMessagesRef = useRef(loadingMessages);

    useEffect(() => {
        const wasLoading = prevLoadingMessagesRef.current.length > 0;
        const isNotLoading = loadingMessages.length === 0;

        if (wasLoading && isNotLoading) {
            if (connectionStatus === ConnectionStatus.CONNECTED && hasRestored && send) {
                console.log("Syncing conversation history after message completion.");
                send({ type: 'save_history', payload: conversations });
            }
        }
        
        prevLoadingMessagesRef.current = loadingMessages;

    }, [loadingMessages, conversations, connectionStatus, hasRestored, send]);

    const messages = activeConversation?.messages ?? [];
    
    useEffect(() => {
        // Auto-scroll to show latest AI response when generating or generated
        if (messages.length > 0 || loadingMessages.length > 0) {
            chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
        }
    }, [messages, loadingMessages]);
    

    const scrollToBottom = () => {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(() => {
        const hasConnectedBefore = localStorage.getItem('otakonHasConnectedBefore') === 'true';

        if (connectionStatus === ConnectionStatus.CONNECTED) {
            if (!hasConnectedBefore) {
                // First time connecting - show proper splash screen progression
                localStorage.setItem('otakonHasConnectedBefore', 'true');
                setIsConnectionModalOpen(false);
                
                // Check current onboarding status to determine next screen
                if (onboardingStatus === 'features') {
                    // If we're in features screen, go to pro-features next
                    setOnboardingStatus('pro-features');
                    console.log('ðŸŽ‰ First PC connection! Showing "Pro Features" splash screen');
                } else if (onboardingStatus === 'initial') {
                    // If we're in initial screen, go to pro-features
                    setOnboardingStatus('pro-features');
                    console.log('ðŸŽ‰ First PC connection! Showing "Pro Features" splash screen');
                } else {
                    // Default case - show pro-features
                    setOnboardingStatus('pro-features');
                    console.log('ðŸŽ‰ First PC connection! Showing "Pro Features" splash screen');
                }
            } else {
                // Returning user - automatically show chat screen
                setIsConnectionModalOpen(false);
                setView('app');
                console.log('ðŸ”„ Returning user connected! Showing chat screen');
            }
        }
    }, [connectionStatus, onboardingStatus]);
    
    useEffect(() => {
        return () => {
            disconnect();
        };
    }, [disconnect]);
    

    const completeOnboarding = useCallback(() => {
        localStorage.setItem('otakonOnboardingComplete', 'true');
        setOnboardingStatus('complete');
    }, []);

    const handleDisconnect = useCallback(() => {
        disconnect();
        setIsConnectionModalOpen(false);
    }, [disconnect]);

    const executeFullReset = useCallback(async () => {
        try {
            // First, clear local data and reset services while still authenticated
            if (send) {
                send({ type: 'clear_history' });
            }
            ttsService.cancel();
            disconnect();
            resetConversations();
            
            // Reset services while still authenticated to avoid 403 errors
            try {
                await unifiedUsageService.reset();
            } catch (error) {
                console.warn('Failed to reset usage service:', error);
            }
            
            try {
                await playerProfileService.resetWelcomeMessageTracking();
            } catch (error) {
                console.warn('Failed to reset welcome message tracking in Supabase:', error);
            }
            
        // Clear localStorage - complete reset for fresh first run experience
        localStorage.removeItem('lastConnectionCode');
        localStorage.removeItem('otakonOnboardingComplete');
        localStorage.removeItem('otakon_profile_setup_completed');
        localStorage.removeItem('otakonHasConnectedBefore');
        localStorage.removeItem('otakonAuthMethod');
        localStorage.removeItem('otakonInstallDismissed');
        localStorage.removeItem('otakon_developer_mode'); // Clear developer mode flag
        
        // Clear any splash screen flags to force first run experience
        localStorage.removeItem('otakon_show_splash_after_login');
        
        // Clear all conversation data for fresh start
        localStorage.removeItem('otakon_conversations');
        localStorage.removeItem('otakon_conversations_order');
        localStorage.removeItem('otakon_active_conversation');
            
            // Reset welcome message tracking so it shows again on next login
            localStorage.removeItem('otakon_welcome_message_shown');
            localStorage.removeItem('otakon_last_welcome_time');
            localStorage.removeItem('otakon_app_closed_time');
            localStorage.removeItem('otakon_first_run_completed');
            
            // Now sign out from Supabase (after all authenticated operations are done)
            await authService.signOut();
            
            // Reset app state and return to login screen
            setOnboardingStatus('login');
            setIsHandsFreeMode(false);
            setIsConnectionModalOpen(false);
            setView('landing');
            
            // Reset session flags to allow welcome message on next login
            setWelcomeMessageShownThisSession(false);
            
            // Reset suggested prompts for fresh experience on next login
            suggestedPromptsService.resetUsedPrompts();
            
            // Reset welcome message tracking for fresh experience on next login
            try {
                await supabaseDataService.resetWelcomeMessageTracking();
                console.log('ðŸ”„ Welcome message tracking reset for fresh login');
            } catch (error) {
                console.warn('Failed to reset welcome message tracking:', error);
            }
            
            console.log('Full reset completed successfully');
        } catch (error) {
            console.error('Full reset error:', error);
            // Even if there's an error, try to clear local state
            setOnboardingStatus('login');
            setIsHandsFreeMode(false);
            setIsConnectionModalOpen(false);
            setView('landing');
        }
    }, [send, disconnect, resetConversations]);
    
    // Function to logout only (keep data) - for settings modal
    const handleLogoutOnly = useCallback(async () => {
        const isDeveloperMode = canAccessDeveloperFeatures(authState.user?.email);
        
        setConfirmationModal({
            title: isDeveloperMode ? 'Sign Out of Developer Mode?' : 'Sign Out?',
            message: isDeveloperMode 
                ? 'Are you sure you want to sign out of developer mode? Your data will be preserved.'
                : 'Are you sure you want to sign out? Your data will be preserved.',
            onConfirm: async () => {
                try {
                    // Sign out from Supabase
                    await authService.signOut();
                    
                    // Reset app state and return to login screen
                    setOnboardingStatus('login');
                    setIsHandsFreeMode(false);
                    setIsConnectionModalOpen(false);
                    setView('landing');
                    
                    // Reset session flags
                    setWelcomeMessageShownThisSession(false);
                    
                    console.log('User logged out successfully (data preserved)');
                } catch (error) {
                    console.error('Logout error:', error);
                    // Even if Supabase logout fails, clear local data
                    await executeFullReset();
                }
            },
        });
    }, [executeFullReset]);

    // Function to logout and reset (clear all data) - for context menu
    const handleLogout = useCallback(async () => {
        const isDeveloperMode = canAccessDeveloperFeatures(authState.user?.email);
        
        setConfirmationModal({
            title: isDeveloperMode ? 'Sign Out & Reset Developer Mode?' : 'Sign Out & Reset?',
            message: isDeveloperMode 
                ? 'Are you sure you want to sign out and reset developer mode? This will permanently delete all data and show the first run experience on next login.'
                : 'Are you sure you want to sign out and reset? This will permanently delete all data.',
            onConfirm: async () => {
                try {
                    // First, clear local data and reset services while still authenticated
                    if (send) {
                        send({ type: 'clear_history' });
                    }
                    ttsService.cancel();
                    disconnect();
                    resetConversations();
                    
                    // Reset services while still authenticated to avoid 403 errors
                    try {
                        await unifiedUsageService.reset();
                    } catch (error) {
                        console.warn('Failed to reset usage service:', error);
                    }
                    
                    try {
                        await playerProfileService.resetWelcomeMessageTracking();
                    } catch (error) {
                        console.warn('Failed to reset welcome message tracking in Supabase:', error);
                    }
                    
                    // Clear localStorage - complete reset for fresh first run experience
                    localStorage.removeItem('lastConnectionCode');
                    localStorage.removeItem('otakonOnboardingComplete');
                    localStorage.removeItem('otakon_profile_setup_completed');
                    localStorage.removeItem('otakonHasConnectedBefore');
                    localStorage.removeItem('otakonAuthMethod');
                    localStorage.removeItem('otakonInstallDismissed');
                    localStorage.removeItem('otakon_developer_mode'); // Clear developer mode flag
                    
                    // Clear any splash screen flags to force first run experience
                    localStorage.removeItem('otakon_show_splash_after_login');
                    
                    // Clear all conversation data for fresh start
                    localStorage.removeItem('otakon_conversations');
                    localStorage.removeItem('otakon_conversations_order');
                    localStorage.removeItem('otakon_active_conversation');
                    
                    // Reset welcome message tracking so it shows again on next login
                    localStorage.removeItem('otakon_welcome_message_shown');
                    localStorage.removeItem('otakon_last_welcome_time');
                    localStorage.removeItem('otakon_app_closed_time');
                    localStorage.removeItem('otakon_first_run_completed');
                    
                    // Now sign out from Supabase (after all authenticated operations are done)
                    await authService.signOut();
                    
                    // Reset app state and return to login screen
                    setOnboardingStatus('login');
                    setIsHandsFreeMode(false);
                    setIsConnectionModalOpen(false);
                    setView('landing');
                    
                    // Reset session flags to allow welcome message on next login
                    setWelcomeMessageShownThisSession(false);
                    
                    // Reset suggested prompts for fresh experience on next login
                    suggestedPromptsService.resetUsedPrompts();
                    
                    // Reset welcome message tracking for fresh experience on next login
                    try {
                        await supabaseDataService.resetWelcomeMessageTracking();
                        console.log('ðŸ”„ Welcome message tracking reset for fresh login');
                    } catch (error) {
                        console.warn('Failed to reset welcome message tracking:', error);
                    }
                    
                    console.log('User logged out and reset successfully');
                } catch (error) {
                    console.error('Logout and reset error:', error);
                    // Even if Supabase logout fails, clear local data
                    await executeFullReset();
                }
            },
        });
    }, [send, disconnect, resetConversations, executeFullReset]);
    
    const handleResetApp = useCallback(() => {
        setConfirmationModal({
            title: 'Reset Application?',
            message: 'This will permanently delete all conversation history and settings, and log you out. This action cannot be undone.',
            onConfirm: executeFullReset,
        });
    }, [executeFullReset]);

    const handleUpgrade = useCallback(async () => {
        await unifiedUsageService.upgradeToPro();
        setShowUpgradeScreen(false);
        setIsCreditModalOpen(false);
        refreshUsage();
    }, []);
    
    const handleUpgradeToVanguard = useCallback(async () => {
        await unifiedUsageService.upgradeToVanguard();
        setShowUpgradeScreen(false);
        setIsCreditModalOpen(false);
        refreshUsage();
    }, []);
    
    const handleUpgradeClick = useCallback(() => setShowUpgradeScreen(true), []);

    const handleUpgradeAndContinue = useCallback(() => {
        handleUpgrade();
        completeOnboarding();
    }, [handleUpgrade, completeOnboarding]);

    const handleUpgradeToVanguardAndContinue = useCallback(() => {
        handleUpgradeToVanguard();
        completeOnboarding();
    }, [handleUpgradeToVanguard, completeOnboarding]);

    const handleFeaturesSplashComplete = useCallback(() => {
        if (connectionStatus === ConnectionStatus.CONNECTED) {
            setOnboardingStatus('pro-features');
        } else {
            setOnboardingStatus('pro-features');
        }
    }, [connectionStatus]);
    const handleProFeaturesComplete = useCallback(() => {
        // After pro features, show "How to Use" screen for connected users
        if (connectionStatus === ConnectionStatus.CONNECTED) {
            setOnboardingStatus('how-to-use');
            console.log('ðŸ“± Pro Features complete! Showing "How to Use" screen');
        } else {
            // If not connected, complete onboarding
            completeOnboarding();
            console.log('ðŸ“± Pro Features complete! Completing onboarding');
        }
    }, [connectionStatus, completeOnboarding]);
    const handleHowToUseComplete = useCallback(() => {
        console.log('ðŸ“š "How to Use" complete! Completing onboarding');
        completeOnboarding();
    }, [completeOnboarding]);
    
    const handleSendMessage = useCallback(async (text: string, images?: ImageFile[], isFromPC: boolean = false) => {
        const startTime = performance.now();
        
        // Track user action
        performanceMonitoringService.trackUserAction('send_message', { 
            hasText: text.trim().length > 0, 
            imageCount: images?.length || 0, 
            isFromPC 
        });
        
        // IMMEDIATELY hide suggested prompts when user submits a query
        if (text.trim().length > 0 || (images && images.length > 0) || isFromPC) {
            // Hide static suggested prompts for Everything Else tab
            if (activeConversation?.id === 'everything-else') {
                localStorage.setItem('otakon_has_interacted_with_chat', 'true');
                console.log('ðŸ“ User submitted query - immediately hiding suggested prompts');
            }
            
            // Hide inline suggestions by clearing them from the last AI message
            if (activeConversation && activeConversation.messages.length > 0) {
                const lastMessage = activeConversation.messages[activeConversation.messages.length - 1];
                if (lastMessage.role === 'model' && lastMessage.suggestions) {
                    // Clear suggestions from the last AI message immediately
                    updateConversation(activeConversation.id, conv => ({
                        ...conv,
                        messages: conv.messages.map(msg => 
                            msg.id === lastMessage.id 
                                ? { ...msg, suggestions: undefined }
                                : msg
                        )
                    }));
                    console.log('ðŸ“ Cleared inline suggestions from last AI message');
                }
            }
        }
        
        setChatInputValue(''); // Clear controlled input on send
        setActiveSubView('chat');
        const result = await sendMessage(text, images, isFromPC);
        refreshUsage();

        // Check wishlist release status when user submits a query
        if (activeConversation?.id === 'everything-else') {
            try {
                // Import wishlistService dynamically to avoid circular dependencies
                const { wishlistService } = await import('./services/wishlistService');
                
                // Check all wishlist items for release status
                const wishlistItems = await wishlistService.getWishlist();
                for (const item of wishlistItems) {
                    if (item.releaseDate && !item.isReleased) {
                        await wishlistService.checkGameReleaseStatus(item.gameName);
                    }
                }
            } catch (error) {
                console.error('Failed to check wishlist release status:', error);
            }
        }

        if (result?.success) {
            // Check if a new game pill was created (conversation switched from everything-else to a game)
            if (activeConversation?.id === 'everything-else' && 
                activeConversationId !== 'everything-else' && 
                activeConversationId !== activeConversation.id) {
                // Game pill was created - hide suggested prompts
                localStorage.setItem('otakon_has_interacted_with_chat', 'true');
                console.log('ðŸŽ® Game pill created - hiding suggested prompts');
            }
            
            // Track daily engagement progress
            if (activeConversation && activeConversation.id !== 'everything-else') {
                // Update game session progress
                dailyEngagementService.updateGameStreak();
                
                // Update goal progress
                if (images && images.length > 0) {
                    dailyEngagementService.updateGoalProgress('screenshots', images.length);
                }
                if (text.trim().length > 0) {
                    dailyEngagementService.updateGoalProgress('help_others', 1);
                }
                

                
                // Check for achievements
                const goals = dailyEngagementService.getDailyGoals();
                const completedGoals = goals.filter(g => g.current >= g.target).length;
                if (completedGoals === goals.length && completedGoals > 0) {
                    // All daily goals completed!
                    setCurrentAchievement({
                        id: 'daily_master',
                        title: 'Daily Master',
                        description: 'Completed all daily goals!',
                        icon: 'fire',
                        reward: '+100 Otagon Points'
                    });
                }
            }
            
            // Update last session time
            dailyEngagementService.updateLastSessionTime();
        } else if (result?.reason === 'limit_reached') {
            setShowUpgradeScreen(true);
        }
        
        // Track performance
        const endTime = performance.now();
        performanceMonitoringService.trackPerformanceEvent('message_send', endTime - startTime, {
            success: result?.success,
            reason: result?.reason
        });
    }, [sendMessage, activeConversation, activeConversationId, setChatInputValue, setActiveSubView, refreshUsage, dailyEngagementService, setCurrentAchievement, setShowUpgradeScreen]);
    
    const clearImagesForReview = useCallback(() => {
        setImagesForReview([]);
    }, []);

    
    const handleHandsFreeClick = useCallback(async () => {
        if (usage.tier === 'free') {
            setShowUpgradeScreen(true);
            return;
        }
        
        if (!isHandsFreeMode) {
            // Initialize notification services when enabling hands-free mode
            try {
                if (smartNotificationService.isSupported()) {
                    await smartNotificationService.initialize();
                    console.log('Smart notifications initialized for hands-free mode');
                }
                if (pushNotificationService.isSupported()) {
                    await pushNotificationService.initialize();
                    console.log('Push notifications initialized for hands-free mode');
                }
            } catch (error) {
                console.error('Failed to initialize notification services:', error);
            }
        }
        
        setIsHandsFreeMode(!isHandsFreeMode);
        if (!isHandsFreeMode) {
            setIsHandsFreeModalOpen(true);
        } else {
            setIsHandsFreeModalOpen(false);
        }
    }, [isHandsFreeMode, usage.tier]);

    const handleToggleHandsFree = useCallback(() => {
        setIsHandsFreeMode(prev => !prev);
    }, []);
    
    const handleLoginComplete = useCallback(() => {
        setOnboardingStatus('initial');
        setView('app');
    }, []);

    const handleInitialSplashComplete = useCallback(() => setOnboardingStatus('features'), []);

    // Player Profile Setup Handlers
    const handleProfileSetupComplete = useCallback(async (profile: any) => {
        try {
            console.log('ðŸŽ¯ Starting profile setup completion...', profile);
            
            // Save profile first
            console.log('ðŸ’¾ Saving profile...');
            await playerProfileService.saveProfile(profile);
            console.log('âœ… Profile saved successfully');
            
            // Complete first time setup
            console.log('ðŸŽ‰ Completing first time setup...');
            playerProfileService.completeFirstTimeSetup();
            console.log('âœ… First time setup completed');
            
            // Close modal immediately
            console.log('ðŸšª Closing profile setup modal...');
            setShowProfileSetup(false);
            setIsFirstTime(false);
            console.log('âœ… Modal closed');
            
            // Mark onboarding as complete (profile setup is handled by Supabase)
            localStorage.setItem('otakonOnboardingComplete', 'true');
            console.log('âœ… Onboarding marked as complete');
            
            // Mark first run completed in Supabase with localStorage fallback
            console.log('ðŸ Marking first run as completed...');
            await playerProfileService.markFirstRunCompleted();
            console.log('âœ… First run marked as completed');
            
            // Add welcome message immediately for first-time users
            const timeGreeting = getTimeGreeting();
            addSystemMessage(
                `${timeGreeting}Welcome to Otagon!\n\n**Profile Setup Complete!** Your gaming experience is now personalized.\n\n**Next Steps:**\nâ€¢ Upload a screenshot from a game you're playing\nâ€¢ Tell me about a game you want help with\nâ€¢ I'll create a dedicated conversation tab for each game\nâ€¢ Get spoiler-free guidance tailored to your progress\n\nWhat game would you like to start with today?`,
                'everything-else',
                false
            );
            console.log('âœ… Welcome message added');
            
            // Update welcome message tracking in Supabase with localStorage fallback
            await playerProfileService.updateWelcomeMessageShown('profile_setup');
            console.log('âœ… Welcome message tracking updated');
            
            // Trigger tutorial immediately after profile setup
            console.log('ðŸŽ¯ Profile setup complete - opening tutorial now');
            setTimeout(() => openTutorial(), 1000); // 1 second delay to let UI settle
            
        } catch (error) {
            console.error('âŒ Error in profile setup completion:', error);
            // Still close the modal even if there's an error
            setShowProfileSetup(false);
            setIsFirstTime(false);
        }
    }, [addSystemMessage, openTutorial]);

    const handleProfileSetupSkip = useCallback(async () => {
        // Set default profile
        const defaultProfile = playerProfileService.getDefaultProfile();
        await playerProfileService.saveProfile(defaultProfile);
        setShowProfileSetup(false);
        setIsFirstTime(false);
        
        // Mark onboarding as complete (profile setup is handled by Supabase)
        localStorage.setItem('otakonOnboardingComplete', 'true');
        
        // Mark first run completed in Supabase with localStorage fallback
        await playerProfileService.markFirstRunCompleted();
        
        // Trigger tutorial immediately after profile setup skip
        console.log('ðŸŽ¯ Profile setup skipped - opening tutorial now');
        setTimeout(() => openTutorial(), 1000); // 1 second delay to let UI settle
    }, [openTutorial]);

    const handleCloseUpgradeScreen = useCallback(() => setShowUpgradeScreen(false), []);
    
    // Function to reset welcome message tracking (useful for testing or user preference)
    const resetWelcomeMessageTracking = useCallback(async () => {
        // Reset in localStorage
        localStorage.removeItem('otakon_profile_setup_completed');
        localStorage.removeItem('otakon_welcome_message_shown');
        localStorage.removeItem('otakon_last_session_date');
        localStorage.removeItem('otakon_last_welcome_time');
        localStorage.removeItem('otakon_app_closed_time');
        localStorage.removeItem('otakon_first_run_completed');
        
        // Also reset in Supabase if possible
        try {
            await playerProfileService.resetWelcomeMessageTracking();
            console.log('ðŸ”„ Welcome message tracking reset in both localStorage and Supabase');
        } catch (error) {
            console.warn('Failed to reset in Supabase, localStorage reset successful:', error);
            console.log('ðŸ”„ Welcome message tracking reset in localStorage only');
        }
    }, []);
    
    const handleOpenConnectionModal = useCallback(() => setIsConnectionModalOpen(true), []);
    const handleCloseConnectionModal = useCallback(() => setIsConnectionModalOpen(false), []);
    const handleCloseHandsFreeModal = useCallback(() => setIsHandsFreeModalOpen(false), []);
    const handleOpenCreditModal = useCallback(() => setIsCreditModalOpen(true), []);
    const handleCloseCreditModal = useCallback(() => setIsCreditModalOpen(false), []);

    // Authentication handlers
    const handleAuthSuccess = useCallback(() => {
        setIsAuthModalOpen(false);
        
        // Reset suggested prompts on new login
        suggestedPromptsService.resetUsedPrompts();
        
        // Check if user has already completed onboarding
        const hasCompletedOnboarding = localStorage.getItem('otakonOnboardingComplete');
        const hasCompletedProfileSetup = localStorage.getItem('otakon_profile_setup_completed');
        
        if (hasCompletedOnboarding && hasCompletedProfileSetup) {
            // Returning user - skip to complete status to allow profile setup check and welcome message
            setOnboardingStatus('complete');
            setView('app');
        } else {
            // New user - go through onboarding flow
            setOnboardingStatus('initial');
            setView('app');
        }
    }, []);

    const handleOpenAuthModal = useCallback(() => setIsAuthModalOpen(true), []);
    

    const handleBatchUploadAttempt = useCallback(() => {
        addSystemMessage("Uploading multiple images is a Pro feature. Please select only one image or upgrade for batch analysis.", activeConversationId, true);
        setShowUpgradeScreen(true);
    }, [addSystemMessage, activeConversationId]);

    const handleSubTabClick = useCallback((id: string) => {
        // Special handling for Otaku Diary tab - open modal instead of switching views
        if (id === 'otaku-diary' && activeConversation) {
            setOtakuDiaryGameInfo({
                id: activeConversation.id,
                title: activeConversation.title
            });
            setIsOtakuDiaryModalOpen(true);
            return;
        }
        
        // Special handling for Wishlist tab - open modal instead of switching views
        if (id === 'wishlist' && activeConversation?.id === 'everything-else') {
            setIsWishlistModalOpen(true);
            return;
        }
        
        setActiveSubView(id);
        
        if (activeConversation) {
            if (id !== 'chat') {
                markInsightAsRead(activeConversation.id, id);
                const insight = activeConversation.insights?.[id];
                if (insight && insight.status === 'loading') {
                    fetchInsightContent(activeConversation.id, id);
                }
            }
        }
    }, [activeConversation, fetchInsightContent, markInsightAsRead, activeSubView]);


    const handleSwitchConversation = useCallback((id: string) => {
        setActiveSubView('chat');
        switchConversation(id);
    }, [switchConversation]);

    // Context Menu Handlers
    const handleConversationContextMenu = (e: React.MouseEvent | React.TouchEvent, convo: Conversation) => {
        e.preventDefault();
        e.stopPropagation();

        if (convo.id === 'everything-else') {
            return; // No context menu for the default conversation
        }
        
        const targetRect = (e.currentTarget as HTMLElement).getBoundingClientRect();

        const menuItems: ContextMenuItem[] = [
            {
                label: convo.isPinned ? 'Unpin' : 'Pin',
                icon: PinIcon,
                action: () => pinConversation(convo.id, !convo.isPinned),
            },
            {
                label: 'Delete',
                icon: TrashIcon,
                isDestructive: true,
                action: () => {
                    setConfirmationModal({
                        title: `Delete "${convo.title}"?`,
                        message: 'This will permanently delete the entire conversation history. This action cannot be undone.',
                        onConfirm: () => deleteConversation(convo.id),
                    });
                },
            }
        ];

        setContextMenu({ targetRect, items: menuItems });
    };
    
    const handleModifyInsight = (insightTitle: string) => {
        setChatInputValue(`@${insightTitle} \\modify `);
        setTimeout(() => chatInputRef.current?.focus(), 0);
    };

    const handleInsightContextMenu = (e: React.MouseEvent | React.TouchEvent, insightId: string, insightTitle: string) => {
        e.preventDefault();
        e.stopPropagation();
        const targetRect = (e.currentTarget as HTMLElement).getBoundingClientRect();
        
        const menuItems: ContextMenuItem[] = [
            {
                label: 'Modify',
                icon: EditIcon,
                action: () => handleModifyInsight(insightTitle),
            },
            {
                label: 'Delete',
                icon: TrashIcon,
                isDestructive: true,
                action: () => deleteInsight(activeConversationId, insightId),
            }
        ];

        setContextMenu({ targetRect, items: menuItems });
    };

    const handleSettingsClick = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        const targetRect = (e.currentTarget as HTMLElement).getBoundingClientRect();
        
        // Debug: Log current user email and developer access
        console.log('ðŸ” Current user email:', authState.user?.email);
        console.log('ðŸ” Can access developer features:', canAccessDeveloperFeatures(authState.user?.email));
        
        const menuItems: ContextMenuItem[] = [
            {
                label: 'Settings',
                icon: SettingsIcon,
                action: () => setIsSettingsModalOpen(true),
            },
            {
                label: 'Insights',
                icon: SettingsIcon, // You can create a custom icon for this
                action: () => setShowProactiveInsights(true),
            },
            {
                label: 'Watch Tutorial',
                icon: SettingsIcon, // You can create a custom icon for this
                action: () => openTutorial(),
            },
            // Cache Performance - only for developers
            ...(canAccessDeveloperFeatures(authState.user?.email) ? [{
                label: 'Cache Performance',
                icon: SettingsIcon, // You can create a custom icon for this
                action: () => setIsCacheDashboardOpen(true),
            }] : []),

            // Reset First Run Experience - only for developers
            ...(canAccessDeveloperFeatures(authState.user?.email) ? [{
                label: 'Reset First Run Experience',
                icon: SettingsIcon, // You can create a custom icon for this
                action: () => {
                    // Clear all onboarding and first-run flags
                    localStorage.removeItem('otakon_profile_setup_completed');
                    localStorage.removeItem('otakon_show_splash_after_login');
                    localStorage.removeItem('otakon_onboarding_completed');
                    localStorage.removeItem('otakon_first_run_completed');
                    localStorage.removeItem('otakon_tutorial_completed');
                    
                    // Reset onboarding status to initial
                    setOnboardingStatus('initial');
                    
                    // Show success message
                    console.log('âœ… First run experience reset successfully!');
                    
                    // Close context menu
                    setContextMenu(null);
                },
            }] : []),

            // Add Sign In option for unauthenticated users
            ...(!authState.user ? [{
                label: 'Sign In',
                icon: UserIcon,
                action: handleOpenAuthModal,
            }] : []),
            {
                label: canAccessDeveloperFeatures(authState.user?.email) ? 'Logout & Reset' : 'Logout',
                icon: LogoutIcon,
                isDestructive: true,
                action: canAccessDeveloperFeatures(authState.user?.email) ? handleLogout : handleLogoutOnly,
            }
        ];
        setContextMenu({ targetRect, items: menuItems });
    };
    
     // Feedback Handlers
    const handleFeedback = (type: 'message' | 'insight', convId: string, targetId: string, originalText: string, vote: 'up' | 'down') => {
        if (vote === 'up') {
            if (type === 'message') {
                updateMessageFeedback(convId, targetId, 'up');
            } else {
                updateInsightFeedback(convId, targetId, 'up');
            }
        } else {
             if (type === 'message') {
                updateMessageFeedback(convId, targetId, 'down');
            } else {
                updateInsightFeedback(convId, targetId, 'down');
            }
            setFeedbackModalState({ type, conversationId: convId, targetId, originalText });
        }
    };

    const handleFeedbackSubmit = (feedbackText: string) => {
        if (!feedbackModalState) return;
        
        addFeedback({
            conversationId: feedbackModalState.conversationId,
            targetId: feedbackModalState.targetId,
            originalText: feedbackModalState.originalText,
            feedbackText,
        });

        if (feedbackModalState.type === 'message') {
            updateMessageFeedback(feedbackModalState.conversationId, feedbackModalState.targetId, 'submitted');
        } else {
            updateInsightFeedback(feedbackModalState.conversationId, feedbackModalState.targetId, 'submitted');
        }
        
        setFeedbackModalState(null);
    };

    // Helper function to check if welcome message should be shown after 12+ hours of inactivity
    const shouldShowWelcomeAfterTimeout = (): boolean => {
        const lastWelcomeTime = localStorage.getItem('otakon_last_welcome_time');
        if (!lastWelcomeTime) return true;
        
        const timeSinceLastWelcome = Date.now() - parseInt(lastWelcomeTime, 10);
        const TWELVE_HOURS_MS = 12 * 60 * 60 * 1000; // 12 hours in milliseconds
        
        return timeSinceLastWelcome >= TWELVE_HOURS_MS;
    };
    
    // Helper function to check if user has completed first run experience
    const hasCompletedFirstRunExperience = async (): Promise<boolean> => {
        try {
            const hasCompletedFirstRun = await supabaseDataService.getUserAppState().then(state => state.appSettings?.firstRunCompleted) || localStorage.getItem('otakon_first_run_completed') === 'true';
            if (hasCompletedFirstRun === 'true') return true;
            
            // Check if user has created any game conversations
            const hasGameConversations = Object.values(conversations).some(conv => 
                conv.id !== 'everything-else' && conv.title && conv.title !== 'New Game'
            );
            
            if (hasGameConversations) {
                localStorage.setItem('otakon_first_run_completed', 'true');
                return true;
            }
            
            return false;
        } catch (error) {
            console.warn('Error checking first run experience, falling back to localStorage:', error);
            return localStorage.getItem('otakon_first_run_completed') === 'true';
        }
    };

    // Centralized welcome message system that prevents duplicates and adapts to user queries
    useEffect(() => {
        console.log('ðŸ” Welcome message useEffect triggered:', { view, onboardingStatus });
        
        if (view === 'app' && onboardingStatus === 'complete') {
            // In development mode, skip welcome message checks if not authenticated
            if (import.meta.env.DEV && !authState.user) {
                console.log('âš ï¸ Development mode: Skipping welcome message checks (no authenticated user)');
                return;
            }
            
            // Use Supabase with localStorage fallback
            const checkWelcomeMessage = async () => {
                try {
                    const shouldShow = await supabaseDataService.shouldShowWelcomeMessage();
                    const hasCompletedProfileSetup = await supabaseDataService.getUserAppState().then(state => state.appSettings?.profileSetupCompleted) || localStorage.getItem('otakon_profile_setup_completed') === 'true';
                    
                    console.log('ðŸ” Welcome message check:', {
                        view,
                        onboardingStatus,
                        shouldShow,
                        hasCompletedProfileSetup,
                        conversationsCount: Object.keys(conversations).length
                    });
                    
                    // Check if there's already a welcome message in the current conversation
                    const currentConversation = conversations['everything-else'];
                    const hasExistingWelcomeMessage = currentConversation?.messages?.some(msg => 
                        msg.role === 'system' && 
                        (msg.text.includes('Welcome to Otagon') || msg.text.includes('Welcome back'))
                    );
                    
                    // Show welcome message if:
                    // 1. User has completed profile setup
                    // 2. Supabase/localStorage indicates welcome should be shown
                    // 3. No existing welcome message in current conversation
                    // Note: Removed session flag check to allow welcome messages after logout/login
                    if (hasCompletedProfileSetup && shouldShow && !hasExistingWelcomeMessage) {
                console.log('âœ… Showing welcome message - conditions met');
                
                // Get current time for time-based greetings
                const currentHour = new Date().getHours();
                let timeGreeting = '';
                
                if (currentHour < 12) {
                    timeGreeting = 'Good morning! ';
                } else if (currentHour < 17) {
                    timeGreeting = 'Good afternoon! ';
                } else {
                    timeGreeting = 'Good evening! ';
                }
                
                                    // Check if user has previous conversations to determine message type
                        const hasPreviousConversations = Object.values(conversations).some(conv => 
                            conv.id !== 'everything-else' && conv.messages && conv.messages.length > 1
                        );
                        
                        // Check if user has completed first run experience (has created at least one game conversation)
                        const hasCompletedFirstRun = await hasCompletedFirstRunExperience();
                        
                        let welcomeMessage: string;
                        
                        if (hasCompletedFirstRun) {
                            // User has completed first run experience - show session summary and contextual welcome
                            const recentGames = Object.values(conversations)
                                .filter(conv => conv.id !== 'everything-else' && conv.title && conv.title !== 'New Game')
                                .slice(0, 3); // Get up to 3 recent games
                            
                            if (recentGames.length > 0) {
                                // Create session summary
                                const gameSummaries = recentGames.map(conv => {
                                    const messageCount = conv.messages?.length || 0;
                                    const progress = conv.progress || 0;
                                    const lastInteraction = conv.lastInteractionTimestamp || conv.createdAt;
                                    
                                    let summary = `**${conv.title}**`;
                                    if (progress > 0) summary += ` (${progress}% progress)`;
                                    if (messageCount > 1) summary += ` - ${messageCount} messages`;
                                    
                                    return summary;
                                });
                                
                                const totalGames = recentGames.length;
                                const totalMessages = recentGames.reduce((sum, conv) => sum + (conv.messages?.length || 0), 0);
                                
                                welcomeMessage = `${timeGreeting}Welcome back to Otagon!\n\n**Your Gaming Session Summary:**\n${gameSummaries.join('\n')}\n\n**Total:** ${totalGames} game${totalGames > 1 ? 's' : ''}, ${totalMessages} message${totalMessages > 1 ? 's' : ''}\n\nWhat's your next gaming challenge today? I'm ready to help you continue your adventures or start something new!`;
                                console.log('ðŸŽ® User with completed first run - showing session summary welcome');
                            } else {
                                welcomeMessage = `${timeGreeting}Welcome back! I'm ready to help with your next gaming challenge. What game are you tackling today, or would you like to continue where you left off?`;
                                console.log('Returning user without recent game history - showing gentle reminder');
                            }
                        } else if (hasPreviousConversations) {
                            // User has conversations but no game conversations yet - show encouragement
                            welcomeMessage = `${timeGreeting}Welcome back! I see you've been chatting with me. Ready to dive into some actual gaming? Upload a screenshot from a game you're playing, or tell me what you'd like to play, and I'll help you get unstuck without spoilers!`;
                            console.log('User with conversations but no games yet - showing encouragement');
                        } else {
                            // Returning user without any history - show gentle reminder
                            welcomeMessage = `${timeGreeting}Welcome back! Ready to dive into some gaming? Upload a screenshot or tell me what you're playing, and I'll help you get unstuck without spoilers.`;
                            console.log('Returning user without any history - showing gentle reminder');
                        }
                        
                        console.log('ðŸ“ Adding welcome message to chat:', welcomeMessage);
                        addSystemMessage(welcomeMessage, 'everything-else', false);
                        
                        // Update tracking using Supabase service with automatic fallback
                        await supabaseDataService.updateWelcomeMessageShown();
                        console.log('âœ… Welcome message tracking updated via Supabase service');
                        
                        // Mark welcome message as shown this session to prevent duplicates
                        setWelcomeMessageShownThisSession(true);
                    } else {
                        console.log('âŒ Welcome message not shown - conditions not met:', {
                            hasCompletedProfileSetup,
                            shouldShow,
                            hasExistingWelcomeMessage
                        });
                    }
                } catch (error) {
                    console.error('Error checking welcome message:', error);
                }
            };
            
            // Execute the welcome message check
            checkWelcomeMessage();
        }
    }, [view, onboardingStatus, addSystemMessage, conversations]);



    if (view === 'landing') {
        // Redirect to login instead of showing landing page
        setOnboardingStatus('login');
        setView('app');
        return null;
    }


    if (onboardingStatus === 'login') {
        return <LoginSplashScreen 
            onComplete={handleLoginComplete} 
            onOpenPrivacy={() => setActiveModal('privacy')}
            onOpenTerms={() => setActiveModal('about')}
        />;
    }

    if (onboardingStatus === 'initial') {
        return <InitialSplashScreen onComplete={handleInitialSplashComplete} />;
    }

    if (onboardingStatus === 'features') {
        return (
            <SplashScreen
                onComplete={handleFeaturesSplashComplete}
                onSkipConnection={handleFeaturesSplashComplete}
                onConnect={connect}
                status={connectionStatus}
                error={connectionError}
                connectionCode={connectionCode}
                onConnectionSuccess={handleFeaturesSplashComplete}
            />
        );
    }
    
    if (onboardingStatus === 'pro-features') {
        return <ProFeaturesSplashScreen onComplete={handleProFeaturesComplete} onUpgrade={handleUpgradeAndContinue} onUpgradeToVanguard={handleUpgradeToVanguardAndContinue} />;
    }
    
    if (onboardingStatus === 'how-to-use') {
        return <HowToUseSplashScreen onComplete={handleHowToUseComplete} />;
    }

    
    if (showUpgradeScreen) {
        return <UpgradeSplashScreen onUpgrade={handleUpgrade} onClose={handleCloseUpgradeScreen} onUpgradeToVanguard={handleUpgradeToVanguard} />;
    }

    const headerContent = (
        <div className="flex items-center gap-2">
            <Logo className="h-8 w-8 sm:h-10 sm:w-10 md:h-12 md:w-12" />
            <h1 className="text-xl sm:text-2xl md:text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-[#FF4D4D] to-[#FFAB40] leading-normal">Otagon</h1>
        </div>
    );

    const isInputDisabled = loadingMessages.length > 0;
    const isProView = usage.tier !== 'free' && activeConversation && activeConversation.id !== 'everything-else' && activeConversation.insights;
    const hasInsights = usage.tier !== 'free' && !!(activeConversation?.insightsOrder && activeConversation.insightsOrder.length > 0);

    return (
        <div className="h-screen bg-black text-[#F5F5F5] flex flex-col font-inter relative overflow-hidden" onContextMenu={(e) => e.preventDefault()}>
            <audio ref={silentAudioRef} src={SILENT_AUDIO_URL} loop playsInline />

            <div className="absolute top-0 left-0 w-full h-full bg-gradient-radial-at-top from-[#1C1C1C]/40 to-transparent -z-0 pointer-events-none"></div>
            <div className="absolute bottom-0 left-0 w-full h-full bg-gradient-radial-at-bottom from-[#0A0A0A]/30 to-transparent -z-0 pointer-events-none"></div>
            
            <header className={`relative flex-shrink-0 flex items-center justify-between p-2 sm:p-3 md:p-4 lg:p-6 bg-black/80 backdrop-blur-xl z-20 border-b border-[#424242]/20 shadow-2xl`}>
                <button
                    type="button"
                    className="transition-all duration-200 hover:opacity-80 hover:scale-105 group flex-shrink-0"
                    aria-label="Otagon logo and title"
                >
                    <div className="flex items-center gap-4">
                        <div className="group-hover:scale-110 transition-transform duration-200">
                            {headerContent}
                        </div>
                    </div>
                </button>
                
                {/* Enhanced Features Status Bar */}
                <div className="flex items-center gap-1 sm:gap-2 md:gap-3 flex-shrink-0">
                    
                </div>
                <div className="flex items-center gap-1 sm:gap-2 md:gap-3 flex-shrink-0">
                     <CreditIndicator usage={usage} onClick={handleOpenCreditModal} />
                     <HandsFreeToggle
                        isHandsFree={isHandsFreeMode}
                        onToggle={handleHandsFreeClick}
                     />
                    <button
                        type="button"
                        onClick={handleOpenConnectionModal}
                        className={`flex items-center justify-center sm:justify-start gap-1.5 sm:gap-2 h-10 w-10 sm:w-auto sm:px-3 md:px-4 rounded-xl text-xs sm:text-sm font-semibold transition-all duration-300 disabled:opacity-50
                        ${
                            connectionStatus === ConnectionStatus.CONNECTED
                            ? 'border-2 border-[#5CBB7B]/60 text-[#5CBB7B] hover:bg-[#5CBB7B]/10 hover:border-[#5CBB7B] shadow-[0_0_20px_rgba(92,187,123,0.4)] hover:shadow-[0_0_30px_rgba(92,187,123,0.6)]'
                            : 'bg-gradient-to-r from-[#2E2E2E] to-[#1C1C1C] border-2 border-[#424242]/60 text-[#CFCFCF] hover:bg-gradient-to-r hover:from-[#424242] hover:to-[#2E2E2E] hover:border-[#5A5A5A] hover:scale-105'
                        }
                        ${
                            connectionStatus === ConnectionStatus.CONNECTING ? 'animate-pulse' : ''
                        }
                        `}
                        title={
                            connectionStatus === ConnectionStatus.CONNECTED 
                                ? 'Connected to PC' 
                                : 'Connect to PC'
                        }
                    >
                        <DesktopIcon className="w-5 h-5 flex-shrink-0" />
                        <span className="hidden sm:inline font-medium">
                        {
                            connectionStatus === ConnectionStatus.CONNECTED ? 'Connected' :
                            connectionStatus === ConnectionStatus.CONNECTING ? 'Connecting...' :
                            'Connect to PC'
                        }
                        </span>
                    </button>
                    
                    {/* Force Reconnect Button - Only show when disconnected and have a saved code */}
                    {connectionStatus === ConnectionStatus.DISCONNECTED && 
                     connectionCode && (
                        <button
                            type="button"
                            onClick={forceReconnect}
                            className="flex items-center gap-1.5 sm:gap-2 h-10 w-10 rounded-xl text-xs sm:text-sm font-semibold bg-gradient-to-r from-[#2E2E2E] to-[#1C1C1C] border-2 border-[#424242]/60 text-[#CFCFCF] hover:from-[#424242] hover:to-[#2E2E2E] hover:border-[#5A5A5A] hover:scale-105 transition-all duration-300 shadow-lg"
                            title="Force reconnect with saved code"
                        >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                            <span className="hidden sm:inline">Reconnect</span>
                        </button>
                    )}
                    

                    
                    <button
                        type="button"
                        onClick={handleSettingsClick}
                        onContextMenu={handleSettingsClick}
                        className="flex items-center justify-center sm:justify-start gap-1.5 sm:gap-2 h-10 w-10 sm:w-auto sm:px-3 md:px-4 rounded-xl text-xs sm:text-sm font-semibold bg-gradient-to-r from-[#2E2E2E] to-[#1C1C1C] border-2 border-[#424242]/60 text-white/90 transition-all duration-300 hover:from-[#424242] hover:to-[#2E2E2E] hover:scale-105 hover:shadow-lg"
                        aria-label="Open settings"
                    >
                        <SettingsIcon className="w-5 h-5 flex-shrink-0" />
                        <span className="hidden sm:inline font-medium">Settings</span>
                    </button>


                </div>
            </header>
            
            {usage.tier === 'free' && (
              <div className="pb-3">
                <AdBanner />
              </div>
            )}

            {/* Daily Engagement Components */}
            {/* {showDailyCheckin && (
              <DailyCheckinBanner
                onClose={() => setShowDailyCheckin(false)}
                autoDismiss={false}
                dismissDelay={0}
              />
            )} */}



            {/* Player Profile Setup Modal - Show instead of session continuation for first-time users */}
            {showProfileSetup && (
              <PlayerProfileSetupModal
                isOpen={showProfileSetup}
                onComplete={handleProfileSetupComplete}
                onSkip={handleProfileSetupSkip}
              />
            )}

            {currentAchievement && (
              <AchievementNotification
                achievement={currentAchievement}
                onClose={() => setCurrentAchievement(null)}
                onShare={() => {
                  // Handle sharing achievement
                  console.log('Sharing achievement:', currentAchievement.title);
                }}
                autoDismiss={false}
                dismissDelay={0}
              />
            )}
            
            {/* Enhanced Features Notifications */}
            {/* Sync success notification removed - no need to show successful sync */}
            
            {databaseSyncStatus === 'error' && (
              <div className="fixed top-20 right-4 z-50 bg-red-600/90 backdrop-blur-xl text-white px-4 py-3 rounded-lg shadow-2xl border border-red-500/30 animate-fade-in">
                <div className="flex items-center gap-3">
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                  <span className="text-sm font-medium">Database sync failed. Click sync button to retry.</span>
                </div>
              </div>
            )}

            <ConversationTabs
                conversations={conversations}
                conversationsOrder={conversationsOrder}
                activeConversationId={activeConversationId}
                activeConversation={activeConversation}
                onSwitchConversation={handleSwitchConversation}
                onContextMenu={handleConversationContextMenu}
                onReorder={reorderConversations}
            />
            
            {/* Proactive Insights Panel */}
            {showProactiveInsights && authState.user && (
                <ProactiveInsightsPanel
                    isOpen={showProactiveInsights}
                    onClose={() => setShowProactiveInsights(false)}
                    onInsightAction={(insight) => {
                        console.log('Proactive insight action:', insight);
                        // TODO: Implement insight actions
                    }}
                />
            )}
            
            {/* Main Chat Interface - Hide when profile setup modal is active */}
            {!showProfileSetup && (
                <>
            {isProView ? (
                 <MainViewContainer
                    activeConversation={activeConversation!}
                    activeSubView={activeSubView}
                    onSubViewChange={handleSubTabClick}
                    onSendMessage={(prompt) => handleSendMessage(prompt)}
                    stopMessage={handleStopMessage}
                    isInputDisabled={isInputDisabled}
                    messages={messages}
                    loadingMessages={loadingMessages}
                    onUpgradeClick={handleUpgradeClick}
                    onFeedback={handleFeedback}
                    onRetry={retryMessage}
                    isFirstTime={isFirstTime}
                    onOpenWishlistModal={() => setIsWishlistModalOpen(true)}
                />
            ) : (
                 <main className="flex-1 flex flex-col px-3 sm:px-4 md:px-6 lg:px-8 pt-4 sm:pt-6 md:pt-8 pb-20 sm:pb-24 overflow-y-auto" ref={chatContainerRef}>
                    {messages.length === 0 && loadingMessages.length === 0 ? (
                        <div className="flex-1 flex flex-col justify-center items-center">
                            {shouldShowSuggestedPromptsEnhanced() && (
                                <SuggestedPrompts 
                                    onPromptClick={(prompt) => handleSendMessage(prompt)} 
                                    isInputDisabled={isInputDisabled}
                                    isFirstTime={isFirstTime}
                                />
                            )}
                        </div>
                    ) : (
                        <div className="flex flex-col gap-4 sm:gap-6 md:gap-8 lg:gap-10 w-full max-w-[95%] sm:max-w-4xl md:max-w-5xl mx-auto my-4 sm:my-6 md:my-8 lg:my-10">
                            {(() => { const loadingSet = new Set(loadingMessages); return messages.map(msg => (
                                 <ChatMessageComponent
                                     key={msg.id}
                                     message={msg}
                                     isLoading={loadingSet.has(msg.id)}
                                     onStop={() => handleStopMessage(msg.id)}
                                     onPromptClick={(prompt) => handleSendMessage(prompt)}
                                     onUpgradeClick={handleUpgradeClick}
                                     onFeedback={(vote) => handleFeedback('message', activeConversationId, msg.id, msg.text, vote)}
                                     onRetry={() => retryMessage(msg.id)}
                                 />
                            ))})()}
                             
                             {/* Show suggested prompts directly below messages as part of chat flow - only when not loading */}
                             {shouldShowSuggestedPromptsEnhanced() && loadingMessages.length === 0 && (
                                 <SuggestedPrompts 
                                     onPromptClick={(prompt) => handleSendMessage(prompt)} 
                                     isInputDisabled={isInputDisabled}
                                     isFirstTime={isFirstTime}
                                 />
                             )}
                             
                             <div ref={chatEndRef} />
                        </div>
                    )}
                    
                </main>
            )}


                    {/* SubTabs - below prompts, visible when has insights (all users can see Otaku Diary) */}
                    {(activeConversation?.insights && activeConversation.id !== 'everything-else') || activeConversation?.id === 'everything-else' ? (
                <div className="w-full max-w-[95%] sm:max-w-4xl md:max-w-5xl mx-auto px-3 sm:px-4 pt-3 sm:pt-4 flex items-center gap-2 sm:gap-3">
                    <div className="flex-1 min-w-0">
                        <SubTabs
                            activeConversation={activeConversation}
                            activeSubView={activeSubView}
                            onTabClick={handleSubTabClick}
                            userTier={usage.tier}
                            onReorder={reorderInsights}
                            onContextMenu={handleInsightContextMenu}
                            connectionStatus={connectionStatus}
                        />
                    </div>
                    <div className="flex-shrink-0">
                        <ScreenshotButton
                            isConnected={connectionStatus === ConnectionStatus.CONNECTED}
                            isProcessing={isInputDisabled}
                            isManualUploadMode={isManualUploadMode}
                            onRequestConnect={() => setIsConnectionModalOpen(true)}
                            usage={usage}
                        />
                    </div>
                </div>
            ) : null}

            

            


                    {/* Chat Input - Hide when profile setup modal is active */}
            <div className="flex-shrink-0 bg-black/60 backdrop-blur-xl z-10 border-t border-[#424242]/20 shadow-2xl">
                <ChatInput
                    value={chatInputValue}
                    onChange={setChatInputValue}
                    onSendMessage={handleSendMessage}
                    isCooldownActive={isInputDisabled}
                    onImageProcessingError={addSystemMessage}
                    usage={usage}
                    imagesForReview={imagesForReview}
                    onImagesReviewed={clearImagesForReview}
                    isManualUploadMode={isManualUploadMode}
                    onToggleManualUploadMode={() => setIsManualUploadMode(prev => !prev)}
                    connectionStatus={connectionStatus}
                    textareaRef={chatInputRef}
                    onBatchUploadAttempt={handleBatchUploadAttempt}
                    activeConversation={activeConversation}
                    hasInsights={hasInsights}
                />
            </div>
                </>
            )}
            
            {isSettingsModalOpen && (
                <React.Suspense fallback={null}>
                <SettingsModal
                    isOpen={isSettingsModalOpen}
                    onClose={() => setIsSettingsModalOpen(false)}
                    usage={usage}
                    onShowUpgrade={() => setShowUpgradeScreen(true)}
                    onShowVanguardUpgrade={handleUpgradeToVanguard}
                    onLogout={handleLogoutOnly}
                    onResetApp={handleResetApp}
                    onShowHowToUse={() => setOnboardingStatus('how-to-use')}
                    userEmail={authState.user?.email || ''}
                    onClearFirstRunCache={clearFirstRunCache}
                    refreshUsage={refreshUsage}
                />
                </React.Suspense>
            )}

            {contextMenu && <ContextMenu {...contextMenu} onClose={() => setContextMenu(null)} />}

            {confirmationModal && (
                <ConfirmationModal
                    title={confirmationModal.title}
                    message={confirmationModal.message}
                    onConfirm={() => {
                        confirmationModal.onConfirm();
                        setConfirmationModal(null);
                    }}
                    onCancel={() => setConfirmationModal(null)}
                />
            )}

            {feedbackModalState && (
                <FeedbackModal
                    originalText={feedbackModalState.originalText}
                    onClose={() => setFeedbackModalState(null)}
                    onSubmit={handleFeedbackSubmit}
                />
            )}
            
             {pendingModification && (
                <InsightActionModal
                    currentTitle={activeConversation?.insights?.[pendingModification.id]?.title || 'Insight'}
                    suggestion={pendingModification}
                    onOverwrite={() => {
                        if (pendingModification.id && pendingModification.title && pendingModification.content) {
                            overwriteInsight(activeConversationId, pendingModification.id, pendingModification.title, pendingModification.content);
                        }
                        setPendingModification(null);
                    }}
                    onCreateNew={() => {
                        if (pendingModification.title && pendingModification.content) {
                            createNewInsight(activeConversationId, pendingModification.title, pendingModification.content);
                        }
                        setPendingModification(null);
                    }}
                    onCancel={() => setPendingModification(null)}
                />
            )}

            {isConnectionModalOpen && (
                <ConnectionModal
                    isOpen={isConnectionModalOpen}
                    onClose={handleCloseConnectionModal}
                    onConnect={connect}
                    onDisconnect={handleDisconnect}
                    status={connectionStatus}
                    error={connectionError}
                    connectionCode={connectionCode}
                    lastSuccessfulConnection={lastSuccessfulConnection ? new Date(lastSuccessfulConnection) : null}
                    onShowHowToUse={() => {
                        setIsConnectionModalOpen(false);
                        setOnboardingStatus('how-to-use');
                    }}
                />
            )}

            {isCreditModalOpen && (
                 <CreditModal
                    onClose={handleCloseCreditModal}
                    onUpgrade={() => setShowUpgradeScreen(true)}
                    usage={usage}
                 />
            )}

            {isHandsFreeModalOpen && (
                <HandsFreeModal
                    onClose={handleCloseHandsFreeModal}
                    isHandsFree={isHandsFreeMode}
                    onToggleHandsFree={handleToggleHandsFree}
                />
            )}

            {/* Cache Performance Dashboard */}
            {isCacheDashboardOpen && (
                <CachePerformanceDashboard
                    isOpen={isCacheDashboardOpen}
                    onClose={() => setIsCacheDashboardOpen(false)}
                />
            )}

            {/* Authentication Modal */}
            {isAuthModalOpen && (
                <AuthModal
                    isOpen={isAuthModalOpen}
                    onClose={() => setIsAuthModalOpen(false)}
                    onAuthSuccess={handleAuthSuccess}
                />
            )}

            
            {/* OAuth Callback Handler */}
            {isOAuthCallback && (
                <AuthCallbackHandler
                    onAuthSuccess={() => {
                        console.log('OAuth callback success, calling handleAuthSuccess...');
                        setIsOAuthCallback(false);
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                        // Call the authentication success handler to properly transition
                        handleAuthSuccess();
                    }}
                    onAuthError={(error) => {
                        console.error('OAuth error:', error);
                        setIsOAuthCallback(false);
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }}
                    onRedirectToSplash={() => {
                        console.log('OAuth callback redirect to splash, calling handleAuthSuccess...');
                        setIsOAuthCallback(false);
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                        // Call the authentication success handler to properly transition
                        handleAuthSuccess();
                    }}
                />
            )}

            {/* Direct OAuth Processing Fallback */}
            {isOAuthCallback && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white p-6 rounded-lg">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
                            <p className="text-gray-700">Processing authentication...</p>
                            <button 
                                onClick={() => {
                                    console.log('Manual OAuth completion triggered');
                                    setIsOAuthCallback(false);
                                    window.history.replaceState({}, document.title, window.location.pathname);
                                    handleAuthSuccess();
                                }}
                                className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                            >
                                Complete Authentication
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* PWA Install Banner */}
            {/* PWA Install Banner removed - only shows on splash screens */}

            {isOtakuDiaryModalOpen && otakuDiaryGameInfo && (
                <OtakuDiaryModal
                    isOpen={isOtakuDiaryModalOpen}
                    onClose={() => setIsOtakuDiaryModalOpen(false)}
                    gameId={otakuDiaryGameInfo.id}
                    gameTitle={otakuDiaryGameInfo.title}
                />
            )}

            {/* Wishlist Modal */}
            {isWishlistModalOpen && (
                <WishlistModal
                    isOpen={isWishlistModalOpen}
                    onClose={() => setIsWishlistModalOpen(false)}
                />
            )}

            {/* UI Tutorial Modal */}
            {isTutorialOpen && (
                <UITutorial
                    isOpen={isTutorialOpen}
                    onComplete={completeTutorial}
                    onSkip={skipTutorial}
                />
            )}

        </div>
    );
};

// Wrap the app with ErrorBoundary
const App: React.FC = () => (
    <ErrorBoundary>
        <AppComponent />
    </ErrorBoundary>
);

export default App;

usechat :

import { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { ChatMessage, Conversations, Conversation, newsPrompts, Insight, insightTabsConfig, InsightStatus, PendingInsightModification, ChatMessageFeedback } from '../services/types';
import { authService } from '../services/supabase';
import { 
    getGameNews, 
    sendMessageWithImages, 
    sendMessage as sendTextToGemini, 
    isChatActive, 
    resetChat as resetGeminiChat, 
    renameChatSession,
    getUpcomingReleases,
    getLatestReviews,
    getGameTrailers,
    generateInitialProHint,
    generateUnifiedInsights,
    generateInsightStream,
    generateInsightWithSearch
} from '../services/geminiService';
import tabManagementService from '../services/tabManagementService';
import { ttsService } from '../services/ttsService';
import { unifiedUsageService } from '../services/unifiedUsageService';
import { smartNotificationService } from '../services/smartNotificationService';
import { gameAnalyticsService } from '../services/gameAnalyticsService';
import { analyticsService } from '../services/analyticsService';
import { playerProfileService } from '../services/playerProfileService';
import { contextManagementService } from '../services/contextManagementService';
import { longTermMemoryService } from '../services/longTermMemoryService';
import { screenshotTimelineService } from '../services/screenshotTimelineService';
import { unifiedAIService } from '../services/unifiedAIService';
import { otakuDiaryService } from '../services/otakuDiaryService';

const COOLDOWN_KEY = 'geminiCooldownEnd';
const COOLDOWN_DURATION = 60 * 60 * 1000; // 1 hour

const EVERYTHING_ELSE_ID = 'everything-else';
const CONVERSATIONS_STORAGE_KEY = 'otakonConversations';

type ImageFile = { base64: string; mimeType: string; dataUrl: string };

const generateGameId = (gameName: string) => {
    return gameName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
};

const allOtakonTags = [
    'GAME_ID', 'CONFIDENCE', 'GAME_PROGRESS', 'GENRE',
    'GAME_IS_UNRELEASED', 'TRIUMPH', 'INVENTORY_ANALYSIS',
    'INSIGHT_UPDATE', 'SUGGESTIONS',
    'INSIGHT_MODIFY_PENDING', 'INSIGHT_DELETE_REQUEST',
    'OBJECTIVE_SET', 'OBJECTIVE_COMPLETE'
];
const tagCleanupRegex = new RegExp(`\\[OTAKON_(${allOtakonTags.join('|')}):.*?\\]`, 'gs');


const sortConversations = (conversations: Conversations) => (aId: string, bId: string): number => {
    const a = conversations[aId];
    const b = conversations[bId];

    if (!a || !b) return 0;

    if (a.id === EVERYTHING_ELSE_ID) return -1;
    if (b.id === EVERYTHING_ELSE_ID) return 1;

    if (a.isPinned && !b.isPinned) return -1;
    if (!a.isPinned && b.isPinned) return 1;
    
    const aTimestamp = a.lastInteractionTimestamp || a.createdAt;
    const bTimestamp = b.lastInteractionTimestamp || b.createdAt;
    return bTimestamp - aTimestamp;
};


export const useChat = (isHandsFreeMode: boolean) => {
    const [chatState, setChatState] = useState<{ 
        conversations: Conversations, 
        order: string[],
        activeId: string,
    }>({
        conversations: {},
        order: [],
        activeId: EVERYTHING_ELSE_ID,
    });
    const { conversations, order: conversationsOrder, activeId: activeConversationId } = chatState;
    
    const [loadingMessages, setLoadingMessages] = useState<string[]>([]);
    const [isCooldownActive, setIsCooldownActive] = useState(false);
    const [pendingModification, setPendingModification] = useState<PendingInsightModification | null>(null);
    const abortControllersRef = useRef<Record<string, AbortController>>({});
    
    const conversationsRef = useRef(conversations);
    useEffect(() => {
        conversationsRef.current = conversations;
    }, [conversations]);
    
    const conversationsOrderRef = useRef(conversationsOrder);
    useEffect(() => {
        conversationsOrderRef.current = conversationsOrder;
    }, [conversationsOrder]);
    
    const saveConversationsToLocalStorage = useCallback(() => {
        try {
            // Save conversations to localStorage for persistence in developer mode
            const conversationsToSave = {
                ...conversations,
                // Ensure we have the everything-else conversation
                [EVERYTHING_ELSE_ID]: conversations[EVERYTHING_ELSE_ID] || {
                    id: EVERYTHING_ELSE_ID,
                    title: 'Everything else',
                    messages: [],
                    createdAt: Date.now(),
                }
            };
            
            localStorage.setItem(CONVERSATIONS_STORAGE_KEY, JSON.stringify(conversationsToSave));
            localStorage.setItem('otakon_conversations_order', JSON.stringify(conversationsOrder));
            localStorage.setItem('otakon_active_conversation', activeConversationId);
            console.log('ðŸ’¾ Conversations saved to localStorage');
        } catch (error) {
            console.warn('Failed to save conversations to localStorage:', error);
        }
    }, [conversations, conversationsOrder, activeConversationId]);

    useEffect(() => {
        // Load conversations from localStorage on app startup
        const loadConversationsFromStorage = () => {
            try {
                const savedConversations = localStorage.getItem(CONVERSATIONS_STORAGE_KEY);
                const savedOrder = localStorage.getItem('otakon_conversations_order');
                const savedActiveId = localStorage.getItem('otakon_active_conversation');
                
                if (savedConversations) {
                    const parsedConversations = JSON.parse(savedConversations);
                    const parsedOrder = savedOrder ? JSON.parse(savedOrder) : Object.keys(parsedConversations);
                    const activeId = savedActiveId && parsedConversations[savedActiveId] ? savedActiveId : EVERYTHING_ELSE_ID;
                    
                    // Ensure we have the everything-else conversation
                    if (!parsedConversations[EVERYTHING_ELSE_ID]) {
                        parsedConversations[EVERYTHING_ELSE_ID] = {
                            id: EVERYTHING_ELSE_ID,
                            title: 'Everything else',
                            messages: [],
                            createdAt: Date.now(),
                        };
                    }
                    
                    setChatState({
                        conversations: parsedConversations,
                        order: parsedOrder,
                        activeId: activeId
                    });
                    console.log('ðŸ’¾ Conversations loaded from localStorage');
                    return;
                }
            } catch (error) {
                console.warn('Failed to load conversations from localStorage:', error);
            }
            
            // Fallback to default state
            setChatState({
                conversations: {
                    [EVERYTHING_ELSE_ID]: {
                        id: EVERYTHING_ELSE_ID,
                        title: 'Everything else',
                        messages: [],
                        createdAt: Date.now(),
                    }
                },
                order: [EVERYTHING_ELSE_ID],
                activeId: EVERYTHING_ELSE_ID
            });
        };
        
        loadConversationsFromStorage();
    }, []);


    useEffect(() => {
        const handler = setTimeout(saveConversationsToLocalStorage, 500);
        return () => clearTimeout(handler);
    }, [chatState, saveConversationsToLocalStorage]);

    useEffect(() => {
        const cooldownEnd = localStorage.getItem(COOLDOWN_KEY);
        if (cooldownEnd && Date.now() < parseInt(cooldownEnd, 10)) {
            setIsCooldownActive(true);
            const timeRemaining = parseInt(cooldownEnd, 10) - Date.now();
            const timer = setTimeout(() => setIsCooldownActive(false), timeRemaining > 0 ? timeRemaining : 0);
            return () => clearTimeout(timer);
        }
    }, []);

    const activeConversation = useMemo(() => conversations[activeConversationId], [conversations, activeConversationId]);
    
    const updateConversation = useCallback((convoId: string, updateFn: (convo: Conversation) => Conversation, skipTimestamp?: boolean) => {
        setChatState(prev => {
            const newConversations = { ...prev.conversations };
            const convo = newConversations[convoId];
            if (convo) {
                const updatedConvo = updateFn(convo);
                if (!skipTimestamp) {
                    updatedConvo.lastInteractionTimestamp = Date.now();
                }
                newConversations[convoId] = updatedConvo;
                const newOrder = [...prev.order].sort(sortConversations(newConversations));
                return { ...prev, conversations: newConversations, order: newOrder };
            }
            return prev;
        });
    }, []);

    const updateMessageInConversation = useCallback((convoId: string, messageId: string, updateFn: (msg: ChatMessage) => ChatMessage) => {
        updateConversation(convoId, convo => ({
            ...convo,
            messages: convo.messages.map(m => m.id === messageId ? updateFn(m) : m)
        }));
    }, [updateConversation]);
    
    const addSystemMessage = useCallback((text: string, convoId?: string, showUpgradeButton?: boolean) => {
        const targetConvoId = convoId || activeConversationId;
        const message: ChatMessage = {
            id: crypto.randomUUID(),
            role: 'model',
            text,
            showUpgradeButton: showUpgradeButton || false,
        };
        updateConversation(targetConvoId, convo => ({
            ...convo,
            messages: [...convo.messages, message]
        }));
    }, [activeConversationId, updateConversation]);

    const handleQuotaError = useCallback((failedMessageId: string) => {
        setIsCooldownActive(true);
        setTimeout(() => setIsCooldownActive(false), COOLDOWN_DURATION);
        const errorText = "The AI is currently resting due to high traffic. Service will resume in about an hour.";
        updateMessageInConversation(activeConversationId, failedMessageId, msg => ({ ...msg, text: `Error: ${errorText}` }));
        setLoadingMessages(prev => prev.filter(id => id !== failedMessageId));
    }, [activeConversationId, updateMessageInConversation]);

    const deleteInsight = useCallback((convoId: string, insightId: string) => {
        updateConversation(convoId, convo => {
            if (!convo.insights || !convo.insightsOrder) return convo;
            
            const oldInsight = convo.insights[insightId];
            const newInsights = { ...convo.insights };
            delete newInsights[insightId];
            const newOrder = convo.insightsOrder.filter(id => id !== insightId);

            // Track insight deletion for game analytics
            const gameContext = gameAnalyticsService.extractGameContext(convo);
            gameAnalyticsService.trackInsightTab({
                conversationId: convoId,
                tabId: insightId,
                tabTitle: oldInsight.title,
                tabContent: oldInsight.content,
                tabType: 'custom',
                isPinned: false,
                orderIndex: 0,
                metadata: { source: 'manual_deletion' }
            }, 'deleted');

            return { ...convo, insights: newInsights, insightsOrder: newOrder };
        });
    }, [updateConversation]);

    const reorderConversations = useCallback((sourceIndex: number, destIndex: number) => {
        setChatState(prev => {
            const newOrder = [...prev.order];
            const [removed] = newOrder.splice(sourceIndex, 1);
            newOrder.splice(destIndex, 0, removed);
            return { ...prev, order: newOrder };
        });
    }, []);

    const markInsightAsRead = useCallback((convoId: string, insightId: string) => {
        updateConversation(convoId, convo => {
            if (convo.insights?.[insightId]?.isNew) {
                const newInsights = { ...convo.insights };
                newInsights[insightId] = { ...newInsights[insightId], isNew: false };
                return { ...convo, insights: newInsights };
            }
            return convo;
        }, true); // skip timestamp update
    }, [updateConversation]);

    const pinConversation = useCallback((convoId: string, isPinned: boolean) => {
        updateConversation(convoId, convo => ({
            ...convo,
            isPinned,
        }));
    }, [updateConversation]);

    const deleteConversation = useCallback((convoId: string) => {
        if (convoId === EVERYTHING_ELSE_ID) return;
        setChatState(prev => {
            const newConversations = { ...prev.conversations };
            delete newConversations[convoId];
            const newOrder = prev.order.filter(id => id !== convoId);
            let newActiveId = prev.activeId;
            if (prev.activeId === convoId) {
                newActiveId = EVERYTHING_ELSE_ID;
            }
            return { conversations: newConversations, order: newOrder, activeId: newActiveId };
        });
    }, []);

    const reorderInsights = useCallback((convoId: string, sourceIndex: number, destIndex: number) => {
        updateConversation(convoId, convo => {
            if (!convo.insightsOrder) return convo;
            const newOrder = [...convo.insightsOrder];
            const [removed] = newOrder.splice(sourceIndex, 1);
            newOrder.splice(destIndex, 0, removed);
            return { ...convo, insightsOrder: newOrder };
        });
    }, [updateConversation]);

    const overwriteInsight = useCallback((convoId: string, insightId: string, newTitle: string, newContent: string) => {
        updateConversation(convoId, convo => {
            if (!convo.insights || !convo.insights[insightId]) return convo;
            
            const oldInsight = convo.insights[insightId];
            const newInsights = { ...convo.insights };
            newInsights[insightId] = {
                ...oldInsight,
                title: newTitle,
                content: newContent,
                status: 'loaded',
                isNew: true,
            };

            // Track insight modification for game analytics
            const gameContext = gameAnalyticsService.extractGameContext(convo);
            gameAnalyticsService.trackInsightModification({
                conversationId: convoId,
                insightId: insightId,
                modificationType: 'updated',
                oldContent: oldInsight.content,
                newContent: newInsights[insightId].content,
                changeSummary: `Title changed from "${oldInsight.title}" to "${newTitle}"`,
                metadata: { source: 'manual_overwrite', oldTitle: oldInsight.title, newTitle, oldContent: oldInsight.content, newContent }
            });

            return { ...convo, insights: newInsights };
        });
    }, [updateConversation]);

    const createNewInsight = useCallback((convoId: string, title: string, content: string) => {
        updateConversation(convoId, convo => {
            const newId = generateGameId(title);
            if (convo.insights?.[newId]) {
                addSystemMessage(`An insight with a similar title already exists. Please choose a different title.`);
                return convo;
            }
            const newInsight: Insight = {
                id: newId,
                title,
                content,
                status: 'loaded',
                isNew: true,
            };
            const newInsights = { ...(convo.insights || {}), [newId]: newInsight };
            const newOrder = [...(convo.insightsOrder || []), newId];

            // Track insight creation for game analytics
            const gameContext = gameAnalyticsService.extractGameContext(convo);
            gameAnalyticsService.trackInsightCreated(
                gameContext.gameId,
                gameContext.gameTitle,
                convoId,
                newId,
                newInsight,
                { source: 'manual_creation', title, content }
            );

            return { ...convo, insights: newInsights, insightsOrder: newOrder };
        });
    }, [updateConversation, addSystemMessage]);

    const updateMessageFeedback = useCallback((convoId: string, messageId: string, vote: ChatMessageFeedback) => {
        updateMessageInConversation(convoId, messageId, msg => ({ ...msg, feedback: vote }));

        // Track AI response feedback for game analytics
        const conversation = conversations[convoId];
        const gameContext = gameAnalyticsService.extractGameContext(conversation);
        
        gameAnalyticsService.trackAIResponseFeedback(
            convoId,
            messageId,
            vote,
            undefined, // No feedback text for thumbs up/down
            { 
                responseType: 'ai_message',
                feedbackType: vote,
                gameId: gameContext.gameId,
                gameTitle: gameContext.gameTitle
            },
            { 
                userTier: unifiedUsageService.getTier(),
                source: 'message_feedback'
            }
        );
    }, [updateMessageInConversation, conversations, unifiedUsageService]);

    const updateInsightFeedback = useCallback((convoId: string, insightId: string, vote: ChatMessageFeedback) => {
        updateConversation(convoId, convo => {
            if (!convo.insights?.[insightId]) return convo;
            
            const oldInsight = convo.insights[insightId];
            const newInsights = { ...convo.insights };
            newInsights[insightId] = { ...oldInsight, feedback: vote };

            // Track insight feedback for game analytics
            const gameContext = gameAnalyticsService.extractGameContext(convo);
            gameAnalyticsService.trackUserFeedback({
                conversationId: convoId,
                targetType: 'insight',
                targetId: insightId,
                feedbackType: vote === 'up' ? 'up' : 'down',
                feedbackText: `${vote} on insight`,
                aiResponseContext: undefined,
                metadata: { 
                    insightTitle: oldInsight.title,
                    insightContent: oldInsight.content,
                    feedbackType: vote,
                    gameId: gameContext.gameId,
                    gameTitle: gameContext.gameTitle
                }
            });

            return { ...convo, insights: newInsights };
        });
    }, [updateConversation]);

    // Function to trigger intelligent insight updates based on AI response context
    const triggerIntelligentInsightUpdate = useCallback(async (
        conversationId: string,
        aiResponseText: string,
        gameName?: string,
        genre?: string,
        progress?: number
    ) => {
        if (!gameName || !genre || progress === undefined) {
            console.log('Missing game context for intelligent insight update');
            return;
        }

        const conversation = conversations[conversationId];
        if (!conversation || !conversation.insights) {
            console.log('No insights found for intelligent update');
            return;
        }

        console.log(`ðŸ§  Triggering intelligent insight update for: ${gameName} based on AI response context`);
        
        // This would integrate with the enhanced insights system
        // For now, we'll log the context for future integration
        console.log('AI Response Context:', aiResponseText.substring(0, 200) + '...');
        console.log('Game Context:', { gameName, genre, progress });
        
        // TODO: Integrate with enhanced insights system to trigger updates
        // This would call the updateInsightsForUserQuery function with the AI response context
    }, [conversations]);
    
    const sendMessage = useCallback(async (text: string, images?: ImageFile[], isFromPC?: boolean): Promise<{ success: boolean; reason?: string }> => {
        // Check if this is a tab management command
        if (text.startsWith('[TAB_MANAGEMENT] ')) {
            const commandText = text.replace('[TAB_MANAGEMENT] ', '');
            const result = await handleTabManagementCommand(commandText);
            
            if (result) {
                // Add a system message showing the result
                addSystemMessage(result.message, activeConversationId, false);
                return { success: result.success, reason: result.error };
            }
        }
        
        const textQueries = text.trim().length > 0 ? 1 : 0;
        const imageQueries = images ? images.length : 0;

        if (textQueries === 0 && imageQueries === 0) return { success: true };
        
        // Track feature usage
        analyticsService.trackFeatureUsage({
            featureName: 'send_message',
            featureCategory: 'chat',
            metadata: { 
                hasText: textQueries > 0, 
                hasImages: imageQueries > 0,
                isFromPC: isFromPC || false
            }
        });

        // Track user query for game analytics
        const queryId = crypto.randomUUID();
        const sourceConversation = conversationsRef.current[activeConversationId];
        if (sourceConversation) {
            gameAnalyticsService.trackUserQuery({
                conversationId: activeConversationId,
                queryType: imageQueries > 0 ? 'image' : 'text',
                queryText: text.trim(),
                hasImages: imageQueries > 0,
                imageCount: imageQueries,
                queryLength: text.trim().length,
                responseTimeMs: 0, // Will be updated later
                success: true,
                gameContext: sourceConversation.id !== EVERYTHING_ELSE_ID ? { gameId: sourceConversation.id } : undefined
            });
        }
        
        ttsService.cancel();

        const userMessage: ChatMessage = {
            id: crypto.randomUUID(),
            role: 'user',
            text,
            images: images?.map(img => img.dataUrl),
            isFromPC
        };

        const sourceConvoId = activeConversationId;
        
        const modelMessageId = crypto.randomUUID();
        const placeholderMessage: ChatMessage = { id: modelMessageId, role: 'model', text: '' };

        // Add user and placeholder messages to the source conversation immediately for UI responsiveness
        updateConversation(sourceConvoId, convo => ({
            ...convo,
            messages: [...convo.messages, userMessage, placeholderMessage]
        }));
        setLoadingMessages(prev => [...prev, modelMessageId]);
        
        const usage = await unifiedUsageService.getUsage();
        const { tier, textCount, textLimit, imageCount, imageLimit } = usage;
        
        if (tier === 'free') {
            if ((textQueries > 0 && textCount >= textLimit) || (imageQueries > 0 && imageCount >= imageLimit)) {
                 addSystemMessage(`You've used all your free queries for this month. Upgrade to Pro for more.`, sourceConvoId, true);
                 setLoadingMessages(prev => prev.filter(id => id !== modelMessageId));
                 updateMessageInConversation(sourceConvoId, modelMessageId, msg => ({...msg, text: ""}));
                return { success: false, reason: 'limit_reached' };
            }
        }
        
        await unifiedUsageService.incrementQueryCount('text', textQueries);
        await unifiedUsageService.incrementQueryCount('image', imageQueries);

        const controller = new AbortController();
        abortControllersRef.current[modelMessageId] = controller;
        
        if (!sourceConversation) return { success: false, reason: 'conversation_not_found' };

        const history = sourceConversation.messages || [];
        const isProUser = (await unifiedUsageService.getTier()) !== 'free';
        
        const onError = (error: string) => {
            setLoadingMessages(prev => prev.filter(id => id !== modelMessageId));
            updateMessageInConversation(activeConversationId, modelMessageId, msg => ({ ...msg, text: `Error: ${error}`}));
        };

        try {
            // --- Game Knowledge System Integration ---
            // Try to get a smart response from our knowledge base first
            const { gameKnowledgeService } = await import('../services/gameKnowledgeService');
            const gameTitle = sourceConversation.id !== EVERYTHING_ELSE_ID ? sourceConversation.id : undefined;
            
            const smartResponse = await gameKnowledgeService.getSmartResponse(text.trim(), gameTitle);
            
            if (smartResponse.source === 'knowledge_base' && smartResponse.confidence >= 0.8) {
                // Use knowledge base response instead of calling AI
                console.log('Using knowledge base response:', smartResponse);
                
                // Update the message with the knowledge base response
                const finalCleanedText = smartResponse.response;
                updateMessageInConversation(activeConversationId, modelMessageId, msg => ({ ...msg, text: finalCleanedText }));
                
                // Track successful knowledge base usage
                gameAnalyticsService.trackKnowledgeBaseUsage(
                    gameTitle || 'unknown',
                    text.trim(),
                    smartResponse.confidence,
                    smartResponse.metadata
                );
                
                // Learn from this successful interaction
                await gameKnowledgeService.learnFromAIResponse(text.trim(), smartResponse.response, gameTitle, true);
                
                setLoadingMessages(prev => prev.filter(id => id !== modelMessageId));
                return { success: true, reason: 'knowledge_base_response' };
            }
            
            // --- Context Injection for Companion AI ---
            let metaNotes = '';
            
            // Initialize conversation context
            const context = contextManagementService.initializeConversationContext(
                sourceConversation.id,
                sourceConversation.id !== EVERYTHING_ELSE_ID ? sourceConversation.id : null
            );
            
            // Add message to history
            contextManagementService.addMessageToHistory(sourceConversation.id, text);
            
            // Add player profile context
            const profileContext = playerProfileService.getProfileContext();
            if (profileContext) {
                metaNotes += `${profileContext}\n`;
            }
            
            // Add conversation context
            const conversationContext = contextManagementService.getContextForAI(sourceConversation.id);
            if (conversationContext) {
                metaNotes += `${conversationContext}\n`;
            }
            
            if(sourceConversation.id !== EVERYTHING_ELSE_ID) {
                // Add game context
                const gameContext = playerProfileService.getGameContextForAI(sourceConversation.id);
                if (gameContext) {
                    metaNotes += `${gameContext}\n`;
                }
                
                // Existing context injection
                if (sourceConversation.insights?.story_so_far?.content) {
                    metaNotes += `[META_STORY_SO_FAR: ${sourceConversation.insights.story_so_far.content}]\n`;
                }
                if (sourceConversation.activeObjective) {
                    metaNotes += `[META_ACTIVE_OBJECTIVE: ${JSON.stringify(sourceConversation.activeObjective)}]\n`;
                }
                 if (sourceConversation.inventory?.length) {
                    metaNotes += `[META_INVENTORY: ${sourceConversation.inventory.join(', ')}]\n`;
                }
                
                // NEW: Insight tab context injection to prevent repetition
                if (sourceConversation.insights) {
                    const insightTabs = Object.entries(sourceConversation.insights);
                    if (insightTabs.length > 0) {
                        metaNotes += `[META_INSIGHT_TABS_CONTEXT: The following insight tabs already exist with content - DO NOT regenerate similar content for these tabs:\n`;
                        
                        insightTabs.forEach(([tabId, insight]) => {
                            if (insight && insight.content) {
                                // Truncate content to avoid context bloat
                                const truncatedContent = insight.content.length > 200 
                                    ? insight.content.substring(0, 200) + '...' 
                                    : insight.content;
                                metaNotes += `- ${tabId}: "${truncatedContent}"\n`;
                            }
                        });
                        
                        metaNotes += `When generating new insights, avoid duplicating content from these existing tabs and focus on new, complementary information.]\n`;
                    }
                }
            }

            // NEW: Add task completion context
            if (sourceConversation.id !== EVERYTHING_ELSE_ID) {
                const { taskCompletionPromptingService } = await import('../services/taskCompletionPromptingService');
                const completionContext = taskCompletionPromptingService.formatCompletionContext(sourceConversation.id);
                if (completionContext) {
                    metaNotes += `${completionContext}\n`;
                    // Clear the pending completions after they've been included in context
                    taskCompletionPromptingService.clearPendingCompletions(sourceConversation.id);
                }
            }
            // --- End Context Injection ---

            const promptText = metaNotes + (text.trim() || "A player needs help. First, identify the game from this screenshot. Then, provide a spoiler-free hint and some interesting lore about what's happening in the image.");
            
            let rawTextResponse = "";
            let hasError = false;

            const onChunk = (chunk: string) => {
                if (isCooldownActive) setIsCooldownActive(false);
                rawTextResponse += chunk;
                const displayText = rawTextResponse.replace(tagCleanupRegex, '').replace(/^[\s`"\]\}]*/, '').trim();
                updateMessageInConversation(activeConversationId, modelMessageId, msg => ({ ...msg, text: displayText }));
                
                // ðŸš« REMOVED: Real-time insight updates to prevent unauthorized API calls
                // Insights are now only updated when user explicitly requests them
                if (isProUser && chunk.length > 0) {
                    console.log('ðŸš« Real-time insight updates disabled - insights only updated on user request');
                }
            };

            const onStreamingError = (error: string) => {
                hasError = true;
                if (error === 'QUOTA_EXCEEDED') {
                    handleQuotaError(modelMessageId);
                } else {
                    updateMessageInConversation(activeConversationId, modelMessageId, msg => ({ ...msg, text: error }));
                    if (isHandsFreeMode) ttsService.speak(error).catch(() => {});
                }
                setLoadingMessages(prev => prev.filter(id => id !== modelMessageId));
            };

            if (isProUser) {
                const imageParts = images ? images.map(img => ({ base64: img.base64, mimeType: img.mimeType })) : null;
                rawTextResponse = await generateInitialProHint(promptText, imageParts, sourceConversation, history, onError, controller.signal) || "";
            } else {
                if (images && images.length > 0) {
                    const imageParts = images.map(img => ({ base64: img.base64, mimeType: img.mimeType }));
                    await sendMessageWithImages(promptText, imageParts, sourceConversation, controller.signal, onChunk, onStreamingError, history);
                } else {
                    await sendTextToGemini(promptText, sourceConversation, controller.signal, onChunk, onStreamingError, history);
                }
            }
            
            if (controller.signal.aborted || hasError || !rawTextResponse) {
                if (!hasError) setLoadingMessages(prev => prev.filter(id => id !== modelMessageId));
                return { success: false, reason: 'cancelled' };
            }
            
            console.log("Raw model response:", rawTextResponse);
            setLoadingMessages(prev => prev.filter(id => id !== modelMessageId));

            // --- TTS EXTRACTION ---
            // Extract hint for TTS *before* stripping any tags
            const hintMatch = rawTextResponse.match(/\[OTAKON_HINT_START\]([\s\S]*?)\[OTAKON_HINT_END\]/);

            // --- Step 1: Extract all data from the raw response before cleaning ---
            let identifiedGameName: string | null = null;
            let gameGenre: string | null = null;
            let gameProgress: number | null = null;
            let suggestions: string[] = [];
            let triumphPayload: ChatMessage['triumph'] | undefined;
            let parsedInventory: { items: string[] } | null = null;
            let insightUpdate: { id: string; content: string } | null = null;
            let insightModifyPending: PendingInsightModification | null = null;
            let insightDeleteRequest: { id: string } | null = null;
            let isGameUnreleased = false;
            let objectiveSet: { description: string } | null = null;
            let objectiveComplete = false;

            const gameIdMatch = rawTextResponse.match(/\[OTAKON_GAME_ID:\s*(.*?)\]/);
            if (gameIdMatch) identifiedGameName = gameIdMatch[1].trim();

            const genreMatch = rawTextResponse.match(/\[OTAKON_GENRE:\s*(.*?)\]/);
            if (genreMatch) gameGenre = genreMatch[1].trim();

            const confidenceMatch = rawTextResponse.match(/\[OTAKON_CONFIDENCE:\s*(high|low)\]/);
            if (confidenceMatch?.[1] === 'high' || (identifiedGameName && !images)) {
                const progressMatch = rawTextResponse.match(/\[OTAKON_GAME_PROGRESS:\s*(\d+)\]/);
                if (progressMatch) gameProgress = parseInt(progressMatch[1], 10);
            }

            if (rawTextResponse.includes('[OTAKON_GAME_IS_UNRELEASED: true]')) {
                isGameUnreleased = true;
            }

            const triumphMatch = rawTextResponse.match(/\[OTAKON_TRIUMPH:\s*({.*?})\]/s);
            if (triumphMatch?.[1]) try { triumphPayload = JSON.parse(triumphMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_TRIUMPH:', e, 'Raw:', triumphMatch[1]); }

            const inventoryMatch = rawTextResponse.match(/\[OTAKON_INVENTORY_ANALYSIS:\s*({.*?})\]/s);
            if (inventoryMatch?.[1]) try { parsedInventory = JSON.parse(inventoryMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_INVENTORY_ANALYSIS:', e, 'Raw:', inventoryMatch[1]); }

            const suggestionsMatch = rawTextResponse.match(/\[OTAKON_SUGGESTIONS:\s*(\[.*?\])\]/s);
            if (suggestionsMatch?.[1]) try { suggestions = JSON.parse(suggestionsMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_SUGGESTIONS:', e, 'Raw:', suggestionsMatch[1]); }

            const insightUpdateMatch = rawTextResponse.match(/\[OTAKON_INSIGHT_UPDATE:\s*({.*?})\]/s);
            if (insightUpdateMatch?.[1]) try { insightUpdate = JSON.parse(insightUpdateMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_INSIGHT_UPDATE:', e, 'Raw:', insightUpdateMatch[1]); }

            const insightModifyPendingMatch = rawTextResponse.match(/\[OTAKON_INSIGHT_MODIFY_PENDING:\s*({.*?})\]/s);
            if (insightModifyPendingMatch?.[1]) try { insightModifyPending = JSON.parse(insightModifyPendingMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_INSIGHT_MODIFY_PENDING:', e, 'Raw:', insightModifyPendingMatch[1]); }

            const insightDeleteRequestMatch = rawTextResponse.match(/\[OTAKON_INSIGHT_DELETE_REQUEST:\s*({.*?})\]/s);
            if (insightDeleteRequestMatch?.[1]) try { insightDeleteRequest = JSON.parse(insightDeleteRequestMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_INSIGHT_DELETE_REQUEST:', e, 'Raw:', insightDeleteRequestMatch[1]); }
            
            const objectiveSetMatch = rawTextResponse.match(/\[OTAKON_OBJECTIVE_SET:\s*({.*?})\]/s);
            if (objectiveSetMatch?.[1]) try { objectiveSet = JSON.parse(objectiveSetMatch[1]); } catch(e){ console.warn('Failed to parse OTAKON_OBJECTIVE_SET:', e, 'Raw:', objectiveSetMatch[1]); }

            if (rawTextResponse.includes('[OTAKON_OBJECTIVE_COMPLETE: true]')) {
                objectiveComplete = true;
            }

            // --- Step 2: Clean the text and update conversation state ---
            const hintTagsRegex = /\[OTAKON_HINT_START\]|\[OTAKON_HINT_END\]/g;
            
            let finalCleanedText = rawTextResponse
                .replace(hintTagsRegex, '') // Remove hint tags for display
                .replace(tagCleanupRegex, '')
                .replace(/^Game Progress: \d+%\s*$/m, '')
                .replace(/^[\s`"\]\}]*/, '')
                .replace(/[\s`"\]\}]*$/, '')
                // Remove these problematic lines that filter out formatting:
                // .replace(/\s+/g, ' ') // Clean up multiple spaces
                // .replace(/\n\s*\n/g, '\n') // Clean up multiple newlines
                .trim();
            
            // Show notification for AI response if screen is locked
            if (smartNotificationService.isScreenLocked()) {
                smartNotificationService.showAINotification(finalCleanedText, sourceConvoId);
            }

            let finalTargetConvoId = sourceConvoId;
            const identifiedGameId = identifiedGameName ? generateGameId(identifiedGameName) : null;
            
            if (identifiedGameId && (sourceConvoId === EVERYTHING_ELSE_ID || identifiedGameId !== sourceConvoId)) {
                console.log(`New game detected: "${identifiedGameName}". Creating/switching to new conversation tab.`);
                finalTargetConvoId = identifiedGameId;
                
                // NEW: Track game switch in screenshot timeline service
                if (images && images.length > 0) {
                    try {
                        const { screenshotTimelineService } = await import('../services/screenshotTimelineService');
                        await screenshotTimelineService.handleGameSwitch(
                            sourceConvoId,
                            finalTargetConvoId,
                            identifiedGameName!,
                            identifiedGameId
                        );
                        console.log(`ðŸ”„ Game switch tracked in timeline: ${sourceConvoId} â†’ ${finalTargetConvoId}`);
                    } catch (error) {
                        console.warn('Failed to track game switch in timeline:', error);
                    }
                }
            }

            // NEW: Generate AI suggested tasks for Pro/Vanguard users
            if (finalTargetConvoId !== EVERYTHING_ELSE_ID && rawTextResponse) {
                try {
                    const userTier = await unifiedUsageService.getTier();
                    if (userTier === 'pro' || userTier === 'vanguard_pro') {
                        // Get context for task generation using statically imported services
                        
                        const longTermContext = longTermMemoryService.getLongTermContext(finalTargetConvoId);
                        const screenshotTimelineContext = screenshotTimelineService.getTimelineContext(finalTargetConvoId);
                        
                        // Get insight tab context from the conversation
                        const targetConversation = conversations[finalTargetConvoId];
                        const insightTabContext = targetConversation?.insights ? 
                          unifiedAIService.getInsightTabContext(targetConversation) : '';
                        
                        // Generate AI suggested tasks
                        const suggestedTasks = await unifiedAIService.generateSuggestedTasks(
                          targetConversation || { id: finalTargetConvoId, title: identifiedGameName || 'Unknown Game' },
                          text,
                          rawTextResponse
                        );
                        
                        // Add tasks to Otaku Diary
                        if (suggestedTasks.length > 0) {
                          await otakuDiaryService.addAISuggestedTasks(finalTargetConvoId, suggestedTasks);
                          console.log(`ðŸŽ¯ Added ${suggestedTasks.length} AI suggested tasks for ${finalTargetConvoId}`);
                        }
                    }
                } catch (error) {
                  console.warn('Failed to generate AI suggested tasks:', error);
                }
            }

            // NEW: Get task completion prompt from AI response
            let taskCompletionPrompt = undefined;
            if (finalTargetConvoId !== EVERYTHING_ELSE_ID) {
                try {
                    const { unifiedAIService } = await import('../services/unifiedAIService');
                    const { otakuDiaryService } = await import('../services/otakuDiaryService');
                    const { taskCompletionPromptingService } = await import('../services/taskCompletionPromptingService');
                    
                    const userTier = await unifiedUsageService.getTier();
                    const centralTasks = await otakuDiaryService.getCentralTasks(finalTargetConvoId);
                    const aiGeneratedTasks = await otakuDiaryService.getAISuggestedTasks(finalTargetConvoId);
                    
                    taskCompletionPrompt = taskCompletionPromptingService.generateCompletionPrompt(
                        finalTargetConvoId,
                        userTier,
                        centralTasks,
                        aiGeneratedTasks
                    );
                } catch (error) {
                    console.warn('Failed to generate task completion prompt:', error);
                }
            }
            
            setChatState(prev => {
                let newConversations = { ...prev.conversations };
                let newOrder = [...prev.order];
                let newActiveId = prev.activeId;
                const sourceConvo = newConversations[sourceConvoId];
                if (!sourceConvo) return prev;

                const finalModelMessage: ChatMessage = {
                    id: modelMessageId, role: 'model', text: finalCleanedText,
                    suggestions: suggestions.length > 0 ? suggestions : undefined,
                    triumph: triumphPayload,
                    taskCompletionPrompt, // NEW: Add task completion prompt
                };
                
                const isNewConversation = finalTargetConvoId !== sourceConvoId;
                if (isNewConversation) {
                    const doesTargetExist = !!newConversations[finalTargetConvoId];
                    const targetConvo = newConversations[finalTargetConvoId] || { id: finalTargetConvoId, title: identifiedGameName!, messages: [], createdAt: Date.now() };
                    targetConvo.messages = [...targetConvo.messages, userMessage, finalModelMessage];
                    newConversations[finalTargetConvoId] = targetConvo;
                    sourceConvo.messages = sourceConvo.messages.filter(m => m.id !== userMessage.id && m.id !== modelMessageId);
                    
                    if (!doesTargetExist) {
                        const newOrderSet = new Set([EVERYTHING_ELSE_ID, finalTargetConvoId, ...prev.order]);
                        newOrder = Array.from(newOrderSet);
                    }
                    if (isChatActive(sourceConvoId)) {
                        renameChatSession(sourceConvoId, finalTargetConvoId);
                    }
                } else {
                    sourceConvo.messages = sourceConvo.messages.map(m => m.id === modelMessageId ? finalModelMessage : m);
                }
                
                const targetConvoForUpdate = newConversations[finalTargetConvoId];
                if (targetConvoForUpdate) {
                     if (isProUser && identifiedGameName && gameGenre && !targetConvoForUpdate.insights) {
                        const tabs = insightTabsConfig[gameGenre] || insightTabsConfig.default;
                        const insightsOrder = tabs.map(t => t.id);
                        
                        // Create insight tabs with loading status - will be populated with actual content
                        const instantInsights: Record<string, Insight> = {};
                        tabs.forEach(tab => {
                            instantInsights[tab.id] = { 
                                id: tab.id, 
                                title: tab.title, 
                                content: 'ðŸ”„ Generating comprehensive insights for you...', 
                                status: 'loading' as any,
                                isPlaceholder: false,
                                lastUpdated: Date.now(),
                                generationAttempts: 0
                            };
                        });
                        
                        // ðŸ”¥ CRITICAL INTEGRATION: Add Otaku Diary tab for ALL users (free, pro, vanguard)
                        const otakuDiaryInsight: Insight = {
                            id: 'otaku-diary',
                            title: 'ðŸ“– Otaku Diary',
                            content: 'ðŸ“ **Your Personal Game Diary**\n\nâœ¨ Track your tasks and favorite moments\n\nðŸŽ¯ **Features:**\nâ€¢ Create and manage to-do lists\nâ€¢ Save favorite AI responses and insights\nâ€¢ Track your gaming progress\nâ€¢ Organize your thoughts and discoveries\n\nðŸš€ **Available for all users!**',
                            status: 'loaded' as any,
                            isPlaceholder: false,
                            lastUpdated: Date.now(),
                            generationAttempts: 0
                        };
                        
                        // Add Otaku Diary to insights and order
                        instantInsights['otaku-diary'] = otakuDiaryInsight;
                        insightsOrder.unshift('otaku-diary'); // Put Otaku Diary first
                        
                        targetConvoForUpdate.insights = instantInsights;
                        targetConvoForUpdate.insightsOrder = insightsOrder;
                        
                        console.log(`ðŸ”„ Created Otaku Diary tab for game: ${identifiedGameName}`);
                        
                        // Generate all insights in one API call for better performance
                        if (gameProgress !== null) {
                            generateAllInsightsAtOnce(identifiedGameName, gameGenre, gameProgress, finalTargetConvoId);
                        }
                    }
                    if (gameProgress !== null) targetConvoForUpdate.progress = gameProgress;
                    if (parsedInventory?.items) targetConvoForUpdate.inventory = parsedInventory.items;
                    if (gameGenre) targetConvoForUpdate.genre = gameGenre;
                    if (insightUpdate && targetConvoForUpdate.insights?.[insightUpdate.id]) {
                        const oldContent = targetConvoForUpdate.insights[insightUpdate.id].content;
                        const separator = oldContent && oldContent !== 'Loading...' ? '\n\n' : '';
                        const newContent = (oldContent === 'Loading...' ? '' : oldContent) + separator + insightUpdate.content;
                        targetConvoForUpdate.insights[insightUpdate.id].content = newContent;
                        targetConvoForUpdate.insights[insightUpdate.id].status = 'loaded';
                        targetConvoForUpdate.insights[insightUpdate.id].isNew = true;
                    }
                    if(isGameUnreleased) targetConvoForUpdate.lastTrailerTimestamp = Date.now();
                     if (objectiveSet) {
                        targetConvoForUpdate.activeObjective = { description: objectiveSet.description, isCompleted: false };
                    }
                    if (objectiveComplete && targetConvoForUpdate.activeObjective) {
                        targetConvoForUpdate.activeObjective.isCompleted = true;
                    }
                    targetConvoForUpdate.lastInteractionTimestamp = Date.now();
                }

                newActiveId = finalTargetConvoId;
                newOrder = newOrder.sort(sortConversations(newConversations));

                return { conversations: newConversations, order: newOrder, activeId: newActiveId };
            });

            if (isHandsFreeMode) {
                // Use the extracted game help section. If missing, extract the most relevant part of the response.
                let textToSpeak = '';
                
                if (hintMatch) {
                    // Use the explicitly marked game help section
                    textToSpeak = hintMatch[1].trim();
                    console.log('ðŸŽ¤ Hands-free: Using explicit game help section');
                } else {
                    // Fallback: Extract the most relevant part of the response for hands-free mode
                    textToSpeak = extractGameHelpFromResponse(finalCleanedText, text.trim());
                    console.log('ðŸŽ¤ Hands-free: Using extracted game help (no explicit tags found)');
                }
                
                if (textToSpeak) {
                    ttsService.speak(textToSpeak).catch(error => addSystemMessage(`Could not play audio hint: ${error.message}`));
                }
            }

            // ðŸ”¥ NEW: Consolidated insight update function that only runs on user queries
            if (isProUser && finalTargetConvoId !== EVERYTHING_ELSE_ID) {
                updateInsightsOnUserQuery(finalCleanedText, finalTargetConvoId, identifiedGameName, gameGenre, gameProgress, text.trim());
            }

            // Note: Insights are now generated in one unified API call for better performance
            // All insight tabs are populated simultaneously when the user makes a query

            if (insightModifyPending) setPendingModification(insightModifyPending);
            if (insightDeleteRequest) deleteInsight(finalTargetConvoId, insightDeleteRequest.id);

            // --- Game Knowledge Learning ---
            // Learn from this AI response to improve our knowledge base
            try {
                const gameTitle = finalTargetConvoId !== EVERYTHING_ELSE_ID ? finalTargetConvoId : identifiedGameName;
                if (gameTitle && finalCleanedText) {
                    await gameKnowledgeService.learnFromAIResponse(
                        text.trim(),
                        finalCleanedText,
                        gameTitle,
                        true // Assume helpful response
                    );
                    
                    // Track knowledge learning for analytics
                    gameAnalyticsService.trackKnowledgeLearning(
                        gameTitle,
                        text.trim(),
                        finalCleanedText.length,
                        'ai_response'
                    );
                }
            } catch (error) {
                console.warn('Failed to learn from AI response:', error);
            }

            // Track successful user query completion for game analytics
            const conversation = conversations[finalTargetConvoId];
            const gameContext = gameAnalyticsService.extractGameContext(conversation);
            
            gameAnalyticsService.trackUserQuery({
                conversationId: finalTargetConvoId,
                queryType: imageQueries > 0 ? 'image' : 'text',
                queryText: text,
                hasImages: imageQueries > 0,
                imageCount: imageQueries,
                queryLength: text.length,
                aiResponseLength: finalCleanedText.length,
                responseTimeMs: Date.now() - (gameAnalyticsService as any).queryStartTime || 0,
                success: true,
                gameContext,
                metadata: { 
                    userTier: unifiedUsageService.getTier(),
                    isFromPC: isFromPC || false,
                    gameGenre,
                    gameProgress,
                    isGameUnreleased,
                    hasInsights: !!insightUpdate,
                    hasObjective: !!objectiveSet
                }
            });

            return { success: true };

        } catch(e) {
            const message = e instanceof Error ? e.message : 'An unknown error occurred.';
            onError(message);

            // Track failed user query for game analytics
            const conversation = conversations[sourceConvoId];
            const gameContext = gameAnalyticsService.extractGameContext(conversation);
            
            gameAnalyticsService.trackUserQuery({
                conversationId: sourceConvoId,
                queryType: imageQueries > 0 ? 'image' : 'text',
                queryText: text,
                hasImages: imageQueries > 0,
                imageCount: imageQueries,
                queryLength: text.length,
                responseTimeMs: Date.now() - (gameAnalyticsService as any).queryStartTime || 0,
                success: false,
                errorMessage: message,
                gameContext,
                metadata: { 
                    userTier: unifiedUsageService.getTier(),
                    isFromPC: isFromPC || false,
                    error: message
                }
            });

            return { success: false, reason: 'error' };
        } finally {
            delete abortControllersRef.current[modelMessageId];
        }
    }, [activeConversationId, isHandsFreeMode, addSystemMessage, handleQuotaError, updateConversation, updateMessageInConversation, deleteInsight]);
    
    const stopMessage = useCallback((messageId: string) => {
        ttsService.cancel();
        abortControllersRef.current[messageId]?.abort();
        delete abortControllersRef.current[messageId];
        setLoadingMessages(prev => prev.filter(id => id !== messageId));
        updateMessageInConversation(activeConversationId, messageId, msg => ({ ...msg, text: '*Request cancelled by user.*' }));
    }, [activeConversationId, updateMessageInConversation]);
    
    const resetConversations = useCallback(() => {
        ttsService.cancel();
        resetGeminiChat();
        // Clear all conversation-related localStorage
        localStorage.removeItem(CONVERSATIONS_STORAGE_KEY);
        localStorage.removeItem('otakon_conversations_order');
        localStorage.removeItem('otakon_active_conversation');
        setChatState({
            conversations: { [EVERYTHING_ELSE_ID]: { id: EVERYTHING_ELSE_ID, title: 'Everything else', messages: [], createdAt: Date.now() } },
            order: [EVERYTHING_ELSE_ID],
            activeId: EVERYTHING_ELSE_ID
        });
        setLoadingMessages([]);
        Object.values(abortControllersRef.current).forEach(c => c.abort());
        abortControllersRef.current = {};
    }, []);
    
    const switchConversation = useCallback((id: string) => {
        ttsService.cancel();
        if (conversations[id]) {
            setChatState(prev => ({...prev, activeId: id}));
        }
    }, [conversations]);
    
    const restoreHistory = useCallback((history: Conversations) => {
        if (!history || Object.keys(history).length === 0 || !history[EVERYTHING_ELSE_ID]) {
            resetConversations();
            return;
        }
        const newOrder = Object.keys(history).sort(sortConversations(history));
        setChatState({ conversations: history, order: newOrder, activeId: EVERYTHING_ELSE_ID });
    }, [resetConversations]);

    const fetchInsightContent = useCallback(async (conversationId: string, insightId: string) => {
        const conversation = conversations[conversationId];
        if (!conversation || !conversation.insights || !conversation.genre || typeof conversation.progress !== 'number') return;
    
        const insightTabConfig = (insightTabsConfig[conversation.genre] || insightTabsConfig.default).find(tab => tab.id === insightId);
        if (!insightTabConfig) return;
    
        updateConversation(conversationId, convo => ({
            ...convo,
            insights: { ...convo.insights!, [insightId]: { ...convo.insights![insightId], status: 'streaming' } }
        }));
    
        const controller = new AbortController();
        // You might want to store this controller in a ref if you need to abort it from elsewhere
    
        try {
            if (insightTabConfig.webSearch) {
                // Use the non-streaming function for web search
                const prompt = `Generate content for the "${insightTabConfig.title}" insight for the game ${conversation.title} (${conversation.genre}).
                
${insightTabConfig.instruction}

Game: ${conversation.title}
Genre: ${conversation.genre}
Progress: ${conversation.progress}%`;

                const fullContent = await generateInsightWithSearch(
                    prompt,
                    'flash', // Always use Flash for cost optimization
                    controller.signal
                );
                if (controller.signal.aborted) return;
                updateConversation(conversationId, convo => ({
                    ...convo,
                    insights: { ...convo.insights!, [insightId]: { ...convo.insights![insightId], content: fullContent, status: 'loaded', isNew: true } }
                }));
            } else {
                // Use the streaming function for non-search insights
                let fullContent = '';
                await generateInsightStream(
                    conversation.title,
                    conversation.genre,
                    conversation.progress,
                    insightTabConfig.instruction || '',
                    insightTabConfig.title,
                    (chunk) => {
                        if (controller.signal.aborted) return;
                        fullContent += chunk;
                        updateConversation(conversationId, convo => ({
                            ...convo,
                            insights: { ...convo.insights!, [insightId]: { ...convo.insights![insightId], content: fullContent, status: 'streaming' } }
                        }), true);
                    },
                    (error) => {
                        console.error(`Error streaming insight ${insightId}:`, error);
                        updateConversation(conversationId, convo => ({
                            ...convo,
                            insights: { ...convo.insights!, [insightId]: { ...convo.insights![insightId], content: `Error: ${error}`, status: 'error' } }
                        }));
                    },
                    controller.signal
                );

                if (controller.signal.aborted) return;

                updateConversation(conversationId, convo => ({
                    ...convo,
                    insights: { ...convo.insights!, [insightId]: { ...convo.insights![insightId], status: 'loaded', isNew: true } }
                }));
            }
        } catch (error) {
            if (error instanceof DOMException && error.name === 'AbortError') {
                console.log(`Fetch for insight ${insightId} was aborted.`);
            } else {
                const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
                console.error(`Error fetching content for insight ${insightId}:`, error);
                updateConversation(conversationId, convo => ({
                    ...convo,
                    insights: { ...convo.insights!, [insightId]: { ...convo.insights![insightId], content: `Error: ${errorMessage}`, status: 'error' } }
                }));
            }
        }
    }, [conversations, updateConversation]);

    // Retry function for failed messages
    const retryMessage = useCallback(async (messageId: string): Promise<{ success: boolean; reason?: string }> => {
        const conversation = conversations[activeConversationId];
        if (!conversation) return { success: false, reason: 'Conversation not found' };

        const message = conversation.messages.find(m => m.id === messageId);
        if (!message || message.role !== 'user') return { success: false, reason: 'Message not found or not a user message' };

        // Track retry usage
        analyticsService.trackFeatureUsage({
            featureName: 'retry_message',
            featureCategory: 'chat',
            metadata: { 
                originalMessageId: messageId,
                conversationId: activeConversationId
            }
        });

        // Remove the failed AI response
        updateConversation(activeConversationId, convo => ({
            ...convo,
            messages: convo.messages.filter(m => m.id !== messageId && m.role === 'user')
        }));

        // Resend the message - convert string[] to ImageFile[] if needed
        const imageFiles = message.images ? message.images.map(img => ({
            base64: img.split(',')[1] || img,
            mimeType: img.startsWith('data:') ? img.split(';')[0].split(':')[1] : 'image/png',
            dataUrl: img
        })) : undefined;
        return await sendMessage(message.text, imageFiles, message.isFromPC);
    }, [conversations, activeConversationId, updateConversation, sendMessage]);





    // Generate all insights in one API call for better performance
    const generateAllInsightsAtOnce = async (
        gameName: string,
        genre: string,
        progress: number,
        conversationId: string
    ) => {
        try {
            const tabs = insightTabsConfig[genre] || insightTabsConfig.default;
            
            // Update all tabs to show generation progress
            updateConversation(conversationId, convo => {
                if (convo.insights) {
                    Object.keys(convo.insights).forEach(tabId => {
                        if (convo.insights![tabId].status === 'loading') {
                            convo.insights![tabId].content = 'ðŸ”„ Generating comprehensive insights...';
                        }
                    });
                }
                return convo;
            });
            
            // Generate all insights in one API call using the unified service
            const result = await generateUnifiedInsights(
                gameName,
                genre,
                progress,
                `Generate comprehensive insights for ${gameName} at ${progress}% progress`,
                (error) => console.error('Unified insight generation error:', error),
                new AbortController().signal
            );
            
            if (result && result.insights) {
                // Update all insights with generated content
                updateConversation(conversationId, convo => {
                    if (convo.insights) {
                        Object.keys(result.insights).forEach(tabId => {
                            if (convo.insights![tabId]) {
                                convo.insights![tabId].content = result.insights[tabId].content;
                                convo.insights![tabId].title = result.insights[tabId].title;
                                convo.insights![tabId].status = 'loaded';
                                convo.insights![tabId].lastUpdated = Date.now();
                                convo.insights![tabId].isNew = true;
                            }
                        });
                    }
                    return convo;
                });
                
                console.log(`Successfully generated all insights for ${gameName} in one API call`);
            } else {
                // ðŸš« REMOVED: Fallback to progressive generation to prevent unauthorized API calls
                console.warn('ðŸš« Progressive insight generation disabled - insights only generated on user request');
            }
            
        } catch (error) {
            console.error('ðŸš« Unified insight generation failed:', error);
            console.warn('ðŸš« Progressive insight generation disabled - insights only generated on user request');
        }
    };

    // ðŸš¨ REMOVED: Automatic background insight generation to prevent unauthorized API calls
    // Insights are now only generated when user explicitly requests them
    const generateInsightsInBackground = async (
        gameName: string,
        genre: string,
        progress: number,
        conversationId: string
    ) => {
        console.log('ðŸš« Background insight generation disabled - insights only generated on user request');
        
        // Set all insights to placeholder status - they will be generated when user clicks
        const tabs = insightTabsConfig[genre] || insightTabsConfig.default;
        
        updateConversation(conversationId, convo => {
            if (!convo.insights) return convo;
            
            const updatedInsights = { ...convo.insights };
            tabs.forEach(tab => {
                if (updatedInsights[tab.id]?.isPlaceholder) {
                    updatedInsights[tab.id] = {
                        ...updatedInsights[tab.id],
                        status: 'placeholder',
                        content: `ðŸ’¡ Click to generate ${tab.title} content\n\nThis insight will be generated when you request it.`,
                        isPlaceholder: true
                    };
                }
            });
            
            return { ...convo, insights: updatedInsights };
        });
    };

    // ðŸš¨ REMOVED: Automatic insight updates to prevent unauthorized API calls
    // Insights are now only updated when user explicitly requests them
    const updateInsightsForProgress = useCallback(async (conversationId: string, newProgress: number) => {
        const conversation = conversations[conversationId];
        if (!conversation?.insights || !conversation.genre) return;

        const currentProgress = conversation.progress || 0;
        const progressDifference = Math.abs(newProgress - currentProgress);
        
        // Only update if progress changed significantly (more than 10%)
        if (progressDifference < 10) return;

        console.log(`Progress changed from ${currentProgress}% to ${newProgress}%, updating progress only...`);

        // Update progress in conversation (no automatic insight updates)
        updateConversation(conversationId, convo => ({
            ...convo,
            progress: newProgress
        }));

        // Mark progress-dependent insights as needing updates (user must click to regenerate)
        const tabs = insightTabsConfig[conversation.genre] || insightTabsConfig.default;
        const progressDependentTabs = tabs.filter(tab => 
            (tab.instruction && tab.instruction.includes('progress')) || 
            (tab.instruction && tab.instruction.includes('current')) ||
            tab.id === 'story_so_far' ||
            tab.id === 'current_objectives'
        );

        updateConversation(conversationId, convo => {
            if (!convo.insights) return convo;
            
            const updatedInsights = { ...convo.insights };
            progressDependentTabs.forEach(tab => {
                if (updatedInsights[tab.id] && !updatedInsights[tab.id].isPlaceholder) {
                    updatedInsights[tab.id] = {
                        ...updatedInsights[tab.id],
                        content: `ðŸ”„ Progress updated to ${newProgress}%\n\nðŸ’¡ Click to regenerate ${tab.title} with current progress`,
                        status: 'placeholder',
                        isNew: true,
                        lastUpdated: Date.now()
                    };
                }
            });
            
            return { ...convo, insights: updatedInsights };
        });

        console.log('ðŸš« Automatic insight updates disabled - insights only updated on user request');
    }, [conversations, updateConversation]);

    // ðŸš¨ REMOVED: Real-time insight updates to prevent unauthorized API calls
    // Insights are now only updated when user explicitly requests them
    const updateInsightsInRealTime = useCallback(async (chunk: string, sourceConversation: Conversation, targetConvoId: string) => {
        // No automatic updates - insights only change when user requests them
        console.log('ðŸš« Real-time insight updates disabled - insights only updated on user request');
    }, []);

    // Helper function to extract relevant information from streaming chunks
    const extractRelevantInfoFromChunk = (chunk: string) => {
        const hasRelevantContent = chunk.includes('story') || 
                                  chunk.includes('character') || 
                                  chunk.includes('quest') || 
                                  chunk.includes('objective') || 
                                  chunk.includes('inventory') || 
                                  chunk.includes('progress') ||
                                  chunk.includes('hint') ||
                                  chunk.includes('lore');
        
        return { hasRelevantContent };
    };

    // Helper function to check if a chunk is relevant to a specific insight tab
    const isChunkRelevantToInsight = (chunk: string, tab: any, newInfo: any) => {
        const tabId = tab.id;
        const chunkLower = chunk.toLowerCase();
        
        switch (tabId) {
            case 'story_so_far':
                return chunkLower.includes('story') || chunkLower.includes('plot') || chunkLower.includes('narrative');
            case 'current_objectives':
                return chunkLower.includes('objective') || chunkLower.includes('quest') || chunkLower.includes('goal');
            case 'character_insights':
                return chunkLower.includes('character') || chunkLower.includes('npc') || chunkLower.includes('companion');
            case 'world_lore':
                return chunkLower.includes('lore') || chunkLower.includes('world') || chunkLower.includes('history');
            case 'gameplay_tips':
                return chunkLower.includes('tip') || chunkLower.includes('hint') || chunkLower.includes('strategy');
            case 'inventory_analysis':
                return chunkLower.includes('inventory') || chunkLower.includes('item') || chunkLower.includes('equipment');
            default:
                return false;
        }
    };

    // ðŸ”¥ NEW: Consolidated insight update function that only runs on user queries
    const updateInsightsOnUserQuery = useCallback(async (
        finalResponse: string,
        conversationId: string,
        gameName: string | null,
        genre: string | null,
        progress: number | null,
        userQuery: string
    ) => {
        if (!gameName || !genre || progress === null || conversationId === EVERYTHING_ELSE_ID) {
            return;
        }

        try {
            console.log(`ðŸ”„ Updating insights for user query: "${userQuery}"`);
            
            // Extract all relevant information from the AI response
            const extractedInfo = {
                story: extractStoryInfo(finalResponse),
                objectives: extractObjectiveInfo(finalResponse),
                characters: extractCharacterInfo(finalResponse),
                lore: extractLoreInfo(finalResponse),
                tips: extractTipInfo(finalResponse),
                inventory: extractInventoryInfo(finalResponse),
                progress: progress,
                userQuery: userQuery
            };

            // Get insight tabs for this genre
            const tabs = insightTabsConfig[genre] || insightTabsConfig.default;
            
            // Update each insight tab with new information from this query/response
            for (const tab of tabs) {
                const insight = conversations[conversationId]?.insights?.[tab.id];
                if (insight && tab.id !== 'otaku-diary') { // Skip Otaku Diary
                    
                    let newContent = '';
                    let shouldUpdate = false;
                    
                    // Determine if this insight should be updated based on the response content
                    switch (tab.id) {
                        case 'story_so_far':
                            if (extractedInfo.story) {
                                newContent = `ðŸ“– **Story Update from Query**\n\n**Your Question:** ${userQuery}\n\n**New Information:** ${extractedInfo.story}\n\n---\n\n${insight.content}`;
                                shouldUpdate = true;
                            }
                            break;
                            
                        case 'current_objectives':
                            if (extractedInfo.objectives) {
                                newContent = `ðŸŽ¯ **Objective Update from Query**\n\n**Your Question:** ${userQuery}\n\n**New Information:** ${extractedInfo.objectives}\n\n---\n\n${insight.content}`;
                                shouldUpdate = true;
                            }
                            break;
                            
                        case 'character_insights':
                            if (extractedInfo.characters) {
                                newContent = `ðŸ‘¤ **Character Update from Query**\n\n**Your Question:** ${userQuery}\n\n**New Information:** ${extractedInfo.characters}\n\n---\n\n${insight.content}`;
                                shouldUpdate = true;
                            }
                            break;
                            
                        case 'world_lore':
                            if (extractedInfo.lore) {
                                newContent = `ðŸŒ **Lore Update from Query**\n\n**Your Question:** ${userQuery}\n\n**New Information:** ${extractedInfo.lore}\n\n---\n\n${insight.content}`;
                                shouldUpdate = true;
                            }
                            break;
                            
                        case 'gameplay_tips':
                            if (extractedInfo.tips) {
                                newContent = `ðŸ’¡ **Tips Update from Query**\n\n**Your Question:** ${userQuery}\n\n**New Information:** ${extractedInfo.tips}\n\n---\n\n${insight.content}`;
                                shouldUpdate = true;
                            }
                            break;
                            
                        case 'inventory_analysis':
                            if (extractedInfo.inventory) {
                                newContent = `ðŸŽ’ **Inventory Update from Query**\n\n**Your Question:** ${userQuery}\n\n**New Information:** ${extractedInfo.inventory}\n\n---\n\n${insight.content}`;
                                shouldUpdate = true;
                            }
                            break;
                    }
                    
                    // Update the insight if new content was found
                    if (shouldUpdate && newContent) {
                        updateConversation(conversationId, convo => {
                            if (!convo.insights?.[tab.id]) return convo;
                            
                            return {
                                ...convo,
                                insights: {
                                    ...convo.insights,
                                    [tab.id]: {
                                        ...convo.insights[tab.id],
                                        content: newContent,
                                        status: 'loaded',
                                        isNew: true,
                                        lastUpdated: Date.now(),
                                        lastUpdatedFromQuery: userQuery
                                    }
                                }
                            };
                        });
                        
                        console.log(`âœ… Updated ${tab.title} with new information from user query`);
                    }
                }
            }
            
            // Update progress if it changed
            const currentProgress = conversations[conversationId]?.progress || 0;
            if (Math.abs(progress - currentProgress) >= 5) { // Lower threshold for more responsive updates
                updateConversation(conversationId, convo => ({
                    ...convo,
                    progress: progress
                }));
                console.log(`ðŸ“Š Progress updated to ${progress}% from user query`);
            }
            
        } catch (error) {
            console.error('Error updating insights on user query:', error);
        }
    }, [conversations, updateConversation]);

    // Helper functions to extract specific information from AI responses
    const extractStoryInfo = (response: string): string | null => {
        const storyMatch = response.match(/(?:story|plot|narrative)[:\s]*([^.!?]+[.!?])/i);
        return storyMatch ? storyMatch[1].trim() : null;
    };

    const extractObjectiveInfo = (response: string): string | null => {
        const objectiveMatch = response.match(/(?:objective|quest|goal|mission)[:\s]*([^.!?]+[.!?])/i);
        return objectiveMatch ? objectiveMatch[1].trim() : null;
    };

    const extractCharacterInfo = (response: string): string | null => {
        const characterMatch = response.match(/(?:character|npc|companion)[:\s]*([^.!?]+[.!?])/i);
        return characterMatch ? characterMatch[1].trim() : null;
    };

    const extractLoreInfo = (response: string): string | null => {
        const loreMatch = response.match(/(?:lore|world|history|background)[:\s]*([^.!?]+[.!?])/i);
        return loreMatch ? loreMatch[1].trim() : null;
    };

    const extractTipInfo = (response: string): string | null => {
        const tipMatch = response.match(/(?:tip|hint|strategy|advice)[:\s]*([^.!?]+[.!?])/i);
        return tipMatch ? tipMatch[1].trim() : null;
    };

    const extractInventoryInfo = (response: string): string | null => {
        const inventoryMatch = response.match(/(?:inventory|item|equipment|gear)[:\s]*([^.!?]+[.!?])/i);
        return inventoryMatch ? inventoryMatch[1].trim() : null;
    };

    // Helper function to extract the most relevant game help content for hands-free mode
    const extractGameHelpFromResponse = (response: string, userQuery: string): string => {
        // First, try to find the most relevant section based on the user's query
        const queryLower = userQuery.toLowerCase();
        
        // Look for direct answers to common game help queries
        if (queryLower.includes('how') || queryLower.includes('what') || queryLower.includes('where') || queryLower.includes('why')) {
            // Try to find the first complete sentence that seems to answer the question
            const sentences = response.split(/[.!?]+/).filter(s => s.trim().length > 10);
            for (const sentence of sentences) {
                const sentenceLower = sentence.toLowerCase();
                if (sentenceLower.includes('you can') || sentenceLower.includes('try') || sentenceLower.includes('look for') || 
                    sentenceLower.includes('check') || sentenceLower.includes('find') || sentenceLower.includes('go to')) {
                    return sentence.trim() + '.';
                }
            }
        }
        
        // Look for hint-like content
        const hintPatterns = [
            /(?:hint|tip|suggestion|advice)[:\s]*([^.!?]+[.!?])/i,
            /(?:you should|try to|look for|check|find|go to)[^.!?]*[.!?]/i,
            /(?:the key is|the solution is|you need to)[^.!?]*[.!?]/i
        ];
        
        for (const pattern of hintPatterns) {
            const match = response.match(pattern);
            if (match) {
                return match[0].trim();
            }
        }
        
        // Fallback: return the first meaningful paragraph (first 2-3 sentences)
        const paragraphs = response.split('\n\n').filter(p => p.trim().length > 20);
        if (paragraphs.length > 0) {
            const firstParagraph = paragraphs[0];
            const sentences = firstParagraph.split(/[.!?]+/).filter(s => s.trim().length > 10);
            if (sentences.length >= 2) {
                return sentences.slice(0, 2).join('. ').trim() + '.';
            } else if (sentences.length === 1) {
                return sentences[0].trim() + '.';
            }
        }
        
        // Last resort: return the first 200 characters of the response
        return response.substring(0, 200).trim() + (response.length > 200 ? '...' : '');
    };

    // Tab management command handler
    const handleTabManagementCommand = useCallback(async (text: string) => {
        const command = tabManagementService.parseTabCommand(text);
        if (!command) return null;

        try {
            const currentConversation = conversations[activeConversationId];
            if (!currentConversation?.insights) return null;

            const currentTabs = Object.values(currentConversation.insights).map(insight => ({
                id: insight.id,
                title: insight.title,
                content: insight.content
            }));

            const result = await tabManagementService.executeTabCommand(
                command,
                currentTabs,
                (updatedTabs) => {
                    // Update the conversation with new tab structure
                    const updatedInsights: Record<string, Insight> = {};
                    updatedTabs.forEach((tab, index) => {
                        updatedInsights[tab.id] = {
                            id: tab.id,
                            title: tab.title,
                            content: tab.content,
                            status: 'loaded' as any,
                            lastUpdated: Date.now()
                        };
                    });

                    updateConversation(activeConversationId, convo => ({
                        ...convo,
                        insights: updatedInsights,
                        insightsOrder: updatedTabs.map(t => t.id)
                    }));
                }
            );

            return result;
        } catch (error) {
            console.error('Error executing tab management command:', error);
            return {
                success: false,
                message: 'âŒ Error executing command',
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }, [activeConversationId, conversations, updateConversation]);

    return {
        conversations,
        conversationsOrder,
        reorderConversations,
        activeConversationId,
        activeConversation,
        loadingMessages,
        isCooldownActive,
        sendMessage,
        stopMessage,
        resetConversations,
        addSystemMessage,
        restoreHistory,
        switchConversation,
        fetchInsightContent,
        markInsightAsRead,
        saveConversationsToLocalStorage,
        pinConversation,
        deleteConversation,
        deleteInsight,
        reorderInsights,
        pendingModification,
        setPendingModification,
        overwriteInsight,
        createNewInsight,
        updateMessageFeedback,
        updateInsightFeedback,
        retryMessage,
        updateConversation, // ðŸ”¥ ADDED: For enhanced insights integration
        triggerIntelligentInsightUpdate, // ðŸ”¥ NEW: Intelligent insight updates based on AI response context

        updateInsightsForProgress,
        updateInsightsOnUserQuery, // ðŸ”¥ NEW: Consolidated insight updates on user queries
        handleTabManagementCommand,
    };
};

use connection


import { useState, useCallback, useEffect, useRef } from 'react';
import { ConnectionStatus } from '../services/types';
import { connect as wsConnect, disconnect as wsDisconnect, send as wsSend } from '../services/websocketService';

type MessageHandler = (data: any) => void;

export const useConnection = (onMessage: MessageHandler) => {
    const [status, setStatus] = useState<ConnectionStatus>(ConnectionStatus.DISCONNECTED);
    const [error, setError] = useState<string | null>(null);
    const [connectionCode, setConnectionCode] = useState<string | null>(() => {
        return localStorage.getItem('lastConnectionCode');
    });

    const [lastSuccessfulConnection, setLastSuccessfulConnection] = useState<number | null>(() => {
        const saved = localStorage.getItem('lastSuccessfulConnection');
        return saved ? parseInt(saved) : null;
    });

    const onMessageRef = useRef(onMessage);
    useEffect(() => {
        onMessageRef.current = onMessage;
    }, [onMessage]);

    const statusRef = useRef(status);
    useEffect(() => {
        statusRef.current = status;
    }, [status]);

    const connectionTimeoutRef = useRef<number | null>(null);
    const clearConnectionTimeout = () => {
        if (connectionTimeoutRef.current) {
            clearTimeout(connectionTimeoutRef.current);
            connectionTimeoutRef.current = null;
        }
    };

    const saveSuccessfulConnection = (code: string) => {
        localStorage.setItem('lastConnectionCode', code);
        localStorage.setItem('lastSuccessfulConnection', Date.now().toString());
        setLastSuccessfulConnection(Date.now());

    };

    const connect = useCallback((code: string) => {
        if (statusRef.current === ConnectionStatus.CONNECTING || statusRef.current === ConnectionStatus.CONNECTED) {
            return;
        }

        setStatus(ConnectionStatus.CONNECTING);
        setError(null);
        clearConnectionTimeout();

        connectionTimeoutRef.current = window.setTimeout(() => {
            if (statusRef.current === ConnectionStatus.CONNECTING) {
                console.log("Connection attempt timed out.");
                wsDisconnect(); // Close the WebSocket connection attempt
                setStatus(ConnectionStatus.ERROR);
                setError("Connection timed out. Please check your code and ensure the PC client is running.");
            }
        }, 10000); // 10 seconds

        wsConnect(
            code,
            () => { // onOpen - socket is open, but we wait for partner
                console.log(`WebSocket open. Waiting for partner on code ${code}.`);
                setConnectionCode(code);
                wsSend({ type: 'get_history' });
            },
            (data) => { // onMessage
                if (data.type === 'partner_connected') {
                    console.log("âœ… Partner PC client has connected!");
                    if (statusRef.current === ConnectionStatus.CONNECTING) {
                        clearConnectionTimeout();
                        setStatus(ConnectionStatus.CONNECTED);
                        setError(null);

                        saveSuccessfulConnection(code);
                    }
                } else if (data.type === 'partner_disconnected') {
                    console.log("Partner PC client has disconnected.");
                    // Don't change status here - just log it
                } else if (data.type === 'waiting_for_client') {
                    console.log("Waiting for PC client to connect...");
                    // This is a status update from the relay server
                } else if (data.type === 'screenshot_batch') {
                    console.log("ðŸ“¸ Screenshot batch received from enhanced connector");
                    // Let the main handler process this
                } else if (data.type === 'screenshot') {
                    console.log("ðŸ“¸ Individual screenshot received from PC client");
                    console.log("ðŸ“¸ Screenshot details:", {
                        index: data.index,
                        total: data.total,
                        processImmediate: data.processImmediate,
                        timestamp: data.timestamp,
                        dataUrlLength: data.dataUrl?.length || 0
                    });
                    // Let the main handler process this
                } else if (data.type === 'connection_test') {
                    console.log("âœ… Connection test received from PC client");
                    // Let the main handler process this
                }
                
                // Always forward all messages to the main handler
                onMessageRef.current(data);
            },
            (err) => { // onError - This is usually called for unclean disconnects.
                clearConnectionTimeout();
                setStatus(ConnectionStatus.ERROR);
                setError(err);
            },
            () => { // onClose
                clearConnectionTimeout();
                // If an error has already been set (e.g., by timeout or onError), don't overwrite it.
                // Only set the generic error if we were connecting and no specific error was provided.
                if (statusRef.current === ConnectionStatus.CONNECTING) {
                    setStatus(ConnectionStatus.ERROR);
                    setError(prev => prev || "Connection failed. Please check the code and ensure the PC client is running.");
                } else if (statusRef.current !== ConnectionStatus.ERROR) {
                    setStatus(ConnectionStatus.DISCONNECTED);
                }
            }
        );
    }, []);

    const disconnect = useCallback(() => {
        clearConnectionTimeout();

        wsDisconnect();
        setStatus(ConnectionStatus.DISCONNECTED);
        setError(null);
        setConnectionCode(null);

        localStorage.removeItem('lastConnectionCode');
        localStorage.removeItem('lastSuccessfulConnection');
    }, []);

    const forceReconnect = useCallback(() => {
        const savedCode = localStorage.getItem('lastConnectionCode');
        if (savedCode) {
            disconnect();
            // Small delay to ensure cleanup is complete
            setTimeout(() => {
                connect(savedCode);
            }, 100);
        }
    }, [connect, disconnect]);

    // Auto-reconnect when app starts or comes into focus
    useEffect(() => {
        const savedCode = localStorage.getItem('lastConnectionCode');
        
        // Only auto-reconnect if we're not already connected and have a saved code
        if (savedCode && status === ConnectionStatus.DISCONNECTED) {
            console.log("ðŸ”— Auto-connecting with saved code on app start:", savedCode);
            // Small delay to ensure app is fully initialized
            const autoConnectDelay = setTimeout(() => {
                // Double-check we're still disconnected before attempting connection
                if (status === ConnectionStatus.DISCONNECTED) {
                    connect(savedCode);
                }
            }, 1000);
            
            return () => clearTimeout(autoConnectDelay);
        }
    }, [connect, status]);

    // Auto-reconnect when app comes into focus
    useEffect(() => {
        const handleVisibilityChange = () => {
            // Only reconnect if we're not already connected and have a saved code
            if (!document.hidden && status === ConnectionStatus.DISCONNECTED) {
                const savedCode = localStorage.getItem('lastConnectionCode');
                if (savedCode) {
                    console.log("ðŸ”— Auto-reconnecting on app focus:", savedCode);
                    // Double-check we're still disconnected before attempting connection
                    if (status === ConnectionStatus.DISCONNECTED) {
                        connect(savedCode);
                    }
                }
            }
        };

        const handleFocus = () => {
            // Only reconnect if we're not already connected and have a saved code
            if (status === ConnectionStatus.DISCONNECTED) {
                const savedCode = localStorage.getItem('lastConnectionCode');
                if (savedCode) {
                    console.log("ðŸ”— Auto-reconnecting on window focus:", savedCode);
                    // Double-check we're still disconnected before attempting connection
                    if (status === ConnectionStatus.DISCONNECTED) {
                        connect(savedCode);
                    }
                }
            }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('focus', handleFocus);

        return () => {
            document.removeEventListener('visibilitychange', handleVisibilityChange);
            window.removeEventListener('focus', handleFocus);
        };
    }, [connect, status]);

    const send = useCallback((data: object) => {
        wsSend(data);
    }, []);

    return { 
        status, 
        error, 
        connect, 
        disconnect, 
        connectionCode, 
        send,
        lastSuccessfulConnection,
        forceReconnect
    };
};