class K{static detectEnvironment(){var e;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((e=navigator.userAgent)===null||e===void 0)&&e.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const t=process.versions;if(t&&t.node){const n=t.node,i=parseInt(n.replace(/^v/,"").split(".")[0]);return i>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${i} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${i} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const e=this.detectEnvironment();if(e.constructor)return e.constructor;let t=e.error||"WebSocket not supported in this environment.";throw e.workaround&&(t+=`

Suggested solution: ${e.workaround}`),new Error(t)}static createWebSocket(e,t){const n=this.getWebSocketConstructor();return new n(e,t)}static isWebSocketSupported(){try{const e=this.detectEnvironment();return e.type==="native"||e.type==="ws"}catch{return!1}}}const q="2.81.1",Y=`realtime-js/${q}`,M="1.0.0",X="2.0.0",$=M,B=1e4,Z=1e3,Q=100;var R;(function(s){s[s.connecting=0]="connecting",s[s.open=1]="open",s[s.closing=2]="closing",s[s.closed=3]="closed"})(R||(R={}));var m;(function(s){s.closed="closed",s.errored="errored",s.joined="joined",s.joining="joining",s.leaving="leaving"})(m||(m={}));var b;(function(s){s.close="phx_close",s.error="phx_error",s.join="phx_join",s.reply="phx_reply",s.leave="phx_leave",s.access_token="access_token"})(b||(b={}));var N;(function(s){s.websocket="websocket"})(N||(N={}));var S;(function(s){s.Connecting="connecting",s.Open="open",s.Closing="closing",s.Closed="closed"})(S||(S={}));class ee{constructor(){this.HEADER_LENGTH=1,this.META_LENGTH=4,this.USER_BROADCAST_PUSH_META_LENGTH=5,this.KINDS={push:0,reply:1,broadcast:2,userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST="broadcast"}encode(e,t){if(this._isArrayBuffer(e.payload))return t(this._binaryEncodePush(e));if(e.event===this.BROADCAST&&!(e.payload instanceof ArrayBuffer)&&typeof e.payload.event=="string")return t(this._binaryEncodeUserBroadcastPush(e));let n=[e.join_ref,e.ref,e.topic,e.event,e.payload];return t(JSON.stringify(n))}_binaryEncodePush(e){const{join_ref:t,ref:n,event:i,topic:r,payload:o}=e,c=this.META_LENGTH+t.length+n.length+r.length+i.length,a=new ArrayBuffer(this.HEADER_LENGTH+c);let h=new DataView(a),f=0;h.setUint8(f++,this.KINDS.push),h.setUint8(f++,t.length),h.setUint8(f++,n.length),h.setUint8(f++,r.length),h.setUint8(f++,i.length),Array.from(t,u=>h.setUint8(f++,u.charCodeAt(0))),Array.from(n,u=>h.setUint8(f++,u.charCodeAt(0))),Array.from(r,u=>h.setUint8(f++,u.charCodeAt(0))),Array.from(i,u=>h.setUint8(f++,u.charCodeAt(0)));var p=new Uint8Array(a.byteLength+o.byteLength);return p.set(new Uint8Array(a),0),p.set(new Uint8Array(o),a.byteLength),p.buffer}_binaryEncodeUserBroadcastPush(e){var t;return this._isArrayBuffer((t=e.payload)===null||t===void 0?void 0:t.payload)?this._encodeBinaryUserBroadcastPush(e):this._encodeJsonUserBroadcastPush(e)}_encodeBinaryUserBroadcastPush(e){var t,n;const{join_ref:i,ref:r,topic:o}=e,c=e.payload.event,a=(n=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&n!==void 0?n:new ArrayBuffer(0),h=this.USER_BROADCAST_PUSH_META_LENGTH+i.length+r.length+o.length+c.length,f=new ArrayBuffer(this.HEADER_LENGTH+h);let p=new DataView(f),u=0;p.setUint8(u++,this.KINDS.userBroadcastPush),p.setUint8(u++,i.length),p.setUint8(u++,r.length),p.setUint8(u++,o.length),p.setUint8(u++,c.length),p.setUint8(u++,this.BINARY_ENCODING),Array.from(i,d=>p.setUint8(u++,d.charCodeAt(0))),Array.from(r,d=>p.setUint8(u++,d.charCodeAt(0))),Array.from(o,d=>p.setUint8(u++,d.charCodeAt(0))),Array.from(c,d=>p.setUint8(u++,d.charCodeAt(0)));var l=new Uint8Array(f.byteLength+a.byteLength);return l.set(new Uint8Array(f),0),l.set(new Uint8Array(a),f.byteLength),l.buffer}_encodeJsonUserBroadcastPush(e){var t,n;const{join_ref:i,ref:r,topic:o}=e,c=e.payload.event,a=(n=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&n!==void 0?n:{},f=new TextEncoder().encode(JSON.stringify(a)).buffer,p=this.USER_BROADCAST_PUSH_META_LENGTH+i.length+r.length+o.length+c.length,u=new ArrayBuffer(this.HEADER_LENGTH+p);let l=new DataView(u),d=0;l.setUint8(d++,this.KINDS.userBroadcastPush),l.setUint8(d++,i.length),l.setUint8(d++,r.length),l.setUint8(d++,o.length),l.setUint8(d++,c.length),l.setUint8(d++,this.JSON_ENCODING),Array.from(i,v=>l.setUint8(d++,v.charCodeAt(0))),Array.from(r,v=>l.setUint8(d++,v.charCodeAt(0))),Array.from(o,v=>l.setUint8(d++,v.charCodeAt(0))),Array.from(c,v=>l.setUint8(d++,v.charCodeAt(0)));var _=new Uint8Array(u.byteLength+f.byteLength);return _.set(new Uint8Array(u),0),_.set(new Uint8Array(f),u.byteLength),_.buffer}decode(e,t){if(this._isArrayBuffer(e)){let n=this._binaryDecode(e);return t(n)}if(typeof e=="string"){const n=JSON.parse(e),[i,r,o,c,a]=n;return t({join_ref:i,ref:r,topic:o,event:c,payload:a})}return t({})}_binaryDecode(e){const t=new DataView(e),n=t.getUint8(0),i=new TextDecoder;switch(n){case this.KINDS.push:return this._decodePush(e,t,i);case this.KINDS.reply:return this._decodeReply(e,t,i);case this.KINDS.broadcast:return this._decodeBroadcast(e,t,i);case this.KINDS.userBroadcast:return this._decodeUserBroadcast(e,t,i)}}_decodePush(e,t,n){const i=t.getUint8(1),r=t.getUint8(2),o=t.getUint8(3);let c=this.HEADER_LENGTH+this.META_LENGTH-1;const a=n.decode(e.slice(c,c+i));c=c+i;const h=n.decode(e.slice(c,c+r));c=c+r;const f=n.decode(e.slice(c,c+o));c=c+o;const p=JSON.parse(n.decode(e.slice(c,e.byteLength)));return{join_ref:a,ref:null,topic:h,event:f,payload:p}}_decodeReply(e,t,n){const i=t.getUint8(1),r=t.getUint8(2),o=t.getUint8(3),c=t.getUint8(4);let a=this.HEADER_LENGTH+this.META_LENGTH;const h=n.decode(e.slice(a,a+i));a=a+i;const f=n.decode(e.slice(a,a+r));a=a+r;const p=n.decode(e.slice(a,a+o));a=a+o;const u=n.decode(e.slice(a,a+c));a=a+c;const l=JSON.parse(n.decode(e.slice(a,e.byteLength))),d={status:u,response:l};return{join_ref:h,ref:f,topic:p,event:b.reply,payload:d}}_decodeBroadcast(e,t,n){const i=t.getUint8(1),r=t.getUint8(2);let o=this.HEADER_LENGTH+2;const c=n.decode(e.slice(o,o+i));o=o+i;const a=n.decode(e.slice(o,o+r));o=o+r;const h=JSON.parse(n.decode(e.slice(o,e.byteLength)));return{join_ref:null,ref:null,topic:c,event:a,payload:h}}_decodeUserBroadcast(e,t,n){const i=t.getUint8(1),r=t.getUint8(2),o=t.getUint8(3),c=t.getUint8(4);let a=this.HEADER_LENGTH+4;const h=n.decode(e.slice(a,a+i));a=a+i;const f=n.decode(e.slice(a,a+r));a=a+r;const p=n.decode(e.slice(a,a+o));a=a+o;const u=e.slice(a,e.byteLength),l=c===this.JSON_ENCODING?JSON.parse(n.decode(u)):u,d={type:this.BROADCAST,event:f,payload:l};return o>0&&(d.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST,payload:d}}_isArrayBuffer(e){var t;return e instanceof ArrayBuffer||((t=e==null?void 0:e.constructor)===null||t===void 0?void 0:t.name)==="ArrayBuffer"}}class z{constructor(e,t){this.callback=e,this.timerCalc=t,this.timer=void 0,this.tries=0,this.callback=e,this.timerCalc=t}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var g;(function(s){s.abstime="abstime",s.bool="bool",s.date="date",s.daterange="daterange",s.float4="float4",s.float8="float8",s.int2="int2",s.int4="int4",s.int4range="int4range",s.int8="int8",s.int8range="int8range",s.json="json",s.jsonb="jsonb",s.money="money",s.numeric="numeric",s.oid="oid",s.reltime="reltime",s.text="text",s.time="time",s.timestamp="timestamp",s.timestamptz="timestamptz",s.timetz="timetz",s.tsrange="tsrange",s.tstzrange="tstzrange"})(g||(g={}));const W=(s,e,t={})=>{var n;const i=(n=t.skipTypes)!==null&&n!==void 0?n:[];return e?Object.keys(e).reduce((r,o)=>(r[o]=te(o,s,e,i),r),{}):{}},te=(s,e,t,n)=>{const i=e.find(c=>c.name===s),r=i==null?void 0:i.type,o=t[s];return r&&!n.includes(r)?x(r,o):P(o)},x=(s,e)=>{if(s.charAt(0)==="_"){const t=s.slice(1,s.length);return re(e,t)}switch(s){case g.bool:return ne(e);case g.float4:case g.float8:case g.int2:case g.int4:case g.int8:case g.numeric:case g.oid:return ie(e);case g.json:case g.jsonb:return se(e);case g.timestamp:return oe(e);case g.abstime:case g.date:case g.daterange:case g.int4range:case g.int8range:case g.money:case g.reltime:case g.text:case g.time:case g.timestamptz:case g.timetz:case g.tsrange:case g.tstzrange:return P(e);default:return P(e)}},P=s=>s,ne=s=>{switch(s){case"t":return!0;case"f":return!1;default:return s}},ie=s=>{if(typeof s=="string"){const e=parseFloat(s);if(!Number.isNaN(e))return e}return s},se=s=>{if(typeof s=="string")try{return JSON.parse(s)}catch(e){return console.log(`JSON parse error: ${e}`),s}return s},re=(s,e)=>{if(typeof s!="string")return s;const t=s.length-1,n=s[t];if(s[0]==="{"&&n==="}"){let r;const o=s.slice(1,t);try{r=JSON.parse("["+o+"]")}catch{r=o?o.split(","):[]}return r.map(c=>x(e,c))}return s},oe=s=>typeof s=="string"?s.replace(" ","T"):s,V=s=>{const e=new URL(s);return e.protocol=e.protocol.replace(/^ws/i,"http"),e.pathname=e.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),e.pathname===""||e.pathname==="/"?e.pathname="/api/broadcast":e.pathname=e.pathname+"/api/broadcast",e.href};class L{constructor(e,t,n={},i=B){this.channel=e,this.event=t,this.payload=n,this.timeout=i,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(e){this.timeout=e,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(e){this.payload=Object.assign(Object.assign({},this.payload),e)}receive(e,t){var n;return this._hasReceived(e)&&t((n=this.receivedResp)===null||n===void 0?void 0:n.response),this.recHooks.push({status:e,callback:t}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const e=t=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=t,this._matchReceive(t)};this.channel._on(this.refEvent,{},e),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(e,t){this.refEvent&&this.channel._trigger(this.refEvent,{status:e,response:t})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:e,response:t}){this.recHooks.filter(n=>n.status===e).forEach(n=>n.callback(t))}_hasReceived(e){return this.receivedResp&&this.receivedResp.status===e}}var I;(function(s){s.SYNC="sync",s.JOIN="join",s.LEAVE="leave"})(I||(I={}));class A{constructor(e,t){this.channel=e,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const n=(t==null?void 0:t.events)||{state:"presence_state",diff:"presence_diff"};this.channel._on(n.state,{},i=>{const{onJoin:r,onLeave:o,onSync:c}=this.caller;this.joinRef=this.channel._joinRef(),this.state=A.syncState(this.state,i,r,o),this.pendingDiffs.forEach(a=>{this.state=A.syncDiff(this.state,a,r,o)}),this.pendingDiffs=[],c()}),this.channel._on(n.diff,{},i=>{const{onJoin:r,onLeave:o,onSync:c}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(i):(this.state=A.syncDiff(this.state,i,r,o),c())}),this.onJoin((i,r,o)=>{this.channel._trigger("presence",{event:"join",key:i,currentPresences:r,newPresences:o})}),this.onLeave((i,r,o)=>{this.channel._trigger("presence",{event:"leave",key:i,currentPresences:r,leftPresences:o})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(e,t,n,i){const r=this.cloneDeep(e),o=this.transformState(t),c={},a={};return this.map(r,(h,f)=>{o[h]||(a[h]=f)}),this.map(o,(h,f)=>{const p=r[h];if(p){const u=f.map(v=>v.presence_ref),l=p.map(v=>v.presence_ref),d=f.filter(v=>l.indexOf(v.presence_ref)<0),_=p.filter(v=>u.indexOf(v.presence_ref)<0);d.length>0&&(c[h]=d),_.length>0&&(a[h]=_)}else c[h]=f}),this.syncDiff(r,{joins:c,leaves:a},n,i)}static syncDiff(e,t,n,i){const{joins:r,leaves:o}={joins:this.transformState(t.joins),leaves:this.transformState(t.leaves)};return n||(n=()=>{}),i||(i=()=>{}),this.map(r,(c,a)=>{var h;const f=(h=e[c])!==null&&h!==void 0?h:[];if(e[c]=this.cloneDeep(a),f.length>0){const p=e[c].map(l=>l.presence_ref),u=f.filter(l=>p.indexOf(l.presence_ref)<0);e[c].unshift(...u)}n(c,f,a)}),this.map(o,(c,a)=>{let h=e[c];if(!h)return;const f=a.map(p=>p.presence_ref);h=h.filter(p=>f.indexOf(p.presence_ref)<0),e[c]=h,i(c,h,a),h.length===0&&delete e[c]}),e}static map(e,t){return Object.getOwnPropertyNames(e).map(n=>t(n,e[n]))}static transformState(e){return e=this.cloneDeep(e),Object.getOwnPropertyNames(e).reduce((t,n)=>{const i=e[n];return"metas"in i?t[n]=i.metas.map(r=>(r.presence_ref=r.phx_ref,delete r.phx_ref,delete r.phx_ref_prev,r)):t[n]=i,t},{})}static cloneDeep(e){return JSON.parse(JSON.stringify(e))}onJoin(e){this.caller.onJoin=e}onLeave(e){this.caller.onLeave=e}onSync(e){this.caller.onSync=e}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var J;(function(s){s.ALL="*",s.INSERT="INSERT",s.UPDATE="UPDATE",s.DELETE="DELETE"})(J||(J={}));var U;(function(s){s.BROADCAST="broadcast",s.PRESENCE="presence",s.POSTGRES_CHANGES="postgres_changes",s.SYSTEM="system"})(U||(U={}));var k;(function(s){s.SUBSCRIBED="SUBSCRIBED",s.TIMED_OUT="TIMED_OUT",s.CLOSED="CLOSED",s.CHANNEL_ERROR="CHANNEL_ERROR"})(k||(k={}));class H{constructor(e,t={config:{}},n){var i,r;if(this.topic=e,this.params=t,this.socket=n,this.bindings={},this.state=m.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=e.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},t.config),this.timeout=this.socket.timeout,this.joinPush=new L(this,b.join,this.params,this.timeout),this.rejoinTimer=new z(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=m.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=m.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=m.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=m.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=m.errored,this.rejoinTimer.scheduleTimeout())}),this._on(b.reply,{},(o,c)=>{this._trigger(this._replyEventName(c),o)}),this.presence=new A(this),this.broadcastEndpointURL=V(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((r=(i=this.params.config)===null||i===void 0?void 0:i.broadcast)===null||r===void 0)&&r.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(e,t=this.timeout){var n,i,r;if(this.socket.isConnected()||this.socket.connect(),this.state==m.closed){const{config:{broadcast:o,presence:c,private:a}}=this.params,h=(i=(n=this.bindings.postgres_changes)===null||n===void 0?void 0:n.map(l=>l.filter))!==null&&i!==void 0?i:[],f=!!this.bindings[U.PRESENCE]&&this.bindings[U.PRESENCE].length>0||((r=this.params.config.presence)===null||r===void 0?void 0:r.enabled)===!0,p={},u={broadcast:o,presence:Object.assign(Object.assign({},c),{enabled:f}),postgres_changes:h,private:a};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(l=>e==null?void 0:e(k.CHANNEL_ERROR,l)),this._onClose(()=>e==null?void 0:e(k.CLOSED)),this.updateJoinPayload(Object.assign({config:u},p)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",async({postgres_changes:l})=>{var d;if(this.socket.setAuth(),l===void 0){e==null||e(k.SUBSCRIBED);return}else{const _=this.bindings.postgres_changes,v=(d=_==null?void 0:_.length)!==null&&d!==void 0?d:0,w=[];for(let y=0;y<v;y++){const E=_[y],{filter:{event:C,schema:T,table:G,filter:F}}=E,j=l&&l[y];if(j&&j.event===C&&j.schema===T&&j.table===G&&j.filter===F)w.push(Object.assign(Object.assign({},E),{id:j.id}));else{this.unsubscribe(),this.state=m.errored,e==null||e(k.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=w,e&&e(k.SUBSCRIBED);return}}).receive("error",l=>{this.state=m.errored,e==null||e(k.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(l).join(", ")||"error")))}).receive("timeout",()=>{e==null||e(k.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(e,t={}){return await this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)}async untrack(e={}){return await this.send({type:"presence",event:"untrack"},e)}on(e,t,n){return this.state===m.joined&&e===U.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(()=>this.subscribe())),this._on(e,t,n)}async httpSend(e,t,n={}){var i;const r=this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"";if(t==null)return Promise.reject("Payload is required for httpSend()");const o={method:"POST",headers:{Authorization:r,apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event:e,payload:t,private:this.private}]})},c=await this._fetchWithTimeout(this.broadcastEndpointURL,o,(i=n.timeout)!==null&&i!==void 0?i:this.timeout);if(c.status===202)return{success:!0};let a=c.statusText;try{const h=await c.json();a=h.error||h.message||a}catch{}return Promise.reject(new Error(a))}async send(e,t={}){var n,i;if(!this._canPush()&&e.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:r,payload:o}=e,a={method:"POST",headers:{Authorization:this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"",apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event:r,payload:o,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,a,(n=t.timeout)!==null&&n!==void 0?n:this.timeout);return await((i=h.body)===null||i===void 0?void 0:i.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(r=>{var o,c,a;const h=this._push(e.type,e,t.timeout||this.timeout);e.type==="broadcast"&&!(!((a=(c=(o=this.params)===null||o===void 0?void 0:o.config)===null||c===void 0?void 0:c.broadcast)===null||a===void 0)&&a.ack)&&r("ok"),h.receive("ok",()=>r("ok")),h.receive("error",()=>r("error")),h.receive("timeout",()=>r("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=m.leaving;const t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(b.close,"leave",this._joinRef())};this.joinPush.destroy();let n=null;return new Promise(i=>{n=new L(this,b.leave,{},e),n.receive("ok",()=>{t(),i("ok")}).receive("timeout",()=>{t(),i("timed out")}).receive("error",()=>{i("error")}),n.send(),this._canPush()||n.trigger("ok",{})}).finally(()=>{n==null||n.destroy()})}teardown(){this.pushBuffer.forEach(e=>e.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=m.closed,this.bindings={}}async _fetchWithTimeout(e,t,n){const i=new AbortController,r=setTimeout(()=>i.abort(),n),o=await this.socket.fetch(e,Object.assign(Object.assign({},t),{signal:i.signal}));return clearTimeout(r),o}_push(e,t,n=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let i=new L(this,e,t,n);return this._canPush()?i.send():this._addToPushBuffer(i),i}_addToPushBuffer(e){if(e.startTimeout(),this.pushBuffer.push(e),this.pushBuffer.length>Q){const t=this.pushBuffer.shift();t&&(t.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${t.event}`,t.payload))}}_onMessage(e,t,n){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,n){var i,r;const o=e.toLocaleLowerCase(),{close:c,error:a,leave:h,join:f}=b;if(n&&[c,a,h,f].indexOf(o)>=0&&n!==this._joinRef())return;let u=this._onMessage(o,t,n);if(t&&!u)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(i=this.bindings.postgres_changes)===null||i===void 0||i.filter(l=>{var d,_,v;return((d=l.filter)===null||d===void 0?void 0:d.event)==="*"||((v=(_=l.filter)===null||_===void 0?void 0:_.event)===null||v===void 0?void 0:v.toLocaleLowerCase())===o}).map(l=>l.callback(u,n)):(r=this.bindings[o])===null||r===void 0||r.filter(l=>{var d,_,v,w,y,E;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in l){const C=l.id,T=(d=l.filter)===null||d===void 0?void 0:d.event;return C&&((_=t.ids)===null||_===void 0?void 0:_.includes(C))&&(T==="*"||(T==null?void 0:T.toLocaleLowerCase())===((v=t.data)===null||v===void 0?void 0:v.type.toLocaleLowerCase()))}else{const C=(y=(w=l==null?void 0:l.filter)===null||w===void 0?void 0:w.event)===null||y===void 0?void 0:y.toLocaleLowerCase();return C==="*"||C===((E=t==null?void 0:t.event)===null||E===void 0?void 0:E.toLocaleLowerCase())}else return l.type.toLocaleLowerCase()===o}).map(l=>{if(typeof u=="object"&&"ids"in u){const d=u.data,{schema:_,table:v,commit_timestamp:w,type:y,errors:E}=d;u=Object.assign(Object.assign({},{schema:_,table:v,commit_timestamp:w,eventType:y,new:{},old:{},errors:E}),this._getPayloadRecords(d))}l.callback(u,n)})}_isClosed(){return this.state===m.closed}_isJoined(){return this.state===m.joined}_isJoining(){return this.state===m.joining}_isLeaving(){return this.state===m.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,n){const i=e.toLocaleLowerCase(),r={type:i,filter:t,callback:n};return this.bindings[i]?this.bindings[i].push(r):this.bindings[i]=[r],this}_off(e,t){const n=e.toLocaleLowerCase();return this.bindings[n]&&(this.bindings[n]=this.bindings[n].filter(i=>{var r;return!(((r=i.type)===null||r===void 0?void 0:r.toLocaleLowerCase())===n&&H.isEqual(i.filter,t))})),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const n in e)if(e[n]!==t[n])return!1;return!0}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(b.close,{},e)}_onError(e){this._on(b.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=m.joining,this.joinPush.resend(e))}_getPayloadRecords(e){const t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=W(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=W(e.columns,e.old_record)),t}}const D=()=>{},O={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},ae=[1e3,2e3,5e3,1e4],ce=1e4,he=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class le{constructor(e,t){var n;if(this.accessTokenValue=null,this.apiKey=null,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=B,this.transport=null,this.heartbeatIntervalMs=O.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=D,this.ref=0,this.reconnectTimer=null,this.vsn=$,this.logger=D,this.conn=null,this.sendBuffer=[],this.serializer=new ee,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=i=>i?(...r)=>i(...r):(...r)=>fetch(...r),!(!((n=t==null?void 0:t.params)===null||n===void 0)&&n.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=t.params.apikey,this.endPoint=`${e}/${N.websocket}`,this.httpEndpoint=V(e),this._initializeOptions(t),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(t==null?void 0:t.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=K.createWebSocket(this.endpointURL())}catch(e){this._setConnectionState("disconnected");const t=e.message;throw t.includes("Node.js")?new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${t}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(e,t){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const n=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(n),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(e?this.conn.close(e,t??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,n){this.logger(e,t,n)}connectionState(){switch(this.conn&&this.conn.readyState){case R.connecting:return S.Connecting;case R.open:return S.Open;case R.closing:return S.Closing;default:return S.Closed}}isConnected(){return this.connectionState()===S.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(e,t={config:{}}){const n=`realtime:${e}`,i=this.getChannels().find(r=>r.topic===n);if(i)return i;{const r=new H(`realtime:${e}`,t,this);return this.channels.push(r),r}}push(e){const{topic:t,event:n,payload:i,ref:r}=e,o=()=>{this.encode(e,c=>{var a;(a=this.conn)===null||a===void 0||a.send(c)})};this.log("push",`${t} ${n} (${r})`,i),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(e=null){this._authPromise=this._performAuth(e);try{await this._authPromise}finally{this._authPromise=null}}async sendHeartbeat(){var e;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(t){this.log("error","error in heartbeat callback",t)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(t){this.log("error","error in heartbeat callback",t)}this._wasManualDisconnect=!1,(e=this.conn)===null||e===void 0||e.close(Z,"heartbeat timeout"),setTimeout(()=>{var t;this.isConnected()||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout()},O.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(t){this.log("error","error in heartbeat callback",t)}this._setAuthSafely("heartbeat")}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(n=>n.topic===e&&(n._isJoined()||n._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}_onConnMessage(e){this.decode(e.data,t=>{if(t.topic==="phoenix"&&t.event==="phx_reply")try{this.heartbeatCallback(t.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}t.ref&&t.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:n,event:i,payload:r,ref:o}=t,c=o?`(${o})`:"",a=r.status||"";this.log("receive",`${a} ${n} ${i} ${c}`.trim(),r),this.channels.filter(h=>h._isMember(n)).forEach(h=>h._trigger(i,r,o)),this._triggerStateCallbacks("message",t)})}_clearTimer(e){var t;e==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):e==="reconnect"&&((t=this.reconnectTimer)===null||t===void 0||t.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e))}_teardownConnection(){if(this.conn){if(this.conn.readyState===R.open||this.conn.readyState===R.connecting)try{this.conn.close()}catch(e){this.log("error","Error closing connection",e)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this.channels.forEach(e=>e.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(t=>{this.log("error","error waiting for auth on connect",t),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this.workerRef.terminate()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_onConnClose(e){var t;this._setConnectionState("disconnected"),this.log("transport","close",e),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout(),this._triggerStateCallbacks("close",e)}_onConnError(e){this._setConnectionState("disconnected"),this.log("transport",`${e}`),this._triggerChanError(),this._triggerStateCallbacks("error",e)}_triggerChanError(){this.channels.forEach(e=>e._trigger(b.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const n=e.match(/\?/)?"&":"?",i=new URLSearchParams(t);return`${e}${n}${i}`}_workerObjectUrl(e){let t;if(e)t=e;else{const n=new Blob([he],{type:"application/javascript"});t=URL.createObjectURL(n)}return t}_setConnectionState(e,t=!1){this._connectionState=e,e==="connecting"?this._wasManualDisconnect=!1:e==="disconnecting"&&(this._wasManualDisconnect=t)}async _performAuth(e=null){let t;e?t=e:this.accessToken?t=await this.accessToken():t=this.accessTokenValue,this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(n=>{const i={access_token:t,version:Y};t&&n.updateJoinPayload(i),n.joinedOnce&&n._isJoined()&&n._push(b.access_token,{access_token:t})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(e="general"){this.setAuth().catch(t=>{this.log("error",`error setting auth in ${e}`,t)})}_triggerStateCallbacks(e,t){try{this.stateChangeCallbacks[e].forEach(n=>{try{n(t)}catch(i){this.log("error",`error in ${e} callback`,i)}})}catch(n){this.log("error",`error triggering ${e} callbacks`,n)}}_setupReconnectionTimer(){this.reconnectTimer=new z(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},O.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(e){var t,n,i,r,o,c,a,h,f,p,u,l;switch(this.transport=(t=e==null?void 0:e.transport)!==null&&t!==void 0?t:null,this.timeout=(n=e==null?void 0:e.timeout)!==null&&n!==void 0?n:B,this.heartbeatIntervalMs=(i=e==null?void 0:e.heartbeatIntervalMs)!==null&&i!==void 0?i:O.HEARTBEAT_INTERVAL,this.worker=(r=e==null?void 0:e.worker)!==null&&r!==void 0?r:!1,this.accessToken=(o=e==null?void 0:e.accessToken)!==null&&o!==void 0?o:null,this.heartbeatCallback=(c=e==null?void 0:e.heartbeatCallback)!==null&&c!==void 0?c:D,this.vsn=(a=e==null?void 0:e.vsn)!==null&&a!==void 0?a:$,e!=null&&e.params&&(this.params=e.params),e!=null&&e.logger&&(this.logger=e.logger),(e!=null&&e.logLevel||e!=null&&e.log_level)&&(this.logLevel=e.logLevel||e.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=e==null?void 0:e.reconnectAfterMs)!==null&&h!==void 0?h:(d=>ae[d-1]||ce),this.vsn){case M:this.encode=(f=e==null?void 0:e.encode)!==null&&f!==void 0?f:((d,_)=>_(JSON.stringify(d))),this.decode=(p=e==null?void 0:e.decode)!==null&&p!==void 0?p:((d,_)=>_(JSON.parse(d)));break;case X:this.encode=(u=e==null?void 0:e.encode)!==null&&u!==void 0?u:this.serializer.encode.bind(this.serializer),this.decode=(l=e==null?void 0:e.decode)!==null&&l!==void 0?l:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=e==null?void 0:e.workerUrl}}}export{le as R};
