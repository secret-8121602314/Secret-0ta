{"version":3,"file":"services-cbHiOPu1.js","sources":["../../src/services/cacheService.ts","../../src/services/errorService.ts","../../src/services/toastService.ts","../../src/services/onboardingService.ts","../../src/services/websocketService.ts","../../src/services/waitlistService.ts","../../src/services/storageService.ts","../../src/services/chatMemoryService.ts","../../src/services/otakonTags.ts","../../src/services/profileAwareTabService.ts","../../src/services/promptSystem.ts","../../src/services/errorRecoveryService.ts","../../src/services/characterImmersionService.ts","../../src/services/suggestedPromptsService.ts","../../src/services/sessionSummaryService.ts","../../src/services/subtabsService.ts","../../src/services/gameTabService.ts","../../src/services/userService.ts","../../src/services/tabManagementService.ts","../../src/services/ttsService.ts","../../src/services/messageRoutingService.ts","../../src/services/contextSummarizationService.ts"],"sourcesContent":["import { supabase } from '../lib/supabase';\n\n/**\n * Centralized cache service using Supabase for persistent caching\n * Replaces multiple cache instances across services with database-backed cache\n */\nclass CacheService {\n  private memoryCache = new Map<string, { value: any; expires: number }>();\n  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes\n  private readonly CACHE_TABLE = 'app_cache';\n  private readonly MAX_MEMORY_CACHE_SIZE = 100; // Prevent memory bloat\n  \n  // Request deduplication - prevent multiple simultaneous calls for the same key\n  private pendingRequests = new Map<string, Promise<any>>();\n\n  /**\n   * Set a value in both memory and Supabase cache\n   */\n  async set(key: string, value: any, ttl: number = this.DEFAULT_TTL, cacheType: string = 'general', userId?: string): Promise<void> {\n    const expires = Date.now() + ttl;\n    \n    // Store in memory cache for fast access\n    this.memoryCache.set(key, { value, expires });\n    console.log(`[CacheService] Stored in memory cache: ${key}`);\n    \n    // Store in Supabase for persistence\n    try {\n      console.log(`[CacheService] Storing in Supabase: ${key} (type: ${cacheType}, user: ${userId || 'none'})`);\n      const { error } = await supabase\n        .from(this.CACHE_TABLE)\n        .upsert({\n          key,\n          value: JSON.stringify(value),\n          expires_at: new Date(expires).toISOString(),\n          updated_at: new Date().toISOString(),\n          cache_type: cacheType,\n          user_id: userId || null,\n          size_bytes: JSON.stringify(value).length\n        });\n      \n      if (error) {\n        console.warn(`[CacheService] Failed to store cache in Supabase for key ${key}:`, error);\n      } else {\n        console.log(`[CacheService] Successfully stored in Supabase: ${key}`);\n      }\n    } catch (error) {\n      console.warn(`[CacheService] Supabase cache unavailable for key ${key}, using memory only:`, error);\n    }\n    \n    // Cleanup memory cache if it gets too large\n    if (this.memoryCache.size > this.MAX_MEMORY_CACHE_SIZE) {\n      this.cleanupMemoryCache();\n    }\n  }\n\n  /**\n   * Get a value from cache (memory first, then Supabase)\n   * Implements request deduplication to prevent multiple simultaneous calls\n   * @param key - Cache key\n   * @param memoryOnly - If true, only check memory cache (faster for real-time operations)\n   */\n  async get<T>(key: string, memoryOnly: boolean = false): Promise<T | null> {\n    // Check if there's already a pending request for this key\n    if (this.pendingRequests.has(key)) {\n      console.log(`[CacheService] Request deduplication: waiting for pending request for key: ${key}`);\n      return await this.pendingRequests.get(key) as T | null;\n    }\n    \n    // Try memory cache first\n    const memoryItem = this.memoryCache.get(key);\n    if (memoryItem && Date.now() <= memoryItem.expires) {\n      console.log(`[CacheService] Cache HIT (memory): ${key}`);\n      return memoryItem.value as T;\n    }\n    \n    // Remove expired memory item\n    if (memoryItem) {\n      this.memoryCache.delete(key);\n    }\n    \n    // If memory-only mode, return null instead of checking Supabase\n    if (memoryOnly) {\n      console.log(`[CacheService] Cache MISS (memory-only mode): ${key}`);\n      return null;\n    }\n    \n    // Create a promise for the Supabase request and store it\n    const supabaseRequest = this.fetchFromSupabase<T>(key);\n    this.pendingRequests.set(key, supabaseRequest);\n    \n    try {\n      const result = await supabaseRequest;\n      return result;\n    } finally {\n      // Clean up the pending request\n      this.pendingRequests.delete(key);\n    }\n  }\n  \n  /**\n   * Fetch data from Supabase cache\n   */\n  private async fetchFromSupabase<T>(key: string): Promise<T | null> {\n    try {\n      console.log(`[CacheService] Cache MISS (memory), trying Supabase: ${key}`);\n      const { data, error } = await supabase\n        .from(this.CACHE_TABLE)\n        .select('value, expires_at')\n        .eq('key', key)\n        .maybeSingle(); // Use maybeSingle() instead of single() to avoid 406 errors\n      \n      if (error) {\n        console.warn(`[CacheService] Supabase error for key ${key}:`, error);\n        return null;\n      }\n      \n      if (!data) {\n        console.log(`[CacheService] Cache MISS (Supabase): ${key}`);\n        return null;\n      }\n      \n      const expiresAt = new Date(data.expires_at).getTime();\n      if (Date.now() > expiresAt) {\n        console.log(`[CacheService] Cache EXPIRED (Supabase): ${key}`);\n        await this.delete(key);\n        return null;\n      }\n      \n      console.log(`[CacheService] Cache HIT (Supabase): ${key}`);\n      const value = JSON.parse(typeof data.value === 'string' ? data.value : '{}');\n      this.memoryCache.set(key, { value, expires: expiresAt });\n      return value as T;\n      \n    } catch (error) {\n      console.warn(`[CacheService] Error retrieving cache for key ${key}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Check if a key exists and is not expired\n   */\n  async has(key: string): Promise<boolean> {\n    const value = await this.get(key);\n    return value !== null;\n  }\n\n  /**\n   * Delete a specific key from both memory and Supabase\n   */\n  async delete(key: string): Promise<boolean> {\n    // Remove from memory\n    const memoryDeleted = this.memoryCache.delete(key);\n    \n    // Remove from Supabase\n    try {\n      const { error } = await supabase\n        .from(this.CACHE_TABLE)\n        .delete()\n        .eq('key', key);\n      \n      if (error) {\n        console.warn(`[CacheService] Failed to delete cache from Supabase:`, error);\n      }\n    } catch (error) {\n      console.warn(`[CacheService] Error deleting cache:`, error);\n    }\n    \n    return memoryDeleted;\n  }\n\n  /**\n   * Clear all cache entries from both memory and Supabase\n   */\n  async clear(): Promise<void> {\n    // Clear memory cache\n    this.memoryCache.clear();\n    \n    // Clear pending requests\n    this.pendingRequests.clear();\n    \n    // Clear Supabase cache\n    try {\n      const { error } = await supabase\n        .from(this.CACHE_TABLE)\n        .delete()\n        .neq('key', 'never_delete'); // Delete all except this placeholder\n      \n      if (error) {\n        console.warn(`[CacheService] Failed to clear Supabase cache:`, error);\n      }\n    } catch (error) {\n      console.warn(`[CacheService] Error clearing cache:`, error);\n    }\n  }\n\n  /**\n   * Clear expired entries from both memory and Supabase\n   */\n  async cleanup(): Promise<void> {\n    const now = Date.now();\n    \n    // Cleanup memory cache\n    this.cleanupMemoryCache();\n    \n    // Cleanup Supabase cache\n    try {\n      const { error } = await supabase\n        .from(this.CACHE_TABLE)\n        .delete()\n        .lt('expires_at', new Date(now).toISOString());\n      \n      if (error) {\n        console.warn(`[CacheService] Failed to cleanup Supabase cache:`, error);\n      }\n    } catch (error) {\n      console.warn(`[CacheService] Error cleaning up cache:`, error);\n    }\n  }\n\n  /**\n   * Cleanup memory cache to prevent bloat\n   */\n  private cleanupMemoryCache(): void {\n    const now = Date.now();\n    const entries = Array.from(this.memoryCache.entries());\n    \n    // Remove expired entries\n    entries.forEach(([key, item]) => {\n      if (now > item.expires) {\n        this.memoryCache.delete(key);\n      }\n    });\n    \n    // If still too large, remove oldest entries\n    if (this.memoryCache.size > this.MAX_MEMORY_CACHE_SIZE) {\n      const sortedEntries = entries\n        .filter(([key]) => this.memoryCache.has(key))\n        .sort((a, b) => a[1].expires - b[1].expires);\n      \n      const toRemove = sortedEntries.slice(0, this.memoryCache.size - this.MAX_MEMORY_CACHE_SIZE);\n      toRemove.forEach(([key]) => this.memoryCache.delete(key));\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): { memorySize: number; memoryKeys: string[] } {\n    return {\n      memorySize: this.memoryCache.size,\n      memoryKeys: Array.from(this.memoryCache.keys()),\n    };\n  }\n\n  /**\n   * Get comprehensive cache statistics from Supabase\n   */\n  async getSupabaseStats(): Promise<any> {\n    try {\n      const { data, error } = await supabase.rpc('get_cache_stats');\n      if (error) {\n        console.warn('[CacheService] Failed to get Supabase stats:', error);\n        return null;\n      }\n      return data;\n    } catch (error) {\n      console.warn('[CacheService] Error getting Supabase stats:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get cache performance metrics\n   */\n  async getPerformanceMetrics(): Promise<any> {\n    try {\n      const { data, error } = await supabase.rpc('get_cache_performance_metrics');\n      if (error) {\n        console.warn('[CacheService] Failed to get performance metrics:', error);\n        return null;\n      }\n      return data;\n    } catch (error) {\n      console.warn('[CacheService] Error getting performance metrics:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get user-specific cache entries\n   */\n  async getUserCacheEntries(userId: string): Promise<any[]> {\n    try {\n      const { data, error } = await supabase.rpc('get_user_cache_entries', { p_user_id: userId });\n      if (error) {\n        console.warn('[CacheService] Failed to get user cache entries:', error);\n        return [];\n      }\n      return data || [];\n    } catch (error) {\n      console.warn('[CacheService] Error getting user cache entries:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Clear all cache entries for a specific user\n   */\n  async clearUserCache(userId: string): Promise<number> {\n    try {\n      const { data, error } = await supabase.rpc('clear_user_cache', { p_user_id: userId });\n      if (error) {\n        console.warn('[CacheService] Failed to clear user cache:', error);\n        return 0;\n      }\n      return data || 0;\n    } catch (error) {\n      console.warn('[CacheService] Error clearing user cache:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Set chat context data\n   */\n  async setChatContext(userId: string, context: any): Promise<void> {\n    // Store for 90 days - chat context should persist but can expire after extended inactivity\n    await this.set(`chat_context:${userId}`, context, 90 * 24 * 60 * 60 * 1000, 'context', userId); // 90 days\n  }\n\n  /**\n   * Get chat context data\n   */\n  async getChatContext<T>(userId: string): Promise<T | null> {\n    return await this.get<T>(`chat_context:${userId}`);\n  }\n\n  /**\n   * Set user memory data\n   */\n  async setUserMemory(userId: string, memory: any): Promise<void> {\n    // Store indefinitely (365 days) - user memory should persist until explicitly deleted\n    await this.set(`user_memory:${userId}`, memory, 365 * 24 * 60 * 60 * 1000, 'memory', userId); // 1 year\n  }\n\n  /**\n   * Get user memory data\n   */\n  async getUserMemory<T>(userId: string): Promise<T | null> {\n    return await this.get<T>(`user_memory:${userId}`);\n  }\n\n  /**\n   * Set game context data\n   */\n  async setGameContext(userId: string, gameId: string, context: any): Promise<void> {\n    // Store for 90 days - game context should persist but can expire after extended inactivity\n    await this.set(`game_context:${userId}:${gameId}`, context, 90 * 24 * 60 * 60 * 1000, 'context', userId); // 90 days\n  }\n\n  /**\n   * Get game context data\n   */\n  async getGameContext<T>(userId: string, gameId: string): Promise<T | null> {\n    return await this.get<T>(`game_context:${userId}:${gameId}`);\n  }\n\n  /**\n   * Set user data with appropriate TTL\n   */\n  async setUser(userId: string, user: any): Promise<void> {\n    // Store indefinitely (365 days) - user data should persist until explicitly deleted\n    await this.set(`user:${userId}`, user, 365 * 24 * 60 * 60 * 1000, 'user', userId); // 1 year\n  }\n\n  /**\n   * Get user data\n   */\n  async getUser<T>(userId: string): Promise<T | null> {\n    return await this.get<T>(`user:${userId}`);\n  }\n\n  /**\n   * Set rate limit data\n   */\n  async setRateLimit(key: string, data: { count: number; resetTime: number }): Promise<void> {\n    await this.set(`rate_limit:${key}`, data, 15 * 60 * 1000, 'rate_limit'); // 15 minutes\n  }\n\n  /**\n   * Get rate limit data\n   */\n  async getRateLimit(key: string): Promise<{ count: number; resetTime: number } | null> {\n    return await this.get<{ count: number; resetTime: number }>(`rate_limit:${key}`);\n  }\n\n  /**\n   * Set conversation data\n   */\n  async setConversation(conversationId: string, conversation: any, userId?: string): Promise<void> {\n    // Store indefinitely (365 days) - conversations should persist until explicitly deleted\n    await this.set(`conversation:${conversationId}`, conversation, 365 * 24 * 60 * 60 * 1000, 'conversation', userId); // 1 year\n  }\n\n  /**\n   * Get conversation data\n   */\n  async getConversation<T>(conversationId: string): Promise<T | null> {\n    return await this.get<T>(`conversation:${conversationId}`);\n  }\n\n  /**\n   * Initialize cache table if it doesn't exist\n   */\n  async initializeCacheTable(): Promise<void> {\n    try {\n      // Check if table exists by trying to select from it\n      const { error } = await supabase\n        .from(this.CACHE_TABLE)\n        .select('key')\n        .limit(1);\n      \n      if (error && error.code === 'PGRST116') {\n        // Table doesn't exist, create it\n        console.log('[CacheService] Creating cache table...');\n        // Note: This would typically be done via a migration\n        // For now, we'll just log that it needs to be created\n        console.warn('[CacheService] Cache table needs to be created in Supabase');\n      }\n    } catch (error) {\n      console.warn('[CacheService] Error checking cache table:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const cacheService = new CacheService();\n\n// Initialize cache table on startup\ncacheService.initializeCacheTable();\n\n// Auto-cleanup every 5 minutes\nsetInterval(() => {\n  cacheService.cleanup();\n}, 5 * 60 * 1000);\n","/**\n * Centralized error handling service\n * Provides consistent error handling across the application\n */\nclass ErrorService {\n  private static errorCount = 0;\n  private static maxErrorsPerMinute = 10;\n  private static errorWindow = 60 * 1000; // 1 minute\n  private static recentErrors: number[] = [];\n\n  /**\n   * Handle an error with context and optional user message\n   */\n  static handle(error: Error, context: string, userMessage?: string): void {\n    // Increment error count\n    this.errorCount++;\n    \n    // Check if we're hitting error rate limits\n    if (this.isErrorRateLimited()) {\n      console.warn(`[ErrorService] Error rate limit exceeded, suppressing error:`, error);\n      return;\n    }\n\n    // Log error with context\n    console.error(`[${context}]`, {\n      message: error.message,\n      stack: error.stack,\n      context,\n      timestamp: new Date().toISOString(),\n      errorCount: this.errorCount,\n    });\n\n    // Show user-friendly message if provided\n    if (userMessage) {\n      this.showUserMessage(userMessage);\n    }\n\n    // Report to monitoring service (if configured)\n    this.reportError(error, context);\n  }\n\n  /**\n   * Handle authentication errors\n   */\n  static handleAuthError(error: Error, operation: string): void {\n    const userMessage = this.getAuthErrorMessage(operation);\n    this.handle(error, `AuthService:${operation}`, userMessage);\n  }\n\n  /**\n   * Handle WebSocket errors\n   */\n  static handleWebSocketError(error: Error, operation: string): void {\n    const userMessage = this.getWebSocketErrorMessage(operation);\n    this.handle(error, `WebSocketService:${operation}`, userMessage);\n  }\n\n  /**\n   * Handle conversation errors\n   */\n  static handleConversationError(error: Error, operation: string): void {\n    const userMessage = this.getConversationErrorMessage(operation);\n    this.handle(error, `ConversationService:${operation}`, userMessage);\n  }\n\n  /**\n   * Handle database errors\n   */\n  static handleDatabaseError(error: Error, operation: string): void {\n    const userMessage = this.getDatabaseErrorMessage(operation);\n    this.handle(error, `DatabaseService:${operation}`, userMessage);\n  }\n\n  /**\n   * Check if error rate is too high\n   */\n  private static isErrorRateLimited(): boolean {\n    const now = Date.now();\n    \n    // Remove old errors from the window\n    this.recentErrors = this.recentErrors.filter(time => now - time < this.errorWindow);\n    \n    // Add current error\n    this.recentErrors.push(now);\n    \n    // Check if we're over the limit\n    return this.recentErrors.length > this.maxErrorsPerMinute;\n  }\n\n  /**\n   * Show user-friendly error message\n   */\n  private static showUserMessage(message: string): void {\n    // TODO: Implement toast notification system\n    // For now, we'll use console.warn as a placeholder\n    console.warn(`[User Message] ${message}`);\n    \n    // In a real implementation, this would:\n    // 1. Show a toast notification\n    // 2. Update UI state to show error\n    // 3. Log to user activity tracking\n  }\n\n  /**\n   * Report error to monitoring service\n   */\n  private static reportError(error: Error, context: string): void {\n    // TODO: Implement error reporting to monitoring service\n    // For now, we'll just log it\n    console.warn(`[Error Reporting] Would report error to monitoring service:`, {\n      error: error.message,\n      context,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Get user-friendly auth error messages\n   */\n  private static getAuthErrorMessage(operation: string): string {\n    const messages: Record<string, string> = {\n      'signIn': 'Failed to sign in. Please check your credentials and try again.',\n      'signOut': 'Failed to sign out. Please try again.',\n      'loadUser': 'Failed to load user data. Please refresh the page.',\n      'createUser': 'Failed to create user account. Please try again.',\n      'refreshUser': 'Failed to refresh user data. Please try again.',\n    };\n    \n    return messages[operation] || 'An authentication error occurred. Please try again.';\n  }\n\n  /**\n   * Get user-friendly WebSocket error messages\n   */\n  private static getWebSocketErrorMessage(operation: string): string {\n    const messages: Record<string, string> = {\n      'connect': 'Failed to connect to server. Please check your internet connection.',\n      'send': 'Failed to send message. Please try again.',\n      'disconnect': 'Failed to disconnect. Please try again.',\n    };\n    \n    return messages[operation] || 'A connection error occurred. Please try again.';\n  }\n\n  /**\n   * Get user-friendly conversation error messages\n   */\n  private static getConversationErrorMessage(operation: string): string {\n    const messages: Record<string, string> = {\n      'create': 'Failed to create conversation. Please try again.',\n      'load': 'Failed to load conversations. Please refresh the page.',\n      'save': 'Failed to save conversation. Please try again.',\n      'delete': 'Failed to delete conversation. Please try again.',\n    };\n    \n    return messages[operation] || 'A conversation error occurred. Please try again.';\n  }\n\n  /**\n   * Get user-friendly database error messages\n   */\n  private static getDatabaseErrorMessage(operation: string): string {\n    const messages: Record<string, string> = {\n      'save': 'Failed to save data. Please try again.',\n      'load': 'Failed to load data. Please refresh the page.',\n      'update': 'Failed to update data. Please try again.',\n      'delete': 'Failed to delete data. Please try again.',\n    };\n    \n    return messages[operation] || 'A database error occurred. Please try again.';\n  }\n\n  /**\n   * Get error statistics\n   */\n  static getStats(): { totalErrors: number; recentErrors: number; isRateLimited: boolean } {\n    return {\n      totalErrors: this.errorCount,\n      recentErrors: this.recentErrors.length,\n      isRateLimited: this.isErrorRateLimited(),\n    };\n  }\n\n  /**\n   * Reset error statistics\n   */\n  static reset(): void {\n    this.errorCount = 0;\n    this.recentErrors = [];\n  }\n}\n\nexport { ErrorService };\n","/**\r\n * Toast Notification Service\r\n * Provides user-friendly feedback for operations throughout the app\r\n * Replaces silent console.error calls with visible notifications\r\n */\r\n\r\nexport type ToastType = 'success' | 'error' | 'warning' | 'info';\r\n\r\nexport interface ToastAction {\r\n  label: string;\r\n  onClick: () => void | Promise<void>;\r\n}\r\n\r\nexport interface Toast {\r\n  id: string;\r\n  message: string;\r\n  type: ToastType;\r\n  duration?: number;\r\n  action?: ToastAction;\r\n  dismissible?: boolean;\r\n}\r\n\r\nexport interface ToastOptions {\r\n  duration?: number;\r\n  action?: ToastAction;\r\n  dismissible?: boolean;\r\n}\r\n\r\ntype ToastListener = (toasts: Toast[]) => void;\r\n\r\nclass ToastService {\r\n  private toasts: Toast[] = [];\r\n  private listeners: Set<ToastListener> = new Set();\r\n  private maxToasts = 5; // Maximum visible toasts\r\n\r\n  /**\r\n   * Subscribe to toast updates\r\n   * @returns Unsubscribe function\r\n   */\r\n  subscribe(listener: ToastListener): () => void {\r\n    this.listeners.add(listener);\r\n    // Immediately notify with current toasts\r\n    listener(this.toasts);\r\n    \r\n    return () => {\r\n      this.listeners.delete(listener);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Notify all listeners of toast changes\r\n   */\r\n  private notify(): void {\r\n    this.listeners.forEach(listener => listener([...this.toasts]));\r\n  }\r\n\r\n  /**\r\n   * Show a toast notification\r\n   * @param message - Message to display\r\n   * @param type - Toast type (success, error, warning, info)\r\n   * @param options - Additional options\r\n   * @returns Toast ID for manual dismissal\r\n   */\r\n  show(\r\n    message: string,\r\n    type: ToastType = 'info',\r\n    options: ToastOptions = {}\r\n  ): string {\r\n    const id = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    const toast: Toast = {\r\n      id,\r\n      message,\r\n      type,\r\n      duration: options.duration ?? this.getDefaultDuration(type),\r\n      action: options.action,\r\n      dismissible: options.dismissible ?? true,\r\n    };\r\n\r\n    // Add to beginning of array (newest first)\r\n    this.toasts.unshift(toast);\r\n\r\n    // Limit number of visible toasts\r\n    if (this.toasts.length > this.maxToasts) {\r\n      this.toasts = this.toasts.slice(0, this.maxToasts);\r\n    }\r\n\r\n    this.notify();\r\n\r\n    // Auto-dismiss after duration\r\n    if (toast.duration && toast.duration > 0) {\r\n      setTimeout(() => this.dismiss(id), toast.duration);\r\n    }\r\n\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Show success toast\r\n   */\r\n  success(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'success', {\r\n      duration: 3000,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show error toast with optional retry action\r\n   */\r\n  error(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'error', {\r\n      duration: 7000,\r\n      dismissible: true,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show warning toast\r\n   */\r\n  warning(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'warning', {\r\n      duration: 5000,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show info toast\r\n   */\r\n  info(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'info', {\r\n      duration: 4000,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Dismiss a specific toast\r\n   */\r\n  dismiss(id: string): void {\r\n    const index = this.toasts.findIndex(t => t.id === id);\r\n    if (index !== -1) {\r\n      this.toasts.splice(index, 1);\r\n      this.notify();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dismiss all toasts\r\n   */\r\n  dismissAll(): void {\r\n    this.toasts = [];\r\n    this.notify();\r\n  }\r\n\r\n  /**\r\n   * Get default duration based on toast type\r\n   */\r\n  private getDefaultDuration(type: ToastType): number {\r\n    switch (type) {\r\n      case 'success':\r\n        return 3000;\r\n      case 'error':\r\n        return 7000;\r\n      case 'warning':\r\n        return 5000;\r\n      case 'info':\r\n        return 4000;\r\n      default:\r\n        return 4000;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show loading toast that stays until dismissed\r\n   * Returns dismiss function\r\n   */\r\n  loading(message: string): () => void {\r\n    const id = this.show(message, 'info', {\r\n      duration: 0, // Don't auto-dismiss\r\n      dismissible: false,\r\n    });\r\n\r\n    return () => this.dismiss(id);\r\n  }\r\n\r\n  /**\r\n   * Show promise-based toast\r\n   * Shows loading, then success or error based on promise result\r\n   */\r\n  async promise<T>(\r\n    promise: Promise<T>,\r\n    messages: {\r\n      loading: string;\r\n      success: string | ((data: T) => string);\r\n      error: string | ((error: Error) => string);\r\n    }\r\n  ): Promise<T> {\r\n    const dismiss = this.loading(messages.loading);\r\n\r\n    try {\r\n      const result = await promise;\r\n      dismiss();\r\n      \r\n      const successMessage = typeof messages.success === 'function'\r\n        ? messages.success(result)\r\n        : messages.success;\r\n      \r\n      this.success(successMessage);\r\n      return result;\r\n    } catch (error) {\r\n      dismiss();\r\n      \r\n      const errorMessage = typeof messages.error === 'function'\r\n        ? messages.error(error as Error)\r\n        : messages.error;\r\n      \r\n      this.error(errorMessage);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const toastService = new ToastService();\r\n","import { supabase } from '../lib/supabase';\r\n\r\n// ========================================\r\n// TYPES\r\n// ========================================\r\n\r\nexport type OnboardingStep = \r\n  | 'login'               // LoginSplashScreen\r\n  | 'loading'             // Loading screen during auth processing\r\n  | 'initial'             // InitialSplashScreen  \r\n  | 'how-to-use'          // SplashScreen (PC Connection with 6-digit code)\r\n  | 'features-connected'  // HowToUseSplashScreen (Only if PC connection successful)\r\n  | 'pro-features'        // ProFeaturesSplashScreen (Supercharge with Otagon Pro)\r\n  | 'profile-setup'       // Profile Setup Modal (sets has_profile_setup flag)\r\n  | 'complete';           // Main App (Onboarding fully complete)\r\n\r\nexport interface OnboardingProgress {\r\n  step: OnboardingStep;\r\n  completed_at: string;\r\n  data: any;\r\n}\r\n\r\nexport interface OnboardingStatus {\r\n  is_new_user: boolean;\r\n  has_seen_splash_screens: boolean;\r\n  has_profile_setup: boolean;\r\n  has_welcome_message: boolean;\r\n  has_seen_how_to_use: boolean;\r\n  has_seen_features_connected: boolean;\r\n  has_seen_pro_features: boolean;\r\n  pc_connected: boolean;\r\n  pc_connection_skipped: boolean;\r\n  onboarding_completed: boolean;\r\n  tier: string;\r\n}\r\n\r\n// ========================================\r\n// ONBOARDING SERVICE\r\n// ========================================\r\n\r\nclass OnboardingService {\r\n  private static instance: OnboardingService;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): OnboardingService {\r\n    if (!OnboardingService.instance) {\r\n      OnboardingService.instance = new OnboardingService();\r\n    }\r\n    return OnboardingService.instance;\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING STATUS MANAGEMENT\r\n  // ========================================\r\n\r\n  async getOnboardingStatus(userId: string): Promise<OnboardingStatus | null> {\r\n    try {\r\n      console.log('ðŸŽ¯ [OnboardingService] Getting onboarding status for user:', userId);\r\n      const { data, error } = await supabase.rpc('get_user_onboarding_status', {\r\n        p_user_id: userId\r\n      });\r\n\r\n      if (error) {\r\n        console.error('ðŸŽ¯ [OnboardingService] Error getting onboarding status:', error);\r\n        return null;\r\n      }\r\n\r\n      console.log('ðŸŽ¯ [OnboardingService] Onboarding status raw data:', data);\r\n      \r\n      // The RPC function returns a TABLE (array), so we need to get the first element\r\n      if (!data || data.length === 0) {\r\n        console.log('ðŸŽ¯ [OnboardingService] No onboarding data found for user');\r\n        return null;\r\n      }\r\n      \r\n      const status = data[0];\r\n      console.log('ðŸŽ¯ [OnboardingService] Onboarding status (first element):', status);\r\n      return status;\r\n\r\n    } catch (error) {\r\n      console.error('ðŸŽ¯ [OnboardingService] Error getting onboarding status:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async updateOnboardingStatus(userId: string, status: OnboardingStep, data: any = {}): Promise<boolean> {\r\n    try {\r\n      const { error } = await supabase.rpc('update_user_onboarding_status', {\r\n        p_user_id: userId,\r\n        p_step: status,\r\n        p_data: data\r\n      });\r\n\r\n      if (error) {\r\n        console.error('Error updating onboarding status:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Error updating onboarding status:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getOnboardingProgress(userId: string): Promise<OnboardingProgress[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('onboarding_progress')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .order('completed_at', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error getting onboarding progress:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []).map(item => ({\r\n        step: item.step as OnboardingStep,\r\n        completed_at: item.created_at || '',\r\n        data: item.data || {}\r\n      }));\r\n\r\n    } catch (error) {\r\n      console.error('Error getting onboarding progress:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // STEP-SPECIFIC METHODS\r\n  // ========================================\r\n\r\n  async markSplashScreensSeen(userId: string): Promise<boolean> {\r\n    return this.updateOnboardingStatus(userId, 'initial', {\r\n      splash_screens_seen: true,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  async markProfileSetupComplete(userId: string, profileData: any): Promise<boolean> {\r\n    // Profile setup is now handled in the chat screen, not as part of onboarding\r\n    // This function is kept for backward compatibility but doesn't affect onboarding flow\r\n    try {\r\n      const { error } = await supabase\r\n        .from('users')\r\n        .update({\r\n          has_profile_setup: true,\r\n          profile_data: profileData,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('auth_user_id', userId);\r\n\r\n      if (error) {\r\n        console.error('Error marking profile setup complete:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking profile setup complete:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async markWelcomeMessageShown(userId: string): Promise<boolean> {\r\n    return this.updateOnboardingStatus(userId, 'complete', {\r\n      welcome_message_shown: true,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  async markOnboardingComplete(userId: string): Promise<boolean> {\r\n    return this.updateOnboardingStatus(userId, 'complete', {\r\n      onboarding_complete: true,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING FLOW LOGIC\r\n  // ========================================\r\n\r\n  // Helper function to safely get boolean values with defaults\r\n  private getBooleanValue(value: any, defaultValue: boolean = false): boolean {\r\n    if (value === null || value === undefined) {\r\n      return defaultValue;\r\n    }\r\n    return Boolean(value);\r\n  }\r\n\r\n  async getNextOnboardingStep(userId: string): Promise<OnboardingStep> {\r\n    try {\r\n      console.log('ðŸŽ¯ [OnboardingService] Getting next step for user:', userId);\r\n      const status = await this.getOnboardingStatus(userId);\r\n      console.log('ðŸŽ¯ [OnboardingService] User status:', status);\r\n      \r\n      if (!status) {\r\n        console.log('ðŸŽ¯ [OnboardingService] No status found, returning login');\r\n        return 'login';\r\n      }\r\n\r\n\r\n      // Safely get boolean values with defaults\r\n      const hasSeenSplashScreens = this.getBooleanValue(status.has_seen_splash_screens);\r\n      const hasSeenHowToUse = this.getBooleanValue(status.has_seen_how_to_use);\r\n      const hasSeenFeaturesConnected = this.getBooleanValue(status.has_seen_features_connected);\r\n      const hasSeenProFeatures = this.getBooleanValue(status.has_seen_pro_features);\r\n      const pcConnected = this.getBooleanValue(status.pc_connected);\r\n      const pcConnectionSkipped = this.getBooleanValue(status.pc_connection_skipped);\r\n\r\n      console.log('ðŸŽ¯ [OnboardingService] Processed values:', {\r\n        hasSeenSplashScreens,\r\n        hasSeenHowToUse,\r\n        hasSeenFeaturesConnected,\r\n        hasSeenProFeatures,\r\n        pcConnected,\r\n        pcConnectionSkipped\r\n      });\r\n\r\n      // Check onboarding steps in order (matching old build logic)\r\n      if (!hasSeenSplashScreens) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User hasn\\'t seen splash screens, returning initial');\r\n        return 'initial';\r\n      }\r\n\r\n      // After initial splash, go to how-to-use (PC connection)\r\n      if (hasSeenSplashScreens && !hasSeenHowToUse) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User needs to see how-to-use screen, returning how-to-use');\r\n        return 'how-to-use';\r\n      }\r\n\r\n      // If PC connection was successful, show features-connected\r\n      if (hasSeenHowToUse && pcConnected && !hasSeenFeaturesConnected) {\r\n        console.log('ðŸŽ¯ [OnboardingService] PC connected, showing features-connected screen');\r\n        return 'features-connected';\r\n      }\r\n\r\n      // If PC connection was skipped, go to pro-features\r\n      if (hasSeenHowToUse && !pcConnected && pcConnectionSkipped && !hasSeenProFeatures) {\r\n        console.log('ðŸŽ¯ [OnboardingService] PC connection skipped, showing pro-features screen');\r\n        return 'pro-features';\r\n      }\r\n\r\n      // If PC connection failed (not skipped), go back to how-to-use\r\n      if (hasSeenHowToUse && !pcConnected && !pcConnectionSkipped) {\r\n        console.log('ðŸŽ¯ [OnboardingService] PC connection failed, returning to how-to-use screen');\r\n        return 'how-to-use';\r\n      }\r\n\r\n      // After features-connected, go to pro-features\r\n      if (hasSeenFeaturesConnected && !hasSeenProFeatures) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User needs to see pro-features screen, returning pro-features');\r\n        return 'pro-features';\r\n      }\r\n\r\n      // After pro features, onboarding is complete (profile setup is now an overlay)\r\n      if (hasSeenProFeatures) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User has seen pro features, onboarding complete');\r\n        return 'complete';\r\n      }\r\n\r\n      // REMOVED: Overly aggressive fallback that was skipping screens\r\n      // If we reach here, something is wrong - but return to how-to-use rather than complete\r\n      // This prevents skipping screens if the flow logic breaks\r\n      console.warn('ðŸŽ¯ [OnboardingService] WARNING: Unexpected flow state, returning to how-to-use');\r\n      return 'how-to-use';\r\n\r\n    } catch (error) {\r\n      console.error('ðŸŽ¯ [OnboardingService] Error getting next onboarding step:', error);\r\n      return 'login';\r\n    }\r\n  }\r\n\r\n  async shouldShowOnboarding(userId: string): Promise<boolean> {\r\n    try {\r\n      const status = await this.getOnboardingStatus(userId);\r\n      \r\n      if (!status) {\r\n        return true;\r\n      }\r\n\r\n      // Check if onboarding is complete\r\n      return !status.onboarding_completed;\r\n\r\n    } catch (error) {\r\n      console.error('Error checking if should show onboarding:', error);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING ANALYTICS\r\n  // ========================================\r\n\r\n  async trackOnboardingStep(userId: string, step: OnboardingStep, action: string, data: any = {}): Promise<void> {\r\n    try {\r\n      await supabase\r\n        .from('user_analytics')\r\n        .insert({\r\n          user_id: userId,\r\n          event_type: 'onboarding_step',\r\n          event_data: {\r\n            step,\r\n            action,\r\n            data,\r\n            timestamp: new Date().toISOString()\r\n          }\r\n        });\r\n\r\n    } catch (error) {\r\n      console.error('Error tracking onboarding step:', error);\r\n    }\r\n  }\r\n\r\n  async trackOnboardingDropOff(userId: string, step: OnboardingStep, reason: string, data: any = {}): Promise<void> {\r\n    try {\r\n      await supabase\r\n        .from('user_analytics')\r\n        .insert({\r\n          user_id: userId,\r\n          event_type: 'onboarding_dropoff',\r\n          event_data: {\r\n            step,\r\n            reason,\r\n            data,\r\n            timestamp: new Date().toISOString()\r\n          }\r\n        });\r\n\r\n    } catch (error) {\r\n      console.error('Error tracking onboarding dropoff:', error);\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING RESET\r\n  // ========================================\r\n\r\n  async resetOnboarding(userId: string): Promise<boolean> {\r\n    try {\r\n      // Clear onboarding progress\r\n      const { error: progressError } = await supabase\r\n        .from('onboarding_progress')\r\n        .delete()\r\n        .eq('user_id', userId);\r\n\r\n      if (progressError) {\r\n        console.error('Error clearing onboarding progress:', progressError);\r\n        return false;\r\n      }\r\n\r\n      // Reset user onboarding flags\r\n      const { error: userError } = await supabase\r\n        .from('users')\r\n        .update({\r\n          is_new_user: true,\r\n          has_seen_splash_screens: false,\r\n          has_profile_setup: false,\r\n          has_welcome_message: false,\r\n          onboarding_completed: false,\r\n          onboarding_data: {}\r\n        })\r\n        .eq('id', userId);\r\n\r\n      if (userError) {\r\n        console.error('Error resetting user onboarding flags:', userError);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Error resetting onboarding:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING STATISTICS\r\n  // ========================================\r\n\r\n  async getOnboardingStats(): Promise<{\r\n    total_users: number;\r\n    completed_onboarding: number;\r\n    dropoff_by_step: Record<string, number>;\r\n  }> {\r\n    try {\r\n      // Get total users\r\n      const { count: totalUsers } = await supabase\r\n        .from('users')\r\n        .select('*', { count: 'exact', head: true });\r\n\r\n      // Get users who completed onboarding\r\n      const { count: completedUsers } = await supabase\r\n        .from('users')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('onboarding_completed', true);\r\n\r\n      // Get dropoff by step\r\n      const { data: dropoffData } = await supabase\r\n        .from('user_analytics')\r\n        .select('event_data')\r\n        .eq('event_type', 'onboarding_dropoff');\r\n\r\n      const dropoffByStep: Record<string, number> = {};\r\n      if (dropoffData) {\r\n        dropoffData.forEach(record => {\r\n          const eventData = record.event_data;\r\n          if (typeof eventData === 'object' && eventData !== null && !Array.isArray(eventData)) {\r\n            const step = (eventData as Record<string, unknown>).step;\r\n            if (typeof step === 'string') {\r\n              dropoffByStep[step] = (dropoffByStep[step] || 0) + 1;\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      return {\r\n        total_users: totalUsers || 0,\r\n        completed_onboarding: completedUsers || 0,\r\n        dropoff_by_step: dropoffByStep\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Error getting onboarding stats:', error);\r\n      return {\r\n        total_users: 0,\r\n        completed_onboarding: 0,\r\n        dropoff_by_step: {}\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// ========================================\r\n// EXPORT SINGLETON INSTANCE\r\n// ========================================\r\n\r\nexport const onboardingService = OnboardingService.getInstance();\r\nexport default onboardingService;\r\n","let ws: WebSocket | null = null;\nconst SERVER_ADDRESS = 'wss://otakon-relay.onrender.com';\n\nlet reconnectAttempts = 0;\nconst maxBackoffMs = 5000;\nconst sendQueue: object[] = [];\nlet lastCode: string | null = null;\nlet handlers: { onOpen: () => void; onMessage: (data: any) => void; onError: (error: string) => void; onClose: () => void } | null = null;\nlet heartbeatTimer: number | null = null;\nconst HEARTBEAT_MS = 30000; // 30s - more frequent heartbeat to maintain connection\n\n\nconst connect = (\n  code: string,\n  onOpen: () => void,\n  onMessage: (data: any) => void,\n  onError: (error: string) => void,\n  onClose: () => void\n) => {\n\n  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {\n    // Skip logging for already connected state\n    return;\n  }\n\n  // Only accept 6-digit codes\n  if (!/^\\d{6}$/.test(code)) {\n    onError(\"Invalid code format. Please enter a 6-digit code.\");\n    return;\n  }\n\n  lastCode = code;\n  handlers = { onOpen, onMessage, onError, onClose };\n\n  const fullUrl = `${SERVER_ADDRESS}/${code}`;\n\n  try {\n    ws = new WebSocket(fullUrl);\n  } catch (e) {\n    const message = e instanceof Error ? e.message : \"An unknown error occurred.\";\n    onError(`Connection failed: ${message}. Please check the URL and your network connection.`);\n    return;\n  }\n\n  ws.onopen = () => {\n    // Connection established - no need to log every connection\n    reconnectAttempts = 0;\n    onOpen();\n    // Flush queued messages\n    while (sendQueue.length && ws && ws.readyState === WebSocket.OPEN) {\n      const payload = sendQueue.shift();\n      try { \n        ws.send(JSON.stringify(payload)); \n      } catch {\n        // Ignore send errors during queue processing\n      }\n    }\n\n    // Start heartbeat\n    if (heartbeatTimer) {\n      clearInterval(heartbeatTimer);\n      heartbeatTimer = null;\n    }\n    heartbeatTimer = window.setInterval(() => {\n      if (ws && ws.readyState === WebSocket.OPEN) {\n        try { \n          ws.send(JSON.stringify({ type: 'ping', ts: Date.now() })); \n        } catch {\n          // Ignore heartbeat send errors\n        }\n      }\n    }, HEARTBEAT_MS);\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      // Only log errors in development, not every message\n      onMessage(data);\n    } catch (e) {\n      if (process.env.NODE_ENV === 'development') {\n        console.error(\"Failed to parse WebSocket message:\", event.data, e);\n      }\n      // Ignore non-JSON\n    }\n  };\n\n  ws.onerror = () => {\n    // Handled by onclose\n  };\n\n  ws.onclose = (event: CloseEvent) => {\n    // Only log unexpected closures\n    if (!event.wasClean && process.env.NODE_ENV === 'development') {\n      console.warn(`WebSocket connection closed unexpectedly. Code: ${event.code}, Reason: '${event.reason}'`);\n    }\n\n    if (!event.wasClean) {\n      let errorMessage = \"Connection closed unexpectedly.\";\n      if (event.code === 1006) {\n        errorMessage = \"Connection to the server failed. Please check your network, verify the code, and ensure the PC client is running.\";\n      } else if (event.reason) {\n        errorMessage = `Connection closed: ${event.reason}`;\n      }\n      onError(errorMessage);\n    }\n\n    ws = null;\n    onClose();\n\n    // Stop heartbeat\n    if (heartbeatTimer) {\n      clearInterval(heartbeatTimer);\n      heartbeatTimer = null;\n    }\n\n    // Auto-reconnect with backoff+jitter\n    if (lastCode && handlers) {\n      reconnectAttempts += 1;\n      const base = Math.min(maxBackoffMs, 500 * Math.pow(2, reconnectAttempts - 1));\n      const jitter = Math.random() * 300;\n      const delay = base + jitter;\n      setTimeout(() => {\n        if (!ws && handlers) {\n          connect(lastCode!, handlers.onOpen, handlers.onMessage, handlers.onError, handlers.onClose);\n        }\n      }, delay);\n    }\n  };\n};\n\nconst send = (data: object) => {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify(data));\n  } else {\n    // Queue and let onopen flush\n    sendQueue.push(data);\n    // Message queued - no need to log every queued message\n  }\n};\n\nconst disconnect = () => {\n  if (ws) {\n    ws.close(1000, \"User disconnected\");\n    ws = null;\n  }\n  reconnectAttempts = 0;\n  if (heartbeatTimer) {\n    clearInterval(heartbeatTimer);\n    heartbeatTimer = null;\n  }\n  \n  // Clear all connection state to prevent auto-reconnection after logout\n  lastCode = null;\n  handlers = null;\n  \n  // Clear any pending reconnection attempts\n  if (process.env.NODE_ENV === 'development') {\n    console.log(\"ðŸ”Œ WebSocket disconnected and all reconnection state cleared\");\n  }\n};\n\nexport { connect, disconnect, send };\n","import { supabase } from '../lib/supabase';\n\nexport interface WaitlistEntry {\n  id?: string;\n  email: string;\n  created_at?: string;\n  source?: string;\n  status?: 'pending' | 'approved' | 'rejected';\n}\n\nexport class WaitlistService {\n  static async addToWaitlist(email: string, source: string = 'landing_page'): Promise<{ success: boolean; error?: string; alreadyExists?: boolean }> {\n    try {\n      console.log('Adding to waitlist using direct table operations');\n      \n      // Try to insert directly first - this will fail if email already exists\n      const { data: insertData, error: insertError } = await supabase\n        .from('waitlist')\n        .insert({\n          email,\n          source,\n          status: 'pending'\n        })\n        .select();\n\n      if (insertError) {\n        console.error('Error adding to waitlist:', insertError);\n        console.error('Insert error details:', {\n          message: insertError.message,\n          code: insertError.code,\n          details: insertError.details,\n          hint: insertError.hint\n        });\n        \n        // Check if it's a duplicate key error (email already exists)\n        if (insertError.code === '23505') {\n          return { \n            success: true, \n            alreadyExists: true,\n            error: 'You\\'re already on our waitlist! We\\'ll email you when access is ready.'\n          };\n        }\n        \n        // For other errors, try to check if email exists first\n        const { data: existing, error: checkError } = await supabase\n          .from('waitlist')\n          .select('email, status, created_at')\n          .eq('email', email)\n          .maybeSingle();\n\n        if (checkError) {\n          console.error('Error checking existing email:', checkError);\n          return { success: false, error: `Failed to add to waitlist: ${insertError.message}` };\n        }\n\n        if (existing) {\n          return { \n            success: true, \n            alreadyExists: true,\n            error: 'You\\'re already on our waitlist! We\\'ll email you when access is ready.'\n          };\n        }\n        \n        return { success: false, error: `Failed to add to waitlist: ${insertError.message}` };\n      }\n\n      console.log('Successfully added to waitlist:', insertData);\n      return { \n        success: true, \n        alreadyExists: false,\n        error: undefined\n      };\n    } catch (error) {\n      console.error('Waitlist service error:', error);\n      return { success: false, error: 'An unexpected error occurred' };\n    }\n  }\n\n  // Get waitlist count (for display purposes)\n  static async getWaitlistCount(): Promise<{ count?: number; error?: string }> {\n    try {\n      // Use direct table query (no function calls to avoid 404 errors)\n      const { count, error } = await supabase\n        .from('waitlist')\n        .select('*', { count: 'exact', head: true });\n\n      if (error) {\n        console.error('Error getting waitlist count:', error);\n        return { error: 'Failed to get count' };\n      }\n\n      return { count: count || 0 };\n    } catch (error) {\n      console.error('Error getting waitlist count:', error);\n      return { error: 'Failed to get count' };\n    }\n  }\n\n  static async getWaitlistStats(): Promise<{ total: number; pending: number; invited: number; converted: number }> {\n    try {\n      const { data, error } = await supabase\n        .from('waitlist')\n        .select('status');\n\n      if (error) {\n        console.error('Error fetching waitlist stats:', error);\n        // Return default stats instead of zeros to maintain UI consistency\n        return { total: 137, pending: 137, invited: 0, converted: 0 };\n      }\n\n      const stats = {\n        total: data.length,\n        pending: 0,\n        invited: 0,\n        converted: 0\n      };\n\n      data.forEach(entry => {\n        const status = entry.status || 'pending';\n        if (status === 'pending') {\n          stats.pending++;\n        } else if (status === 'approved') {\n          stats.invited++;\n        } else if (status === 'rejected') {\n          stats.converted++;\n        }\n      });\n\n      return stats;\n    } catch (error) {\n      console.error('Error fetching waitlist stats:', error);\n      // Return default stats instead of zeros to maintain UI consistency\n      return { total: 137, pending: 137, invited: 0, converted: 0 };\n    }\n  }\n}\n","export class StorageService {\n  static get<T>(key: string, defaultValue: T): T {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch (error) {\n      console.error(`Error getting ${key} from localStorage:`, error);\n      return defaultValue;\n    }\n  }\n\n  static set<T>(key: string, value: T): void {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error(`Error setting ${key} in localStorage:`, error);\n    }\n  }\n\n  static remove(key: string): void {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.error(`Error removing ${key} from localStorage:`, error);\n    }\n  }\n\n  static clear(): void {\n    try {\n      localStorage.clear();\n    } catch (error) {\n      console.error('Error clearing localStorage:', error);\n    }\n  }\n}\n","import { cacheService } from './cacheService';\nimport { Conversation, ChatMessage } from '../types';\n\n/**\n * Chat Memory Service using centralized cache\n * Handles chat persistence, context, and memory management\n */\nclass ChatMemoryService {\n  private readonly CONVERSATION_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days\n  private readonly CONTEXT_TTL = 24 * 60 * 60 * 1000; // 24 hours\n\n  /**\n   * Save conversation with full context\n   */\n  async saveConversation(conversation: Conversation, userId?: string): Promise<void> {\n    const key = `conversation:${conversation.id}`;\n    await cacheService.set(key, conversation, this.CONVERSATION_TTL, 'conversation', userId);\n  }\n\n  /**\n   * Load conversation with context\n   */\n  async loadConversation(conversationId: string): Promise<Conversation | null> {\n    const key = `conversation:${conversationId}`;\n    return await cacheService.get<Conversation>(key);\n  }\n\n  /**\n   * Save chat context (recent messages, user preferences, etc.)\n   */\n  async saveChatContext(userId: string, context: {\n    recentMessages: ChatMessage[];\n    userPreferences: any;\n    gameContext: any;\n    conversationSummary: string;\n  }): Promise<void> {\n    await cacheService.setChatContext(userId, context);\n  }\n\n  /**\n   * Load chat context\n   */\n  async loadChatContext(userId: string): Promise<any | null> {\n    return await cacheService.getChatContext(userId);\n  }\n\n  /**\n   * Save AI memory/insights about user\n   */\n  async saveUserMemory(userId: string, memory: {\n    preferences: any;\n    playStyle: string;\n    favoriteGames: string[];\n    lastInteractions: any[];\n    personalityProfile: any;\n  }): Promise<void> {\n    await cacheService.setUserMemory(userId, memory);\n  }\n\n  /**\n   * Load AI memory about user\n   */\n  async loadUserMemory(userId: string): Promise<any | null> {\n    return await cacheService.getUserMemory(userId);\n  }\n\n  /**\n   * Save conversation summary for quick context\n   */\n  async saveConversationSummary(conversationId: string, summary: {\n    keyPoints: string[];\n    userQuestions: string[];\n    aiInsights: string[];\n    gameContext: any;\n  }): Promise<void> {\n    const key = `conversation_summary:${conversationId}`;\n    await cacheService.set(key, summary, this.CONTEXT_TTL);\n  }\n\n  /**\n   * Load conversation summary\n   */\n  async loadConversationSummary(conversationId: string): Promise<any | null> {\n    const key = `conversation_summary:${conversationId}`;\n    return await cacheService.get(key);\n  }\n\n  /**\n   * Save game-specific context\n   */\n  async saveGameContext(userId: string, gameId: string, context: {\n    currentProgress: any;\n    lastScreenshot: string;\n    recentHints: string[];\n    userFrustrationLevel: number;\n    preferredHintStyle: string;\n  }): Promise<void> {\n    await cacheService.setGameContext(userId, gameId, context);\n  }\n\n  /**\n   * Load game-specific context\n   */\n  async loadGameContext(userId: string, gameId: string): Promise<any | null> {\n    return await cacheService.getGameContext(userId, gameId);\n  }\n\n  /**\n   * Get all user conversations (for sidebar)\n   */\n  async getUserConversations(_userId: string): Promise<Conversation[]> {\n    // This would need a different approach - maybe a separate table\n    // For now, we'll use a pattern-based approach\n    const conversations: Conversation[] = [];\n    \n    // In a real implementation, you'd query a conversations table\n    // or use a different caching strategy for this\n    return conversations;\n  }\n\n  /**\n   * Clear all chat data for a user\n   */\n  async clearUserChatData(userId: string): Promise<void> {\n    // Use the enhanced cache service to clear all user data\n    await cacheService.clearUserCache(userId);\n  }\n}\n\nexport const chatMemoryService = new ChatMemoryService();\n","/**\r\n * Parses AI responses to extract OTAKON tags and clean content\r\n */\r\nexport const parseOtakonTags = (rawContent: string): { cleanContent: string; tags: Map<string, any> } => {\r\n  const tags = new Map<string, any>();\r\n  const tagRegex = /\\[OTAKON_([A-Z_]+):\\s*(.*?)\\]/g;\r\n\r\n  let cleanContent = rawContent;\r\n  let match;\r\n\r\n  while ((match = tagRegex.exec(rawContent)) !== null) {\r\n    const tagName = match[1];\r\n    let tagValue: any = match[2].trim();\r\n\r\n    console.log(`ðŸ” [OtakonTags] Found tag: ${tagName}, raw value: \"${tagValue}\"`);\r\n\r\n    // Parse JSON for complex tags\r\n    try {\r\n      if (tagValue.startsWith('{') && tagValue.endsWith('}')) {\r\n        tagValue = JSON.parse(tagValue);\r\n        console.log(`ðŸ” [OtakonTags] Parsed as JSON object:`, tagValue);\r\n      }\r\n      if (tagValue.startsWith('[') && tagValue.endsWith(']')) {\r\n        tagValue = JSON.parse(tagValue.replace(/'/g, '\"'));\r\n        console.log(`ðŸ” [OtakonTags] Parsed as JSON array:`, tagValue);\r\n      }\r\n    } catch (_e) {\r\n      console.log(`ðŸ” [OtakonTags] JSON parsing failed, keeping as string:`, tagValue);\r\n      // Keep as string if not valid JSON\r\n    }\r\n\r\n    tags.set(tagName, tagValue);\r\n    cleanContent = cleanContent.replace(match[0], '');\r\n  }\r\n\r\n  // Clean up extra whitespace and empty lines\r\n  cleanContent = cleanContent\r\n    .replace(/^Hint:\\s*\\n\\s*Hint:\\s*/gm, 'Hint: ') // Fix duplicate Hint headers\r\n    .replace(/^Hint:\\s*\\n\\s*Hint:\\s*/gm, 'Hint: ') // Fix multiple duplicate Hint headers\r\n    .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n') // Replace multiple newlines with double newlines\r\n    .replace(/^\\s+|\\s+$/g, '') // Trim start and end\r\n    .replace(/\\s+$/gm, '') // Trim end of each line\r\n    .replace(/^$\\n/gm, '') // Remove empty lines\r\n    .replace(/\\n\\s*\\n/g, '\\n\\n') // Ensure proper paragraph spacing\r\n    .replace(/\\n\\n\\n+/g, '\\n\\n') // Remove excessive line breaks\r\n    .replace(/\\s*\\]\\s*$/, '') // Remove trailing ] characters with surrounding whitespace\r\n    .replace(/\\s*\\[\\s*$/, '') // Remove trailing [ characters with surrounding whitespace\r\n    .replace(/^\\s*\\]\\s*/, '') // Remove leading ] characters with surrounding whitespace\r\n    .replace(/^\\s*\\[\\s*/, '') // Remove leading [ characters with surrounding whitespace\r\n    .trim();\r\n\r\n  return { cleanContent, tags };\r\n};\r\n\r\n","import { SubTab, PlayerProfile } from '../types';\n\nexport interface GameContext {\n  playthroughCount?: number;\n  lastSessionDate?: number;\n  totalPlayTime?: number;\n  objectivesCompleted?: string[];\n  secretsFound?: string[];\n}\n\nexport interface ProfileSpecificTab extends Omit<SubTab, 'content' | 'isNew' | 'status'> {\n  priority: 'high' | 'medium' | 'low';\n  isProfileSpecific: boolean;\n}\n\nclass ProfileAwareTabService {\n  private static instance: ProfileAwareTabService;\n\n  private constructor() {}\n\n  static getInstance(): ProfileAwareTabService {\n    if (!ProfileAwareTabService.instance) {\n      ProfileAwareTabService.instance = new ProfileAwareTabService();\n    }\n    return ProfileAwareTabService.instance;\n  }\n\n  /**\n   * Generate additional tabs based on player profile\n   * These tabs are added to the base genre tabs\n   */\n  generateProfileSpecificTabs(\n    profile: PlayerProfile,\n    gameContext?: GameContext\n  ): ProfileSpecificTab[] {\n    const tabs: ProfileSpecificTab[] = [];\n\n    // Add tabs based on player focus\n    if (profile.playerFocus === 'Story-Driven') {\n      tabs.push({\n        id: 'narrative_themes',\n        title: 'Narrative Themes',\n        type: 'story',\n        priority: 'high',\n        isProfileSpecific: true,\n        instruction: this.getNarrativeThemesInstruction(profile.hintStyle),\n      });\n    }\n\n    if (profile.playerFocus === 'Completionist') {\n      tabs.push({\n        id: 'secret_hunting',\n        title: 'Secret Hunting',\n        type: 'tips',\n        priority: 'high',\n        isProfileSpecific: true,\n        instruction: this.getSecretHuntingInstruction(profile.hintStyle),\n      });\n    }\n\n    if (profile.playerFocus === 'Strategist') {\n      tabs.push({\n        id: 'optimization_guide',\n        title: 'Optimization Guide',\n        type: 'strategies',\n        priority: 'high',\n        isProfileSpecific: true,\n        instruction: this.getOptimizationInstruction(profile.hintStyle),\n      });\n    }\n\n    // Add playthrough-specific tabs for returning players\n    if (gameContext?.playthroughCount && gameContext.playthroughCount > 1) {\n      tabs.push({\n        id: 'playthrough_comparison',\n        title: 'Playthrough Comparison',\n        type: 'tips',\n        priority: 'medium',\n        isProfileSpecific: true,\n        instruction: this.getPlaythroughComparisonInstruction(profile),\n      });\n    }\n\n    return tabs;\n  }\n\n  /**\n   * Get custom instructions for Narrative Themes tab based on hint style\n   */\n  private getNarrativeThemesInstruction(hintStyle: string): string {\n    const instructions: Record<string, string> = {\n      Cryptic:\n        'Provide subtle hints about story themes without revealing major plot points. Use metaphorical language and thematic connections.',\n      Balanced:\n        'Discuss narrative elements with moderate detail, balancing spoiler avoidance with meaningful insight into themes and character arcs.',\n      Direct:\n        'Explain story themes clearly while maintaining appropriate spoiler warnings. Provide direct analysis of narrative elements encountered so far.',\n    };\n    return instructions[hintStyle] || instructions['Balanced'];\n  }\n\n  /**\n   * Get custom instructions for Secret Hunting tab based on hint style\n   */\n  private getSecretHuntingInstruction(hintStyle: string): string {\n    const instructions: Record<string, string> = {\n      Cryptic:\n        'Give mysterious clues about hidden content locations. Use environmental riddles and subtle hints that require exploration.',\n      Balanced:\n        'Provide clear directions to secrets with some exploration challenge. Balance helpfulness with maintaining the joy of discovery.',\n      Direct:\n        'Give precise locations and requirements for finding secrets. Include step-by-step instructions and exact coordinates when helpful.',\n    };\n    return instructions[hintStyle] || instructions['Balanced'];\n  }\n\n  /**\n   * Get custom instructions for Optimization Guide tab based on hint style\n   */\n  private getOptimizationInstruction(hintStyle: string): string {\n    const instructions: Record<string, string> = {\n      Cryptic:\n        'Suggest optimization strategies through hints and examples. Let the player discover the optimal path with guidance.',\n      Balanced:\n        'Provide balanced optimization advice with clear explanations. Suggest effective approaches while leaving room for experimentation.',\n      Direct:\n        'Give specific optimization recommendations with detailed steps. Provide exact stat allocations, builds, and strategies for maximum efficiency.',\n    };\n    return instructions[hintStyle] || instructions['Direct'];\n  }\n\n  /**\n   * Get custom instructions for Playthrough Comparison tab\n   */\n  private getPlaythroughComparisonInstruction(profile: PlayerProfile): string {\n    return `Compare different playthrough approaches based on ${profile.playerFocus} style and ${profile.hintStyle} preferences. Highlight what's different this time and suggest new strategies to explore.`;\n  }\n\n  /**\n   * Prioritize tabs based on player profile\n   * Profile-specific tabs get higher priority, then by assigned priority level\n   */\n  prioritizeTabsForProfile(\n    tabs: ProfileSpecificTab[],\n    _profile: PlayerProfile\n  ): ProfileSpecificTab[] {\n    return tabs.sort((a, b) => {\n      // Profile-specific tabs get highest priority\n      if (a.isProfileSpecific && !b.isProfileSpecific) {\n        return -1;\n      }\n      if (!a.isProfileSpecific && b.isProfileSpecific) {\n        return 1;\n      }\n\n      // Then by priority level\n      const priorityOrder = { high: 3, medium: 2, low: 1 };\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n  }\n\n  /**\n   * Get hint style modifier for AI prompts\n   * This modifies how AI generates content based on user preference\n   */\n  getHintStyleModifier(hintStyle: string): string {\n    const modifiers: Record<string, string> = {\n      Cryptic:\n        'Use subtle, metaphorical hints. Avoid direct answers. Make the player think and discover.',\n      Balanced:\n        'Provide clear guidance while leaving room for exploration. Balance helpfulness with discovery.',\n      Direct:\n        'Give explicit, step-by-step instructions. Be precise and comprehensive in explanations.',\n    };\n    return modifiers[hintStyle] || modifiers['Balanced'];\n  }\n\n  /**\n   * Get player focus modifier for AI prompts\n   * This adjusts content emphasis based on what the player cares about\n   */\n  getPlayerFocusModifier(playerFocus: string): string {\n    const modifiers: Record<string, string> = {\n      'Story-Driven':\n        'Emphasize narrative elements, character development, and story context. Prioritize lore and thematic content.',\n      Completionist:\n        'Focus on collectibles, hidden items, side quests, and 100% completion strategies. Highlight missable content.',\n      Strategist:\n        'Prioritize optimal strategies, build optimization, and efficient progression. Focus on mechanics and systems.',\n    };\n    return modifiers[playerFocus] || modifiers['Strategist'];\n  }\n\n  /**\n   * Get spoiler tolerance modifier for AI prompts\n   * Controls how much future content can be hinted at\n   */\n  getSpoilerToleranceModifier(spoilerTolerance: string): string {\n    const modifiers: Record<string, string> = {\n      Strict:\n        'NEVER mention future events, characters, or plot points. Only discuss content up to current progress.',\n      Moderate:\n        'You may hint at upcoming content in vague terms, but avoid specific spoilers.',\n      Relaxed:\n        'You can discuss future content more freely, but still mark major spoilers clearly.',\n    };\n    return modifiers[spoilerTolerance] || modifiers['Strict'];\n  }\n\n  /**\n   * Get tone modifier for AI prompts\n   * Adjusts the conversational style of responses\n   */\n  getToneModifier(preferredTone: string): string {\n    const modifiers: Record<string, string> = {\n      Encouraging:\n        'Use an enthusiastic, supportive tone. Celebrate achievements and provide positive reinforcement.',\n      Professional:\n        'Maintain a knowledgeable, respectful tone. Provide expertise without excessive casualness.',\n      Casual:\n        'Use a friendly, conversational tone. Feel free to use gaming terminology and be relaxed.',\n    };\n    return modifiers[preferredTone] || modifiers['Professional'];\n  }\n\n  /**\n   * Build complete profile context for AI prompts\n   * Combines all profile modifiers into a single instruction block\n   */\n  buildProfileContext(profile: PlayerProfile): string {\n    const parts = [\n      `Hint Style: ${this.getHintStyleModifier(profile.hintStyle)}`,\n      `Player Focus: ${this.getPlayerFocusModifier(profile.playerFocus)}`,\n      `Spoiler Tolerance: ${this.getSpoilerToleranceModifier(profile.spoilerTolerance)}`,\n      `Tone: ${this.getToneModifier(profile.preferredTone)}`,\n    ];\n\n    return parts.join('\\n');\n  }\n\n  /**\n   * Get default profile for users who skipped profile setup\n   */\n  getDefaultProfile(): PlayerProfile {\n    return {\n      hintStyle: 'Balanced',\n      playerFocus: 'Strategist',\n      preferredTone: 'Professional',\n      spoilerTolerance: 'Strict',\n    };\n  }\n}\n\nexport const profileAwareTabService = ProfileAwareTabService.getInstance();\n\n","import { Conversation, User, PlayerProfile } from '../types';\r\nimport { profileAwareTabService } from './profileAwareTabService';\r\n\r\n// OTAKON tag definitions for the AI\r\nconst OTAKON_TAG_DEFINITIONS = `\r\nYou MUST use the following tags to structure your response. Do not put them in a code block.\r\n- [OTAKON_GAME_ID: Game Name]: The full, official name of the game you've identified.\r\n- [OTAKON_CONFIDENCE: high|low]: Your confidence in the game identification.\r\n- [OTAKON_GENRE: Genre]: The primary genre of the identified game. Must be one of:\r\n  â€¢ Action RPG - Action-focused RPGs with real-time combat (Dark Souls, God of War, etc.)\r\n  â€¢ RPG - Traditional role-playing games with deep stories and character progression\r\n  â€¢ Souls-like - Challenging action games inspired by Dark Souls (Elden Ring, Sekiro, Hollow Knight, etc.)\r\n  â€¢ Metroidvania - Non-linear exploration platformers with ability-gated progression\r\n  â€¢ Open-World - Large open-world games with exploration focus (GTA, Zelda: BOTW, etc.)\r\n  â€¢ Survival-Crafting - Survival games with resource gathering and crafting mechanics\r\n  â€¢ First-Person Shooter - FPS games\r\n  â€¢ Strategy - Strategy and tactical games (RTS, turn-based, 4X)\r\n  â€¢ Adventure - Story-driven adventure and narrative games\r\n  â€¢ Simulation - Simulation and management games\r\n  â€¢ Sports - Sports games and sports management sims\r\n  â€¢ Multiplayer Shooter - Competitive multiplayer FPS games\r\n  â€¢ Multiplayer Sports - Competitive multiplayer sports games\r\n  â€¢ Racing - Racing games and driving sims\r\n  â€¢ Fighting - Fighting games\r\n  â€¢ Battle Royale - Battle royale games\r\n  â€¢ MMORPG - Massively multiplayer online RPGs\r\n  â€¢ Puzzle - Puzzle games\r\n  â€¢ Horror - Horror and survival horror games\r\n  â€¢ Default - Use this only if none of the above genres fit\r\n  **Important**: Use the EXACT genre names listed above. Choose the MOST SPECIFIC genre that fits the game.\r\n- [OTAKON_GAME_STATUS: unreleased]: ONLY include this tag if the game is NOT YET RELEASED. Verify the release date before including this tag.\r\n- [OTAKON_IS_FULLSCREEN: true|false]: Whether the screenshot shows fullscreen gameplay (not menus, launchers, or non-game screens).\r\n- [OTAKON_TRIUMPH: {\"type\": \"boss_defeated\", \"name\": \"Boss Name\"}]: When analyzing a victory screen.\r\n- [OTAKON_OBJECTIVE_SET: {\"description\": \"New objective\"}]: When a new player objective is identified.\r\n- [OTAKON_INSIGHT_UPDATE: {\"id\": \"sub_tab_id\", \"content\": \"content\"}]: To update a specific sub-tab.\r\n- [OTAKON_INSIGHT_MODIFY_PENDING: {\"id\": \"sub_tab_id\", \"title\": \"New Title\", \"content\": \"New content\"}]: When user asks to modify a subtab via @command.\r\n- [OTAKON_INSIGHT_DELETE_REQUEST: {\"id\": \"sub_tab_id\"}]: When user asks to delete a subtab via @command.\r\n- [OTAKON_SUGGESTIONS: [\"suggestion1\", \"suggestion2\", \"suggestion3\"]]: Three contextual follow-up prompts for the user. Make these short, specific questions that help the user learn more about the current situation, get tips, or understand what to do next.\r\n`;\r\n\r\n// Command Centre instructions for subtab management\r\nconst COMMAND_CENTRE_INSTRUCTIONS = `\r\n**Command Centre - Subtab Management:**\r\nUsers can manage subtabs using @ commands:\r\n1. **@<tab_name> <instruction>**: Update a subtab with new information\r\n   - Example: \"@story_so_far The player just defeated the first boss\"\r\n   - Response: Include [OTAKON_INSIGHT_UPDATE: {\"id\": \"story_so_far\", \"content\": \"The player has...[updated content based on instruction]\"}]\r\n   \r\n2. **@<tab_name> \\\\modify**: Modify or rename a subtab\r\n   - Example: \"@tips \\\\modify change this to combat strategies\"\r\n   - Response: Include [OTAKON_INSIGHT_MODIFY_PENDING: {\"id\": \"tips\", \"title\": \"Combat Strategies\", \"content\": \"[updated content]\"}]\r\n   \r\n3. **@<tab_name> \\\\delete**: Delete a subtab\r\n   - Example: \"@unused_tab \\\\delete\"\r\n   - Response: Include [OTAKON_INSIGHT_DELETE_REQUEST: {\"id\": \"unused_tab\"}] and acknowledge the deletion\r\n\r\nWhen you see an @ command:\r\n- Acknowledge the command in your response (\"I've updated the [tab name] tab...\")\r\n- Include the appropriate OTAKON tag to execute the action\r\n- Provide confirmation of what was changed\r\n`;\r\n\r\nconst getGeneralAssistantPrompt = (userMessage: string): string => {\r\n  return `\r\n**Persona: General Gaming Assistant**\r\nYou are Otagon, a helpful and knowledgeable AI gaming assistant for the \"Game Hub\" tab.\r\n\r\n**CRITICAL: Use Real Information**\r\n- Today's date is ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}\r\n- You have access to Google Search grounding for current information\r\n- ALWAYS cite specific game titles, release dates, and accurate details from web search results\r\n- NEVER use placeholders like \"[Hypothetical Game A]\" or \"[Insert Today's Date]\"\r\n- For questions about recent releases, new updates, or announcements, use the grounded web search data\r\n- Your knowledge cutoff is January 2025 - use web search for anything after that date\r\n- Always provide specific, real game titles and accurate information\r\n\r\n**Task:**\r\n1. Thoroughly answer the user's query: \"${userMessage}\".\r\n2. If the query is about a SPECIFIC RELEASED GAME that the user mentions by name, you MUST include these tags:\r\n   - [OTAKON_GAME_ID: Full Game Name] - The complete, official name of the game\r\n   - [OTAKON_CONFIDENCE: high|low] - Your confidence in the identification\r\n   - [OTAKON_GENRE: Genre] - The primary genre (e.g., Action RPG, FPS, Strategy)\r\n   - [OTAKON_GAME_STATUS: unreleased] - ONLY if the game is NOT YET RELEASED\r\n3. Provide three relevant suggested prompts using the [OTAKON_SUGGESTIONS] tag.\r\n\r\n**IMPORTANT - When to use game tags:**\r\nâœ… User asks: \"How do I beat the first boss in Elden Ring?\" â†’ Include [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG]\r\nâœ… User asks: \"What's the best build for Cyberpunk 2077?\" â†’ Include [OTAKON_GAME_ID: Cyberpunk 2077] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG]\r\nâŒ User asks: \"What's a good RPG to play?\" â†’ NO game tags (general question)\r\nâŒ User asks: \"Tell me about open world games\" â†’ NO game tags (general question)\r\n\r\n**Tag Definitions:**\r\n${OTAKON_TAG_DEFINITIONS}\r\n\r\n**Response Style:**\r\n- Be helpful and knowledgeable about gaming\r\n- Keep responses concise but informative\r\n- Use gaming terminology appropriately\r\n- For game-specific queries, start with \"Hint:\" and provide actionable advice\r\n- Focus on useful information, not obvious descriptions\r\n- Make responses engaging and immersive\r\n`;\r\n};\r\n\r\nconst getGameCompanionPrompt = (\r\n  conversation: Conversation, \r\n  userMessage: string, \r\n  user: User, \r\n  isActiveSession: boolean,\r\n  playerProfile?: PlayerProfile\r\n): string => {\r\n  // Gather subtab context\r\n  const subtabContext = conversation.subtabs\r\n    ?.filter(tab => tab.status === 'loaded' && tab.content)\r\n    .map(tab => `### ${tab.title} (ID: ${tab.id})\\n${tab.content}`)\r\n    .join('\\n\\n') || 'No subtabs available yet.';\r\n\r\n  // Gather recent conversation history (last 10 messages for better context)\r\n  const recentMessages = conversation.messages\r\n    .slice(-10)\r\n    .map(m => `${m.role === 'user' ? 'User' : 'Otagon'}: ${m.content}`)\r\n    .join('\\n');\r\n\r\n  // Include historical context summary if available\r\n  const historicalContext = conversation.contextSummary\r\n    ? `**Historical Context (Previous Sessions):**\\n${conversation.contextSummary}\\n\\n`\r\n    : '';\r\n\r\n  // Get player profile context if available\r\n  const profile = playerProfile || profileAwareTabService.getDefaultProfile();\r\n  const profileContext = profileAwareTabService.buildProfileContext(profile);\r\n\r\n  return `\r\n**Persona: Game Companion**\r\nYou are Otagon, an immersive AI companion for the game \"${conversation.gameTitle}\".\r\nThe user's spoiler preference is: \"${user.preferences?.spoilerPreference || 'none'}\".\r\nThe user's current session mode is: ${isActiveSession ? 'ACTIVE (currently playing)' : 'PLANNING (not playing)'}.\r\n\r\n**Web Search Grounding Available:**\r\n- You have access to Google Search for current information about this game\r\n- Use web search for: patch notes, updates, DLC announcements, strategy guides, wiki information\r\n- Your knowledge cutoff is January 2025 - use grounding for recent game updates or patches\r\n- Always cite specific sources when using grounded information\r\n\r\n**Game Context:**\r\n- Game: ${conversation.gameTitle} (${conversation.genre})\r\n- Current Objective: ${conversation.activeObjective || 'Not set'}\r\n- Game Progress: ${conversation.gameProgress || 0}%\r\n\r\n**Player Profile:**\r\n${profileContext}\r\n\r\n**Current Subtabs (Your Knowledge Base):**\r\n${subtabContext}\r\n\r\n${historicalContext}**Recent Conversation History:**\r\n${recentMessages}\r\n\r\n**User Query:** \"${userMessage}\"\r\n\r\n**Task:**\r\n1. Respond to the user's query in an immersive, in-character way that matches the tone of the game.\r\n2. Use the subtab context above to provide informed, consistent answers.\r\n3. **IMPORTANT: Adapt your response style based on the Player Profile above.**\r\n4. If the query provides new information, update relevant subtabs using [OTAKON_INSIGHT_UPDATE].\r\n5. If the query implies progress, identify new objectives using [OTAKON_OBJECTIVE_SET].\r\n6. ${isActiveSession ? 'Provide concise, actionable advice for immediate use.' : 'Provide more detailed, strategic advice for planning.'}\r\n7. Generate three contextual suggested prompts using the [OTAKON_SUGGESTIONS] tag.\r\n\r\n${COMMAND_CENTRE_INSTRUCTIONS}\r\n\r\n**Suggestions Guidelines:**\r\nGenerate 3 short, specific follow-up questions that help the user:\r\n- Get immediate help with their current situation\r\n- Learn more about game mechanics or story elements\r\n- Get strategic advice for their next steps\r\n- Understand character motivations or plot points\r\n- Explore related game content or areas\r\n\r\nExamples of good suggestions:\r\n- \"What's the best strategy for this boss?\"\r\n- \"Tell me more about this character's backstory\"\r\n- \"What should I do next in this area?\"\r\n- \"How do I unlock this feature?\"\r\n- \"What items should I prioritize here?\"\r\n\r\n**Tag Definitions:**\r\n${OTAKON_TAG_DEFINITIONS}\r\n\r\n**Response Style:**\r\n- Match the tone and atmosphere of ${conversation.gameTitle}\r\n- Be spoiler-free beyond current progress\r\n- Provide practical, actionable advice\r\n- Use game-specific terminology and references\r\n- Start with \"Hint:\" for game-specific queries\r\n- Include lore and story context appropriate to player's progress\r\n- When updating subtabs, seamlessly integrate the update into your response\r\n`;\r\n};\r\n\r\nconst getScreenshotAnalysisPrompt = (\r\n  _conversation: Conversation, \r\n  userMessage: string, \r\n  _user: User,\r\n  playerProfile?: PlayerProfile\r\n): string => {\r\n  // Get player profile context if available\r\n  const profile = playerProfile || profileAwareTabService.getDefaultProfile();\r\n  const profileContext = profileAwareTabService.buildProfileContext(profile);\r\n\r\n  return `\r\n**Persona: Game Lore Expert & Screenshot Analyst**\r\nYou are Otagon, an expert at analyzing game visuals and providing immersive, lore-rich assistance.\r\n\r\n**Player Profile:**\r\n${profileContext}\r\n\r\n**Task:**\r\n1. Analyze the screenshot to identify the game\r\n2. **CRITICAL TAG REQUIREMENTS - Include ALL of these tags:**\r\n   - [OTAKON_GAME_ID: Full Game Name] - The complete, official name of the game\r\n   - [OTAKON_CONFIDENCE: high|low] - Your confidence in the identification\r\n   - [OTAKON_GENRE: Genre] - The primary genre (e.g., Action RPG, FPS, Strategy)\r\n   - [OTAKON_IS_FULLSCREEN: true|false] - Is this fullscreen gameplay? (For informational purposes)\r\n   - [OTAKON_GAME_STATUS: unreleased] - ONLY include this if the game is NOT YET RELEASED (verify release date!)\r\n3. Answer: \"${userMessage}\" with focus on game lore, significance, and useful context\r\n4. Provide 3 contextual suggestions using [OTAKON_SUGGESTIONS: [\"suggestion1\", \"suggestion2\", \"suggestion3\"]]\r\n\r\n**Tag Usage Examples:**\r\nâœ… Released game, fullscreen gameplay: [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG] [OTAKON_IS_FULLSCREEN: true]\r\nâœ… Released game, menu screen: [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG] [OTAKON_IS_FULLSCREEN: false]\r\nâœ… Unreleased game: [OTAKON_GAME_ID: GTA VI] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action Adventure] [OTAKON_IS_FULLSCREEN: true] [OTAKON_GAME_STATUS: unreleased]\r\n\r\n**IMPORTANT - Game Tab Creation:**\r\n- ANY screenshot showing a released game (menu or gameplay) will create a dedicated game tab\r\n- This includes main menus, character selection, settings, and gameplay screens\r\n- Only unreleased games or non-game screens (launchers, store pages) stay in \"Game Hub\"\r\n\r\n**What counts as fullscreen gameplay (for IS_FULLSCREEN tag):**\r\n- In-game world exploration\r\n- Combat encounters\r\n- Cutscenes during gameplay\r\n- Active gameplay screens\r\n\r\n**What is NOT fullscreen gameplay (but still creates a game tab if it's a released game):**\r\n- Main menus, settings menus\r\n- Character selection screens\r\n- Loading screens\r\n- Inventory/map screens\r\n\r\n**Response Guidelines:**\r\n- Use the EXACT structure below - do not deviate from this format\r\n- Focus on GAME LORE, SIGNIFICANCE, and USEFUL CONTEXT rather than describing obvious UI elements\r\n- Make the response immersive and engaging\r\n- Avoid describing basic UI elements unless they're relevant to the question\r\n- Make the response feel like you're a knowledgeable game companion, not a UI analyzer\r\n\r\n**MANDATORY FORMAT - Use this exact structure:**\r\nHint: [Game Name] - [Brief, actionable hint about what the player should do or focus on]\r\n\r\nLore: [Rich lore explanation about the current situation, characters, story significance, or world-building context]\r\n\r\nPlaces of Interest: [Nearby locations, shops, NPCs, or areas where the player can find useful items, quests, or important interactions]\r\n\r\n**What to focus on:**\r\n- Story significance and lore implications\r\n- Character relationships and motivations\r\n- Location importance and world-building\r\n- Gameplay mechanics and strategic advice\r\n- Narrative context and plot relevance\r\n- Cultural or thematic elements\r\n\r\n**What to avoid:**\r\n- Describing obvious UI elements (health bars, buttons, etc.)\r\n- Stating the obvious (\"you can see buildings\", \"there's text on screen\")\r\n- Generic descriptions that don't add value\r\n- Deviating from the mandatory format above\r\n\r\n**Genre Classification Confirmation:**\r\nAfter providing your response, if there's ANY ambiguity about the genre classification, add a brief confirmation question:\r\n- Example: \"I've classified this as a Souls-like game. Does that match your understanding, or would you prefer a different categorization?\"\r\n- Example: \"This appears to be an Open-World adventure game. If you think it fits better in another category (like RPG or Action RPG), let me know!\"\r\n- Only include this if the genre could reasonably fit multiple categories\r\n- Keep it brief and natural - don't add it for obvious genre matches like \"Call of Duty = First-Person Shooter\"\r\n\r\n**Suggestions Guidelines:**\r\nGenerate 3 short, specific follow-up questions that help the user:\r\n- Learn more about the current situation or location\r\n- Get tactical advice for what they're seeing\r\n- Understand story implications or character motivations\r\n- Get tips for gameplay mechanics shown in the screenshot\r\n- Explore related game content or areas\r\n\r\nExamples of good suggestions:\r\n- \"What's the significance of this location?\"\r\n- \"How do I handle this type of enemy?\"\r\n- \"What should I do next here?\"\r\n- \"Tell me about this character's backstory\"\r\n- \"What items should I look for in this area?\"\r\n\r\n**Tag Definitions:**\r\n${OTAKON_TAG_DEFINITIONS}\r\n`;\r\n};\r\n\r\n/**\r\n * Determines the correct persona and returns the master prompt.\r\n */\r\nexport const getPromptForPersona = (\r\n  conversation: Conversation,\r\n  userMessage: string,\r\n  user: User,\r\n  isActiveSession: boolean,\r\n  hasImages: boolean,\r\n  playerProfile?: PlayerProfile\r\n): string => {\r\n  if (hasImages) {\r\n    return getScreenshotAnalysisPrompt(conversation, userMessage, user, playerProfile);\r\n  }\r\n  \r\n  if (!conversation.isGameHub && conversation.gameTitle) {\r\n    return getGameCompanionPrompt(conversation, userMessage, user, isActiveSession, playerProfile);\r\n  }\r\n  \r\n  return getGeneralAssistantPrompt(userMessage);\r\n};\r\n","export interface ErrorContext {\n  operation: string;\n  conversationId?: string;\n  userId?: string;\n  timestamp: number;\n  retryCount: number;\n}\n\nexport interface RecoveryAction {\n  type: 'retry' | 'fallback' | 'user_notification' | 'skip';\n  message?: string;\n  action?: () => Promise<void>;\n}\n\nclass ErrorRecoveryService {\n  private retryAttempts = new Map<string, number>();\n  private readonly MAX_RETRIES = 3;\n  private readonly RETRY_DELAYS = [1000, 2000, 4000]; // Progressive delays\n\n  /**\n   * Handle AI service errors with intelligent recovery\n   */\n  async handleAIError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\n    console.error(`ðŸ¤– [ErrorRecovery] AI Error in ${context.operation}:`, error);\n\n    // Check if we should retry\n    if (this.shouldRetry(context)) {\n      const delay = this.getRetryDelay(context.retryCount);\n      console.log(`ðŸ”„ [ErrorRecovery] Retrying ${context.operation} in ${delay}ms`);\n      \n      await this.delay(delay);\n      return {\n        type: 'retry',\n        action: async () => {\n          // The retry will be handled by the calling function\n        }\n      };\n    }\n\n    // Determine fallback action based on error type\n    if (error.message.includes('API key') || error.message.includes('authentication')) {\n      return {\n        type: 'user_notification',\n        message: 'AI service authentication failed. Please check your API key in settings.'\n      };\n    }\n\n    if (error.message.includes('rate limit') || error.message.includes('quota')) {\n      return {\n        type: 'user_notification',\n        message: 'AI service is temporarily busy. Please try again in a few moments.'\n      };\n    }\n\n    if (error.message.includes('network') || error.message.includes('timeout')) {\n      return {\n        type: 'user_notification',\n        message: 'Network connection issue. Please check your internet connection and try again.'\n      };\n    }\n\n    // Generic fallback\n    return {\n      type: 'user_notification',\n      message: 'AI service is temporarily unavailable. Please try again later.'\n    };\n  }\n\n  /**\n   * Handle conversation service errors\n   */\n  async handleConversationError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\n    console.error(`ðŸ’¬ [ErrorRecovery] Conversation Error in ${context.operation}:`, error);\n\n    if (error.message.includes('not found')) {\n      return {\n        type: 'fallback',\n        message: 'Conversation not found. Creating a new one.',\n        action: async () => {\n          // This would be handled by the calling function\n        }\n      };\n    }\n\n    if (error.message.includes('permission') || error.message.includes('unauthorized')) {\n      return {\n        type: 'user_notification',\n        message: 'Permission denied. Please log in again.'\n      };\n    }\n\n    return {\n      type: 'user_notification',\n      message: 'Failed to save conversation. Your data may not be persisted.'\n    };\n  }\n\n  /**\n   * Handle cache service errors\n   */\n  async handleCacheError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\n    console.error(`ðŸ’¾ [ErrorRecovery] Cache Error in ${context.operation}:`, error);\n\n    // Cache errors are usually non-critical, so we can skip\n    return {\n      type: 'skip',\n      message: 'Cache unavailable. Continuing without caching.'\n    };\n  }\n\n  /**\n   * Handle WebSocket connection errors\n   */\n  async handleWebSocketError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\n    console.error(`ðŸ”Œ [ErrorRecovery] WebSocket Error in ${context.operation}:`, error);\n\n    if (this.shouldRetry(context)) {\n      const delay = this.getRetryDelay(context.retryCount);\n      return {\n        type: 'retry',\n        action: async () => {\n          await this.delay(delay);\n          // Retry connection logic would be handled by the calling function\n        }\n      };\n    }\n\n    return {\n      type: 'user_notification',\n      message: 'PC connection lost. Screenshot upload may not be available.'\n    };\n  }\n\n  /**\n   * Check if an operation should be retried\n   */\n  private shouldRetry(context: ErrorContext): boolean {\n    const key = `${context.operation}_${context.conversationId || 'global'}`;\n    const attempts = this.retryAttempts.get(key) || 0;\n    return attempts < this.MAX_RETRIES;\n  }\n\n  /**\n   * Get retry delay based on attempt count\n   */\n  private getRetryDelay(retryCount: number): number {\n    return this.RETRY_DELAYS[Math.min(retryCount, this.RETRY_DELAYS.length - 1)];\n  }\n\n  /**\n   * Increment retry count for an operation\n   */\n  incrementRetryCount(context: ErrorContext): void {\n    const key = `${context.operation}_${context.conversationId || 'global'}`;\n    const current = this.retryAttempts.get(key) || 0;\n    this.retryAttempts.set(key, current + 1);\n  }\n\n  /**\n   * Reset retry count for an operation\n   */\n  resetRetryCount(context: ErrorContext): void {\n    const key = `${context.operation}_${context.conversationId || 'global'}`;\n    this.retryAttempts.delete(key);\n  }\n\n  /**\n   * Utility delay function\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Display user-friendly error message\n   */\n  displayError(message: string, type: 'error' | 'warning' | 'info' = 'error'): void {\n    // In a real app, this would show a toast notification or modal\n    console.log(`[${type.toUpperCase()}] ${message}`);\n    \n    // For now, we'll use a simple alert (in production, use a proper UI component)\n    if (type === 'error') {\n      // Only show critical errors to user\n      console.error('User Error:', message);\n    }\n  }\n\n  /**\n   * Log error for debugging\n   */\n  logError(error: Error, context: ErrorContext, additionalInfo?: any): void {\n    console.error('Error Details:', {\n      error: error.message,\n      stack: error.stack,\n      context,\n      additionalInfo,\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n\nexport const errorRecoveryService = new ErrorRecoveryService();\n","export interface GameTone {\n  adjectives: string[];\n  personality: string;\n  speechPattern: string;\n  loreStyle: string;\n}\n\nexport interface ImmersionContext {\n  gameTitle: string;\n  genre: string;\n  currentLocation?: string;\n  recentEvents?: string[];\n  playerProgress?: number;\n}\n\nclass CharacterImmersionService {\n  private gameTones: Record<string, GameTone> = {\n    'Action RPG': {\n      adjectives: ['epic', 'heroic', 'legendary', 'mystical', 'ancient'],\n      personality: 'wise and experienced adventurer',\n      speechPattern: 'speaks with the wisdom of ages and the thrill of adventure',\n      loreStyle: 'rich with mythology and ancient secrets'\n    },\n    'FPS': {\n      adjectives: ['intense', 'tactical', 'precise', 'combat-ready', 'strategic'],\n      personality: 'battle-hardened soldier',\n      speechPattern: 'communicates with military precision and combat experience',\n      loreStyle: 'focused on warfare, technology, and military history'\n    },\n    'Horror': {\n      adjectives: ['ominous', 'chilling', 'mysterious', 'haunting', 'eerie'],\n      personality: 'knowledgeable survivor',\n      speechPattern: 'speaks with caution and awareness of lurking dangers',\n      loreStyle: 'dark and atmospheric, filled with supernatural elements'\n    },\n    'Puzzle': {\n      adjectives: ['logical', 'methodical', 'analytical', 'clever', 'systematic'],\n      personality: 'brilliant problem-solver',\n      speechPattern: 'explains with clear logic and step-by-step reasoning',\n      loreStyle: 'intellectual and mysterious, focused on patterns and solutions'\n    },\n    'RPG': {\n      adjectives: ['immersive', 'narrative-driven', 'character-focused', 'epic', 'emotional'],\n      personality: 'storyteller and guide',\n      speechPattern: 'speaks like a narrator, weaving tales and character development',\n      loreStyle: 'deep character development and rich storytelling'\n    },\n    'Strategy': {\n      adjectives: ['tactical', 'strategic', 'calculated', 'methodical', 'commanding'],\n      personality: 'master tactician',\n      speechPattern: 'speaks with authority and strategic insight',\n      loreStyle: 'focused on warfare, politics, and grand strategy'\n    },\n    'Adventure': {\n      adjectives: ['exploratory', 'curious', 'adventurous', 'discoverer', 'wanderer'],\n      personality: 'intrepid explorer',\n      speechPattern: 'speaks with wonder and excitement about discovery',\n      loreStyle: 'filled with exploration, discovery, and world-building'\n    },\n    'Default': {\n      adjectives: ['helpful', 'knowledgeable', 'friendly', 'supportive', 'engaging'],\n      personality: 'helpful gaming companion',\n      speechPattern: 'speaks clearly and helpfully',\n      loreStyle: 'focused on gameplay and helpful information'\n    }\n  };\n\n  /**\n   * Get the appropriate tone for a game based on its genre\n   */\n  getGameTone(genre: string): GameTone {\n    return this.gameTones[genre] || this.gameTones['Default'];\n  }\n\n  /**\n   * Generate immersive context for AI prompts\n   */\n  generateImmersionContext(context: ImmersionContext): string {\n    const tone = this.getGameTone(context.genre);\n    \n    let immersionText = `**Immersion Context for ${context.gameTitle}:**\\n`;\n    immersionText += `You are speaking as a ${tone.personality} who ${tone.speechPattern}.\\n`;\n    immersionText += `The game's lore is ${tone.loreStyle}.\\n`;\n    \n    if (context.currentLocation) {\n      immersionText += `The player is currently in: ${context.currentLocation}\\n`;\n    }\n    \n    if (context.recentEvents && context.recentEvents.length > 0) {\n      immersionText += `Recent events: ${context.recentEvents.join(', ')}\\n`;\n    }\n    \n    if (context.playerProgress !== undefined) {\n      immersionText += `Player progress: ${context.playerProgress}%\\n`;\n    }\n    \n    immersionText += `\\n**Response Guidelines:**\\n`;\n    immersionText += `- Use ${tone.adjectives.join(', ')} language\\n`;\n    immersionText += `- Maintain the ${tone.personality} personality\\n`;\n    immersionText += `- Focus on ${tone.loreStyle} elements\\n`;\n    immersionText += `- Keep responses immersive and in-character\\n`;\n    \n    return immersionText;\n  }\n\n  /**\n   * Enhance AI response with game-specific immersion\n   */\n  enhanceResponse(response: string, context: ImmersionContext): string {\n    \n    // Add immersive opening based on game genre\n    let enhancedResponse = response;\n    \n    if (context.genre === 'Horror') {\n      enhancedResponse = `*The shadows seem to whisper as you approach...*\\n\\n${response}`;\n    } else if (context.genre === 'Action RPG') {\n      enhancedResponse = `*The ancient knowledge flows through your mind...*\\n\\n${response}`;\n    } else if (context.genre === 'FPS') {\n      enhancedResponse = `*Mission briefing updated...*\\n\\n${response}`;\n    } else if (context.genre === 'Puzzle') {\n      enhancedResponse = `*The solution becomes clearer...*\\n\\n${response}`;\n    }\n    \n    return enhancedResponse;\n  }\n\n  /**\n   * Get genre-specific suggestions for follow-up questions\n   */\n  getGenreSuggestions(genre: string, _context: ImmersionContext): string[] {\n    \n    const baseSuggestions = [\n      \"Tell me more about this area\",\n      \"What should I do next?\",\n      \"Any tips for this situation?\"\n    ];\n    \n    const genreSpecificSuggestions: Record<string, string[]> = {\n      'Action RPG': [\n        \"What's the lore behind this location?\",\n        \"How do I improve my character?\",\n        \"What quests are available here?\",\n        \"Tell me about the local NPCs\"\n      ],\n      'FPS': [\n        \"What's the best tactical approach?\",\n        \"What weapons work best here?\",\n        \"How do I flank the enemy?\",\n        \"What's the mission objective?\"\n      ],\n      'Horror': [\n        \"What's the history of this place?\",\n        \"How do I survive this area?\",\n        \"What should I be careful of?\",\n        \"Tell me about the local legends\"\n      ],\n      'Puzzle': [\n        \"What's the pattern here?\",\n        \"How do I solve this step by step?\",\n        \"What clues am I missing?\",\n        \"What's the logical approach?\"\n      ],\n      'RPG': [\n        \"Tell me about the story so far\",\n        \"What choices should I make?\",\n        \"How do I develop my character?\",\n        \"What's the significance of this moment?\"\n      ],\n      'Strategy': [\n        \"What's the best strategy here?\",\n        \"How do I manage my resources?\",\n        \"What's the optimal build order?\",\n        \"How do I counter this threat?\"\n      ]\n    };\n    \n    return genreSpecificSuggestions[genre] || baseSuggestions;\n  }\n\n  /**\n   * Create immersive sub-tab content based on genre\n   */\n  createImmersiveSubTabContent(tabType: string, gameTitle: string, genre: string): string {\n    \n    const contentTemplates: Record<string, Record<string, string>> = {\n      'walkthrough': {\n        'Action RPG': `# ${gameTitle} - Walkthrough\\n\\n*The path of the hero unfolds before you...*\\n\\n## Current Objective\\n*Your quest awaits...*\\n\\n## Next Steps\\n*The adventure continues...*`,\n        'FPS': `# ${gameTitle} - Mission Briefing\\n\\n*Mission parameters updated...*\\n\\n## Objective\\n*Target acquired...*\\n\\n## Tactical Approach\\n*Weapons ready...*`,\n        'Horror': `# ${gameTitle} - Survival Guide\\n\\n*The darkness holds many secrets...*\\n\\n## Current Situation\\n*Something stirs in the shadows...*\\n\\n## Survival Tips\\n*Stay alert...*`,\n        'Default': `# ${gameTitle} - Walkthrough\\n\\n## Current Objective\\n*Continue your journey...*\\n\\n## Next Steps\\n*Progress forward...*`\n      },\n      'tips': {\n        'Action RPG': `# ${gameTitle} - Wisdom of the Ages\\n\\n*Ancient knowledge flows through these tips...*\\n\\n## Combat Mastery\\n*Master the blade and magic...*\\n\\n## Exploration Secrets\\n*Hidden treasures await...*`,\n        'FPS': `# ${gameTitle} - Tactical Intelligence\\n\\n*Mission-critical information...*\\n\\n## Weapon Mastery\\n*Know your arsenal...*\\n\\n## Tactical Positioning\\n*Control the battlefield...*`,\n        'Horror': `# ${gameTitle} - Survival Knowledge\\n\\n*The darkness teaches harsh lessons...*\\n\\n## Survival Tactics\\n*Stay alive...*\\n\\n## Environmental Awareness\\n*Trust your instincts...*`,\n        'Default': `# ${gameTitle} - Tips & Tricks\\n\\n## General Tips\\n*Improve your gameplay...*\\n\\n## Advanced Techniques\\n*Master the game...*`\n      }\n    };\n    \n    return contentTemplates[tabType]?.[genre] || contentTemplates[tabType]?.['Default'] || `# ${gameTitle} - ${tabType}\\n\\n*Content loading...*`;\n  }\n}\n\nexport const characterImmersionService = new CharacterImmersionService();\n","import { newsPrompts } from '../types';\n\nclass SuggestedPromptsService {\n  private readonly STORAGE_KEY = 'otakon_used_suggested_prompts';\n  private readonly LAST_RESET_KEY = 'otakon_suggested_prompts_last_reset';\n  private readonly RESET_INTERVAL_MS = 24 * 60 * 60 * 1000; // 24 hours\n  private usedPrompts: Set<string> = new Set();\n\n  constructor() {\n    this.loadUsedPrompts();\n    this.checkAndResetIfNeeded();\n  }\n\n  private loadUsedPrompts(): void {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const prompts = JSON.parse(stored);\n        this.usedPrompts = new Set(prompts);\n      }\n    } catch (error) {\n      console.warn('Failed to load used suggested prompts:', error);\n      this.usedPrompts = new Set();\n    }\n  }\n\n  private saveUsedPrompts(): void {\n    try {\n      const prompts = Array.from(this.usedPrompts);\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(prompts));\n    } catch (error) {\n      console.warn('Failed to save used suggested prompts:', error);\n    }\n  }\n\n  /**\n   * Check if 24 hours have passed since last reset and reset if needed\n   */\n  private checkAndResetIfNeeded(): void {\n    try {\n      const lastResetTime = localStorage.getItem(this.LAST_RESET_KEY);\n      const now = Date.now();\n      \n      if (!lastResetTime || (now - parseInt(lastResetTime)) >= this.RESET_INTERVAL_MS) {\n        console.log('ðŸ”„ 24 hours passed - resetting suggested prompts for fresh daily news');\n        this.resetUsedPrompts();\n        localStorage.setItem(this.LAST_RESET_KEY, now.toString());\n      }\n    } catch (error) {\n      console.warn('Failed to check/reset suggested prompts:', error);\n    }\n  }\n\n  /**\n   * Mark a prompt as used\n   */\n  public markPromptAsUsed(prompt: string): void {\n    this.usedPrompts.add(prompt);\n    this.saveUsedPrompts();\n  }\n\n  /**\n   * Check if a prompt has been used\n   */\n  public isPromptUsed(prompt: string): boolean {\n    return this.usedPrompts.has(prompt);\n  }\n\n  /**\n   * Get all unused prompts from a list\n   */\n  public getUnusedPrompts(prompts: string[]): string[] {\n    return prompts.filter(prompt => !this.isPromptUsed(prompt));\n  }\n\n  /**\n   * Check if all prompts have been used\n   */\n  public areAllPromptsUsed(prompts: string[]): boolean {\n    return prompts.every(prompt => this.isPromptUsed(prompt));\n  }\n\n  /**\n   * Reset used prompts (called on app restart, login, or 24-hour interval)\n   */\n  public resetUsedPrompts(): void {\n    this.usedPrompts.clear();\n    localStorage.removeItem(this.STORAGE_KEY);\n    console.log('ðŸ”„ Suggested prompts reset - all 4 prompts will be available again');\n  }\n\n  /**\n   * Get count of used prompts\n   */\n  public getUsedCount(): number {\n    return this.usedPrompts.size;\n  }\n\n  /**\n   * Get time until next reset (in milliseconds)\n   */\n  public getTimeUntilNextReset(): number {\n    try {\n      const lastResetTime = localStorage.getItem(this.LAST_RESET_KEY);\n      if (!lastResetTime) {\n        return 0;\n      }\n      \n      const nextResetTime = parseInt(lastResetTime) + this.RESET_INTERVAL_MS;\n      return Math.max(0, nextResetTime - Date.now());\n    } catch (error) {\n      console.warn('Failed to calculate time until next reset:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get static news prompts for the \"Game Hub\" tab\n   */\n  public getStaticNewsPrompts(): string[] {\n    // Returns array of 4 news prompts (not shuffled to maintain consistency)\n    return newsPrompts;\n  }\n\n  /**\n   * Process AI-generated suggestions and format them for display\n   */\n  public processAISuggestions(suggestions: any): string[] {\n    console.log('ðŸ” [SuggestedPromptsService] Input suggestions:', suggestions, 'Type:', typeof suggestions);\n    \n    // Handle different types of suggestions\n    if (!suggestions) {\n      console.log('ðŸ” [SuggestedPromptsService] No suggestions provided');\n      return [];\n    }\n    \n    let suggestionsArray: string[] = [];\n    \n    if (Array.isArray(suggestions)) {\n      console.log('ðŸ” [SuggestedPromptsService] Suggestions is already an array');\n      suggestionsArray = suggestions;\n    } else if (typeof suggestions === 'string') {\n      console.log('ðŸ” [SuggestedPromptsService] Suggestions is a string, attempting to parse');\n      \n      // Clean up common formatting issues first\n      let cleanedSuggestions = suggestions.trim();\n      \n      // Fix malformed JSON arrays that start with [\" but might be incomplete\n      if (cleanedSuggestions.startsWith('[\"') && !cleanedSuggestions.endsWith('\"]')) {\n        // Try to fix incomplete JSON arrays\n        if (!cleanedSuggestions.endsWith('\"')) {\n          cleanedSuggestions += '\"';\n        }\n        if (!cleanedSuggestions.endsWith(']')) {\n          cleanedSuggestions += ']';\n        }\n        console.log('ðŸ” [SuggestedPromptsService] Fixed malformed JSON array:', cleanedSuggestions);\n      }\n      \n      // If it's a string, try to parse it as JSON\n      try {\n        // Try to parse as JSON array first\n        const parsed = JSON.parse(cleanedSuggestions);\n        if (Array.isArray(parsed)) {\n          suggestionsArray = parsed;\n          console.log('ðŸ” [SuggestedPromptsService] Successfully parsed as JSON array');\n        } else {\n          suggestionsArray = [suggestions];\n          console.log('ðŸ” [SuggestedPromptsService] Parsed as single value, wrapped in array');\n        }\n      } catch (_e) {\n        console.log('ðŸ” [SuggestedPromptsService] JSON parsing failed, trying delimiter splitting');\n        // If JSON parsing fails, try to split by common delimiters\n        if (cleanedSuggestions.includes('\", \"') || cleanedSuggestions.includes('\",\\n\"')) {\n          // Split by comma and clean up\n          suggestionsArray = cleanedSuggestions\n            .split(/\",\\s*\"/)\n            .map(s => s.replace(/^[\"\\s]+|[\"\\s]+$/g, ''))\n            .filter(s => s.length > 0);\n          console.log('ðŸ” [SuggestedPromptsService] Split by comma delimiters');\n        } else if (cleanedSuggestions.includes('\\n')) {\n          // Split by newlines for multi-line format\n          suggestionsArray = cleanedSuggestions\n            .split('\\n')\n            .map(s => s.replace(/^[\"\\s]+|[\"\\s]+$/g, ''))\n            .filter(s => s.length > 0);\n          console.log('ðŸ” [SuggestedPromptsService] Split by quote delimiters');\n        } else {\n          // Single suggestion\n          suggestionsArray = [suggestions];\n          console.log('ðŸ” [SuggestedPromptsService] Treated as single suggestion');\n        }\n      }\n    }\n    \n    console.log('ðŸ” [SuggestedPromptsService] Raw suggestions array:', suggestionsArray);\n    \n    // Clean and format suggestions\n    const result = suggestionsArray\n      .filter(suggestion => suggestion && typeof suggestion === 'string' && suggestion.trim().length > 0)\n      .map(suggestion => suggestion.trim())\n      .slice(0, 3); // Limit to 3 suggestions\n    \n    console.log('ðŸ” [SuggestedPromptsService] Final processed suggestions:', result);\n    return result;\n  }\n\n  /**\n   * Get fallback suggestions when AI doesn't provide any\n   * Returns news prompts for Game Hub, game-specific prompts for game tabs\n   */\n  public getFallbackSuggestions(conversationId: string, isGameHub?: boolean): string[] {\n    // âœ… Explicit Game Hub check with multiple conditions\n    const isActuallyGameHub = isGameHub === true || \n      conversationId === 'game-hub' || \n      conversationId === 'everything-else';\n    \n    if (isActuallyGameHub) {\n      // Game Hub: Return 4 static news prompts\n      return this.getStaticNewsPrompts();\n    }\n    \n    // âœ… Game-specific tabs: Return contextual game prompts\n    // These prompts work for ANY game (not news-related)\n    return [\n      \"What should I do next in this area?\",\n      \"Tell me about the story so far\",\n      \"Give me some tips for this game\",\n      \"What are the key mechanics I should know?\"\n    ];\n  }\n}\n\nexport const suggestedPromptsService = new SuggestedPromptsService();\n\n","import { Conversation, ChatMessage } from '../types';\n\nexport interface SessionSummary {\n  mode: 'playing' | 'planning';\n  gameTitle: string;\n  conversationId: string;\n  summary: string;\n  keyPoints: string[];\n  objectives: string[];\n  timestamp: number;\n}\n\nclass SessionSummaryService {\n  /**\n   * Generate a summary of a playing session for planning mode\n   */\n  async generatePlayingSessionSummary(conversation: Conversation): Promise<SessionSummary> {\n    const playingMessages = conversation.messages.filter(msg => \n      msg.role === 'assistant' && msg.content.includes('Hint:')\n    );\n\n    const keyPoints = this.extractKeyPoints(playingMessages);\n    const objectives = this.extractObjectives(playingMessages);\n    \n    const summary = `Playing session summary for ${conversation.gameTitle}:\n    \nKey Achievements:\n${keyPoints.map(point => `â€¢ ${point}`).join('\\n')}\n\nCurrent Objectives:\n${objectives.map(obj => `â€¢ ${obj}`).join('\\n')}\n\nRecent Progress:\n${playingMessages.slice(-3).map(msg => `- ${msg.content.substring(0, 100)}...`).join('\\n')}`;\n\n    return {\n      mode: 'playing',\n      gameTitle: conversation.gameTitle || 'Unknown Game',\n      conversationId: conversation.id,\n      summary,\n      keyPoints,\n      objectives,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * Generate a summary of a planning session for playing mode\n   */\n  async generatePlanningSessionSummary(conversation: Conversation): Promise<SessionSummary> {\n    const planningMessages = conversation.messages.filter(msg => \n      msg.role === 'assistant' && !msg.content.includes('Hint:')\n    );\n\n    const keyPoints = this.extractKeyPoints(planningMessages);\n    const objectives = this.extractObjectives(planningMessages);\n    \n    const summary = `Planning session summary for ${conversation.gameTitle}:\n    \nPlanned Strategies:\n${keyPoints.map(point => `â€¢ ${point}`).join('\\n')}\n\nGoals to Achieve:\n${objectives.map(obj => `â€¢ ${obj}`).join('\\n')}\n\nStrategic Notes:\n${planningMessages.slice(-3).map(msg => `- ${msg.content.substring(0, 100)}...`).join('\\n')}`;\n\n    return {\n      mode: 'planning',\n      gameTitle: conversation.gameTitle || 'Unknown Game',\n      conversationId: conversation.id,\n      summary,\n      keyPoints,\n      objectives,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * Extract key points from messages\n   */\n  private extractKeyPoints(messages: ChatMessage[]): string[] {\n    const keyPoints: string[] = [];\n    \n    messages.forEach(msg => {\n      // Look for specific patterns that indicate achievements or important info\n      if (msg.content.includes('defeated') || msg.content.includes('completed')) {\n        keyPoints.push('Achievement unlocked or objective completed');\n      }\n      if (msg.content.includes('found') || msg.content.includes('discovered')) {\n        keyPoints.push('New item or location discovered');\n      }\n      if (msg.content.includes('unlocked') || msg.content.includes('gained')) {\n        keyPoints.push('New ability or feature unlocked');\n      }\n    });\n\n    return keyPoints.length > 0 ? keyPoints : ['Session progress recorded'];\n  }\n\n  /**\n   * Extract objectives from messages\n   */\n  private extractObjectives(messages: ChatMessage[]): string[] {\n    const objectives: string[] = [];\n    \n    messages.forEach(msg => {\n      // Look for objective-related content\n      if (msg.content.includes('objective') || msg.content.includes('goal')) {\n        objectives.push('Continue current objective');\n      }\n      if (msg.content.includes('next') || msg.content.includes('should')) {\n        objectives.push('Follow recommended next steps');\n      }\n      if (msg.content.includes('explore') || msg.content.includes('investigate')) {\n        objectives.push('Explore new areas or investigate leads');\n      }\n    });\n\n    return objectives.length > 0 ? objectives : ['Continue game progression'];\n  }\n\n  /**\n   * Store session summary in conversation\n   */\n  async storeSessionSummary(conversationId: string, summary: SessionSummary): Promise<void> {\n    // Store in conversation metadata or cache\n    // This would integrate with your existing conversation service\n    console.log('Storing session summary for conversation:', conversationId, summary);\n  }\n\n  /**\n   * Get the most recent session summary\n   */\n  async getLatestSessionSummary(conversationId: string): Promise<SessionSummary | null> {\n    // Retrieve from conversation metadata or cache\n    // This would integrate with your existing conversation service\n    console.log('Getting latest session summary for conversation:', conversationId);\n    return null;\n  }\n}\n\nexport const sessionSummaryService = new SessionSummaryService();\n","import { supabase } from '../lib/supabase';\r\nimport { SubTab } from '../types';\r\nimport { FEATURE_FLAGS } from '../constants';\r\nimport { safeString } from '../utils/typeHelpers';\r\n\r\n/**\r\n * SubtabsService - Abstraction layer for subtab storage\r\n * \r\n * Supports both approaches:\r\n * 1. Legacy: conversations.subtabs JSONB array\r\n * 2. Normalized: subtabs table with conversation_id FK and indexes\r\n * \r\n * Toggle via FEATURE_FLAGS.USE_NORMALIZED_SUBTABS\r\n */\r\nexport class SubtabsService {\r\n  private static instance: SubtabsService;\r\n\r\n  static getInstance(): SubtabsService {\r\n    if (!SubtabsService.instance) {\r\n      SubtabsService.instance = new SubtabsService();\r\n    }\r\n    return SubtabsService.instance;\r\n  }\r\n\r\n  /**\r\n   * Get all subtabs for a conversation\r\n   */\r\n  async getSubtabs(conversationId: string): Promise<SubTab[]> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      return this.getSubtabsFromTable(conversationId);\r\n    } else {\r\n      return this.getSubtabsFromJsonb(conversationId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set subtabs for a conversation (replaces all)\r\n   * \r\n   * MIGRATION STRATEGY: During transition period, write to BOTH table AND JSONB\r\n   * to ensure backwards compatibility while normalized table is being adopted\r\n   */\r\n  async setSubtabs(conversationId: string, subtabs: SubTab[]): Promise<boolean> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      console.error(`ðŸ”„ [SubtabsService] Writing ${subtabs.length} subtabs to BOTH table AND JSONB for conversation:`, conversationId);\r\n      \r\n      // Write to normalized table\r\n      const tableSuccess = await this.setSubtabsInTable(conversationId, subtabs);\r\n      console.error(`  âœ… Table write:`, tableSuccess ? 'SUCCESS' : 'FAILED');\r\n      \r\n      // ALSO write to JSONB for backwards compatibility (UI still reads from here)\r\n      const jsonbSuccess = await this.setSubtabsInJsonb(conversationId, subtabs);\r\n      console.error(`  âœ… JSONB write:`, jsonbSuccess ? 'SUCCESS' : 'FAILED');\r\n      \r\n      return tableSuccess && jsonbSuccess;\r\n    } else {\r\n      return this.setSubtabsInJsonb(conversationId, subtabs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single subtab to a conversation\r\n   * \r\n   * MIGRATION STRATEGY: Write to BOTH table AND JSONB during transition\r\n   */\r\n  async addSubtab(conversationId: string, subtab: SubTab): Promise<SubTab | null> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      // Add to normalized table\r\n      const tableResult = await this.addSubtabToTable(conversationId, subtab);\r\n      \r\n      // ALSO add to JSONB for backwards compatibility\r\n      await this.addSubtabToJsonb(conversationId, subtab);\r\n      \r\n      return tableResult;\r\n    } else {\r\n      return this.addSubtabToJsonb(conversationId, subtab);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a subtab in a conversation\r\n   * \r\n   * MIGRATION STRATEGY: Update in BOTH table AND JSONB during transition\r\n   */\r\n  async updateSubtab(\r\n    conversationId: string,\r\n    subtabId: string,\r\n    updates: Partial<SubTab>\r\n  ): Promise<boolean> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      // Update in normalized table\r\n      const tableSuccess = await this.updateSubtabInTable(subtabId, updates);\r\n      \r\n      // ALSO update in JSONB for backwards compatibility\r\n      const jsonbSuccess = await this.updateSubtabInJsonb(conversationId, subtabId, updates);\r\n      \r\n      return tableSuccess && jsonbSuccess;\r\n    } else {\r\n      return this.updateSubtabInJsonb(conversationId, subtabId, updates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a subtab from a conversation\r\n   */\r\n  async deleteSubtab(conversationId: string, subtabId: string): Promise<boolean> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      return this.deleteSubtabFromTable(subtabId);\r\n    } else {\r\n      return this.deleteSubtabFromJsonb(conversationId, subtabId);\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // NORMALIZED SUBTABS TABLE METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get subtabs from normalized subtabs table\r\n   */\r\n  private async getSubtabsFromTable(conversationId: string): Promise<SubTab[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('subtabs')\r\n        .select('*')\r\n        .eq('conversation_id', conversationId)\r\n        .order('order_index', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error getting subtabs from table:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []).map((subtab) => {\r\n        const metadata = typeof subtab.metadata === 'object' && subtab.metadata !== null ? subtab.metadata as Record<string, unknown> : {};\r\n        return {\r\n          id: subtab.id,\r\n          title: subtab.title,\r\n          content: subtab.content || '',\r\n          type: subtab.tab_type as SubTab['type'],\r\n          isNew: (metadata.isNew as boolean) || false,\r\n          status: (metadata.status as SubTab['status']) || 'loaded',\r\n          instruction: metadata.instruction as string | undefined,\r\n        };\r\n      });\r\n    } catch (error) {\r\n      console.error('Error getting subtabs from table:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set subtabs in normalized table (replaces all existing subtabs)\r\n   */\r\n  private async setSubtabsInTable(\r\n    conversationId: string,\r\n    subtabs: SubTab[]\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Delete existing subtabs for this conversation\r\n      const { error: deleteError } = await supabase\r\n        .from('subtabs')\r\n        .delete()\r\n        .eq('conversation_id', conversationId);\r\n\r\n      if (deleteError) {\r\n        console.error('Error deleting existing subtabs:', deleteError);\r\n        return false;\r\n      }\r\n\r\n      // Insert new subtabs\r\n      if (subtabs.length > 0) {\r\n        const subtabsToInsert = subtabs.map((subtab, index) => ({\r\n          id: subtab.id,\r\n          conversation_id: conversationId,\r\n          game_id: null, // Made nullable in schema migration\r\n          title: subtab.title,\r\n          content: subtab.content,\r\n          tab_type: subtab.type,\r\n          order_index: index,\r\n          metadata: {\r\n            isNew: subtab.isNew,\r\n            status: subtab.status,\r\n            instruction: subtab.instruction,\r\n          },\r\n        }));\r\n\r\n        // Types not regenerated yet, but schema migration applied (game_id nullable)\r\n        const { error: insertError } = await supabase\r\n          .from('subtabs')\r\n          .insert(subtabsToInsert as any);\r\n\r\n        if (insertError) {\r\n          console.error('Error inserting subtabs:', insertError);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error setting subtabs in table:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single subtab to the normalized table\r\n   */\r\n  private async addSubtabToTable(\r\n    conversationId: string,\r\n    subtab: SubTab\r\n  ): Promise<SubTab | null> {\r\n    try {\r\n      // Get the conversation to find game_id\r\n      const { data: conversation } = await supabase\r\n        .from('conversations')\r\n        .select('game_id')\r\n        .eq('id', conversationId)\r\n        .single();\r\n\r\n      const gameId = conversation?.game_id || '';\r\n\r\n      // Get current max order_index\r\n      const { data: existingSubtabs } = await supabase\r\n        .from('subtabs')\r\n        .select('order_index')\r\n        .eq('conversation_id', conversationId)\r\n        .order('order_index', { ascending: false })\r\n        .limit(1);\r\n\r\n      const nextOrderIndex = existingSubtabs?.[0]?.order_index ?? -1;\r\n\r\n      const { data, error } = await supabase\r\n        .from('subtabs')\r\n        .insert({\r\n          id: subtab.id,\r\n          conversation_id: conversationId,\r\n          game_id: gameId,\r\n          title: subtab.title,\r\n          content: subtab.content,\r\n          tab_type: subtab.type,\r\n          order_index: nextOrderIndex + 1,\r\n          metadata: {\r\n            isNew: subtab.isNew,\r\n            status: subtab.status,\r\n            instruction: subtab.instruction,\r\n          },\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error adding subtab to table:', error);\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        id: data.id,\r\n        title: data.title,\r\n        content: safeString(data.content),\r\n        type: data.tab_type as SubTab['type'],\r\n        isNew: typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata) \r\n          ? (data.metadata as Record<string, unknown>).isNew as boolean || false\r\n          : false,\r\n        status: (typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata)\r\n          ? (data.metadata as Record<string, unknown>).status as SubTab['status']\r\n          : undefined) || 'loaded',\r\n        instruction: typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata)\r\n          ? (data.metadata as Record<string, unknown>).instruction as string | undefined\r\n          : undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error adding subtab to table:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a subtab in the normalized table\r\n   */\r\n  private async updateSubtabInTable(\r\n    subtabId: string,\r\n    updates: Partial<SubTab>\r\n  ): Promise<boolean> {\r\n    try {\r\n      const dbUpdates: Record<string, unknown> = {};\r\n      \r\n      if (updates.title !== undefined) {\r\n        dbUpdates.title = updates.title;\r\n      }\r\n      if (updates.content !== undefined) {\r\n        dbUpdates.content = updates.content;\r\n      }\r\n      if (updates.type !== undefined) {\r\n        dbUpdates.tab_type = updates.type;\r\n      }\r\n      \r\n      // Handle metadata updates\r\n      if (updates.isNew !== undefined || updates.status !== undefined || updates.instruction !== undefined) {\r\n        // Get current metadata\r\n        const { data: current } = await supabase\r\n          .from('subtabs')\r\n          .select('metadata')\r\n          .eq('id', subtabId)\r\n          .single();\r\n\r\n        const currentMetadata = typeof current?.metadata === 'object' && current?.metadata !== null \r\n          ? (current.metadata as Record<string, unknown>)\r\n          : {};\r\n        \r\n        dbUpdates.metadata = {\r\n          ...currentMetadata,\r\n          ...(updates.isNew !== undefined && { isNew: updates.isNew }),\r\n          ...(updates.status !== undefined && { status: updates.status }),\r\n          ...(updates.instruction !== undefined && { instruction: updates.instruction }),\r\n        };\r\n      }\r\n\r\n      const { error } = await supabase\r\n        .from('subtabs')\r\n        .update(dbUpdates)\r\n        .eq('id', subtabId);\r\n\r\n      if (error) {\r\n        console.error('Error updating subtab in table:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating subtab in table:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a subtab from the normalized table\r\n   */\r\n  private async deleteSubtabFromTable(subtabId: string): Promise<boolean> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('subtabs')\r\n        .delete()\r\n        .eq('id', subtabId);\r\n\r\n      if (error) {\r\n        console.error('Error deleting subtab from table:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting subtab from table:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // LEGACY JSONB METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get subtabs from conversations.subtabs JSONB field\r\n   */\r\n  private async getSubtabsFromJsonb(conversationId: string): Promise<SubTab[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('conversations')\r\n        .select('subtabs')\r\n        .eq('id', conversationId)\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error getting subtabs from JSONB:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data?.subtabs as unknown as SubTab[]) || [];\r\n    } catch (error) {\r\n      console.error('Error getting subtabs from JSONB:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set subtabs in conversations.subtabs JSONB field\r\n   */\r\n  private async setSubtabsInJsonb(\r\n    conversationId: string,\r\n    subtabs: SubTab[]\r\n  ): Promise<boolean> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('conversations')\r\n        .update({\r\n          subtabs: subtabs as unknown as never,\r\n          subtabs_order: subtabs.map((tab) => tab.id) as unknown as never, // Fixed: Use snake_case column name\r\n        })\r\n        .eq('id', conversationId);\r\n\r\n      if (error) {\r\n        console.error('Error setting subtabs in JSONB:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error setting subtabs in JSONB:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single subtab to conversations.subtabs JSONB array\r\n   */\r\n  private async addSubtabToJsonb(\r\n    conversationId: string,\r\n    subtab: SubTab\r\n  ): Promise<SubTab | null> {\r\n    try {\r\n      // Get current subtabs\r\n      const currentSubtabs = await this.getSubtabsFromJsonb(conversationId);\r\n      \r\n      // Add new subtab\r\n      const updatedSubtabs = [...currentSubtabs, subtab];\r\n      \r\n      // Save back\r\n      const success = await this.setSubtabsInJsonb(conversationId, updatedSubtabs);\r\n      \r\n      return success ? subtab : null;\r\n    } catch (error) {\r\n      console.error('Error adding subtab to JSONB:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a subtab in conversations.subtabs JSONB array\r\n   */\r\n  private async updateSubtabInJsonb(\r\n    conversationId: string,\r\n    subtabId: string,\r\n    updates: Partial<SubTab>\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Get current subtabs\r\n      const currentSubtabs = await this.getSubtabsFromJsonb(conversationId);\r\n      \r\n      // Find and update subtab\r\n      const updatedSubtabs = currentSubtabs.map((subtab) =>\r\n        subtab.id === subtabId ? { ...subtab, ...updates } : subtab\r\n      );\r\n      \r\n      // Save back\r\n      return await this.setSubtabsInJsonb(conversationId, updatedSubtabs);\r\n    } catch (error) {\r\n      console.error('Error updating subtab in JSONB:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a subtab from conversations.subtabs JSONB array\r\n   */\r\n  private async deleteSubtabFromJsonb(\r\n    conversationId: string,\r\n    subtabId: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Get current subtabs\r\n      const currentSubtabs = await this.getSubtabsFromJsonb(conversationId);\r\n      \r\n      // Filter out the subtab\r\n      const updatedSubtabs = currentSubtabs.filter((subtab) => subtab.id !== subtabId);\r\n      \r\n      // Save back\r\n      return await this.setSubtabsInJsonb(conversationId, updatedSubtabs);\r\n    } catch (error) {\r\n      console.error('Error deleting subtab from JSONB:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // MIGRATION UTILITIES\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Migrate subtabs from JSONB to normalized table for a specific conversation\r\n   */\r\n  async migrateConversationSubtabs(conversationId: string): Promise<boolean> {\r\n    try {\r\n      // Get subtabs from JSONB\r\n      const subtabs = await this.getSubtabsFromJsonb(conversationId);\r\n\r\n      if (subtabs.length === 0) {\r\n        return true;\r\n      }\r\n\r\n      // Write to normalized table\r\n      const success = await this.setSubtabsInTable(conversationId, subtabs);\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error migrating subtabs:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rollback: Copy subtabs from table back to JSONB for a specific conversation\r\n   */\r\n  async rollbackConversationSubtabs(conversationId: string): Promise<boolean> {\r\n    try {\r\n      // Get subtabs from table\r\n      const subtabs = await this.getSubtabsFromTable(conversationId);\r\n\r\n      if (subtabs.length === 0) {\r\n        return true;\r\n      }\r\n\r\n      // Write to JSONB\r\n      const success = await this.setSubtabsInJsonb(conversationId, subtabs);\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error rolling back subtabs:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch migrate all conversations with subtabs\r\n   */\r\n  async migrateAllSubtabs(): Promise<{ success: number; failed: number }> {\r\n    try {\r\n      // Get all conversations with subtabs\r\n      const { data: conversations, error } = await supabase\r\n        .from('conversations')\r\n        .select('id, subtabs')\r\n        .not('subtabs', 'is', null);\r\n\r\n      if (error) {\r\n        console.error('Error fetching conversations:', error);\r\n        return { success: 0, failed: 0 };\r\n      }\r\n\r\n      let successCount = 0;\r\n      let failedCount = 0;\r\n\r\n      // Process all conversations in parallel for better performance\r\n      const migrationPromises = (conversations || [])\r\n        .filter(conv => conv.subtabs && Array.isArray(conv.subtabs) && conv.subtabs.length > 0)\r\n        .map(conv => this.migrateConversationSubtabs(conv.id));\r\n\r\n      const results = await Promise.allSettled(migrationPromises);\r\n\r\n      results.forEach(result => {\r\n        if (result.status === 'fulfilled' && result.value) {\r\n          successCount++;\r\n        } else {\r\n          failedCount++;\r\n        }\r\n      });\r\n\r\n      return { success: successCount, failed: failedCount };\r\n    } catch (error) {\r\n      console.error('Error in batch migration:', error);\r\n      return { success: 0, failed: 0 };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const subtabsService = SubtabsService.getInstance();\r\n","import { Conversation, SubTab, GameTab, insightTabsConfig, AIResponse, PlayerProfile } from '../types';\nimport { aiService } from './aiService';\nimport { ConversationService } from './conversationService';\nimport { profileAwareTabService, GameContext, ProfileSpecificTab } from './profileAwareTabService';\nimport { toastService } from './toastService';\nimport { subtabsService } from './subtabsService';\n\n// âœ… UUID generator utility\nfunction generateUUID(): string {\n  return globalThis.crypto?.randomUUID() || \n    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n}\n\nexport interface GameTabCreationData {\n  gameTitle: string;\n  genre: string;\n  conversationId: string;\n  userId: string;\n  aiResponse?: AIResponse; // Optional AI response to extract insights from\n  playerProfile?: PlayerProfile; // Optional player profile for personalization\n  gameContext?: GameContext; // Optional game context (playthrough count, etc.)\n  isUnreleased?: boolean; // True for unreleased/upcoming games\n}\n\nclass GameTabService {\n  /**\n   * Create a new game-specific conversation tab (IDEMPOTENT)\n   * If tab already exists, returns it and optionally updates subtabs with new AI insights\n   */\n  async createGameTab(data: GameTabCreationData): Promise<Conversation> {\n    console.log('ðŸŽ® [GameTabService] Creating game tab:', data);\n\n    // âœ… IDEMPOTENT: Check if tab already exists\n    const existingConv = await ConversationService.getConversation(data.conversationId);\n    \n    if (existingConv) {\n      console.log('ðŸŽ® [GameTabService] Tab already exists:', existingConv.title);\n      \n      // âœ… Update subtabs if they're loading and we have new AI response\n      if (data.aiResponse && existingConv.subtabs?.some(tab => tab.status === 'loading' || tab.content === 'Loading...')) {\n        console.log('ðŸŽ® [GameTabService] Updating loading subtabs with new AI insights');\n        const updatedSubtabs = this.extractInsightsFromAIResponse(\n          data.aiResponse, \n          existingConv.subtabs\n        );\n        \n        await ConversationService.updateConversation(existingConv.id, {\n          subtabs: updatedSubtabs,\n          updatedAt: Date.now()\n        });\n        \n        return { ...existingConv, subtabs: updatedSubtabs };\n      }\n      \n      // Return existing tab as-is\n      return existingConv;\n    }\n\n    // Tab doesn't exist - create new one\n    console.log('ðŸŽ® [GameTabService] Creating new tab for:', data.gameTitle);\n    \n    // For unreleased games, don't generate subtabs\n    let subTabs: SubTab[] = [];\n    \n    if (!data.isUnreleased) {\n      if (data.aiResponse) {\n        console.error('ðŸŽ® [GameTabService] Extracting subtabs from AI response');\n        \n        // âœ… PRIORITY 1: Check if AI provided pre-filled subtab content (gamePillData.wikiContent)\n        if (data.aiResponse.gamePillData?.wikiContent && Object.keys(data.aiResponse.gamePillData.wikiContent).length > 0) {\n          console.error('ðŸŽ® [GameTabService] Found gamePillData.wikiContent with', Object.keys(data.aiResponse.gamePillData.wikiContent).length, 'tabs');\n          \n          // Convert wikiContent to SubTab array with proper UUIDs\n          subTabs = Object.entries(data.aiResponse.gamePillData.wikiContent).map(([tabId, content]) => ({\n            id: generateUUID(), // âœ… Generate proper UUID instead of using string tabId\n            title: this.formatTabTitle(tabId),\n            type: this.determineTabType(tabId),\n            content: content,\n            isNew: false,\n            status: 'loaded' as const\n          }));\n          console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'subtabs from gamePillData.wikiContent');\n        }\n        // âœ… PRIORITY 2: Check for progressiveInsightUpdates\n        else if (data.aiResponse.progressiveInsightUpdates && data.aiResponse.progressiveInsightUpdates.length > 0) {\n          console.error('ðŸŽ® [GameTabService] Found progressiveInsightUpdates with', data.aiResponse.progressiveInsightUpdates.length, 'updates');\n          \n          subTabs = data.aiResponse.progressiveInsightUpdates.map(update => ({\n            id: generateUUID(), // âœ… Generate proper UUID\n            title: update.title,\n            type: this.determineTabType(update.tabId),\n            content: update.content,\n            isNew: false,\n            status: 'loaded' as const\n          }));\n          console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'subtabs from progressiveInsightUpdates');\n        }\n        // âœ… PRIORITY 3: Try to extract INSIGHT_UPDATE tags from AI content\n        else {\n          const extractedSubtabs = this.extractInsightsFromAIResponse(data.aiResponse, []);\n          \n          if (extractedSubtabs.length > 0) {\n            subTabs = extractedSubtabs;\n            console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'subtabs from INSIGHT_UPDATE tags');\n          } else {\n            // âœ… FALLBACK: Create template subtabs and populate them via background AI call\n            subTabs = this.generateInitialSubTabs(data.genre || 'Default', data.playerProfile);\n            console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'template subtabs (will populate via background AI using conversation context)');\n          }\n        }\n      } else {\n        // No AI response - create template subtabs\n        subTabs = this.generateInitialSubTabs(data.genre || 'Default', data.playerProfile);\n        console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'initial template subtabs (no AI response)');\n      }\n    } else {\n      console.error('ðŸŽ® [GameTabService] Creating unreleased game tab (no subtabs, Discuss mode only)');\n    }\n    \n    // Create the conversation\n    const conversation: Conversation = {\n      id: data.conversationId,\n      title: data.gameTitle,\n      messages: [],\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      isActive: false,\n      gameId: data.gameTitle.toLowerCase().replace(/\\s+/g, '-'),\n      gameTitle: data.gameTitle,\n      genre: data.genre,\n      subtabs: subTabs,\n      subtabsOrder: subTabs.map(tab => tab.id),\n      isActiveSession: false,\n      activeObjective: '',\n      gameProgress: 0,\n      isUnreleased: data.isUnreleased || false // Mark if unreleased\n    };\n\n    // Save to database\n    await ConversationService.addConversation(conversation);\n\n    // Save subtabs using the subtabsService (handles both JSONB and normalized approaches)\n    if (subTabs.length > 0) {\n      console.error('ðŸŽ® [GameTabService] Saving', subTabs.length, 'subtabs for conversation:', conversation.id);\n      console.error('ðŸŽ® [GameTabService] Subtabs:', JSON.stringify(subTabs, null, 2));\n      await subtabsService.setSubtabs(conversation.id, subTabs);\n    } else {\n      console.error('ðŸŽ® [GameTabService] No subtabs to save for conversation:', conversation.id);\n    }\n\n    // Generate AI insights in background (non-blocking)\n    // Only generate if we didn't already get them from the response\n    if (!data.aiResponse) {\n      this.generateInitialInsights(conversation, data.playerProfile, data.aiResponse).catch(error => \n        console.error('Background insight generation failed:', error)\n      );\n    } else {\n      // If some subtabs still have \"Loading...\" content, generate insights for them in background\n      const needsInsights = conversation.subtabs?.some(tab => tab.content === 'Loading...');\n      if (needsInsights) {\n        // âœ… CRITICAL: Pass aiResponse so the AI has context from the screenshot\n        this.generateInitialInsights(conversation, data.playerProfile, data.aiResponse).catch(error => \n          console.error('Background insight generation failed:', error)\n        );\n      }\n    }\n\n    // Return immediately without waiting for insights\n    return conversation;\n  }\n\n  /**\n   * Generate initial sub-tabs based on game genre and player profile\n   * Note: Currently unused - tab generation now handled via Edge Function\n   */\n  // @ts-ignore - Kept for future reference\n  private generateInitialSubTabs(\n    genre: string,\n    playerProfile?: PlayerProfile,\n    gameContext?: GameContext\n  ): SubTab[] {\n    // Get base genre tabs\n    const config = insightTabsConfig[genre] || insightTabsConfig['Default'];\n    let baseTabs: ProfileSpecificTab[] = config.map(tabConfig => ({\n      ...tabConfig,\n      priority: 'medium' as const,\n      isProfileSpecific: false\n    }));\n    \n    // If player profile exists, add profile-specific tabs\n    if (playerProfile) {\n      console.error('ðŸŽ® [GameTabService] Generating profile-specific tabs for:', playerProfile.playerFocus);\n      const profileTabs = profileAwareTabService.generateProfileSpecificTabs(\n        playerProfile,\n        gameContext\n      );\n      \n      // Merge base tabs with profile-specific tabs\n      baseTabs = [...baseTabs, ...profileTabs];\n      \n      // Prioritize tabs based on profile\n      baseTabs = profileAwareTabService.prioritizeTabsForProfile(baseTabs, playerProfile);\n    }\n    \n    // Convert to SubTab format with proper UUIDs\n    return baseTabs.map(tabConfig => ({\n      id: generateUUID(), // âœ… Generate proper UUID\n      title: tabConfig.title,\n      type: tabConfig.type,\n      content: 'Loading...',\n      isNew: true,\n      status: 'loading' as const,\n      instruction: tabConfig.instruction\n    }));\n  }\n\n  /**\n   * Extract subtab insights from AI response tags\n   * âœ… NEW: Creates subtabs dynamically based on actual AI insights, not templates\n   */\n  private extractInsightsFromAIResponse(aiResponse: AIResponse, existingSubtabs: SubTab[]): SubTab[] {\n    console.error('ðŸ¤– [GameTabService] Extracting dynamic insights from AI response');\n    \n    // Check if AI provided INSIGHT_UPDATE tags\n    const insightUpdates = aiResponse.otakonTags.get('INSIGHT_UPDATE');\n    \n    if (insightUpdates) {\n      console.error('ðŸ¤– [GameTabService] Found INSIGHT_UPDATE:', insightUpdates);\n      \n      // Check if subtab already exists\n      const existingTab = existingSubtabs.find(tab => tab.id === insightUpdates.id);\n      \n      if (existingTab) {\n        // Update existing subtab\n        return existingSubtabs.map(tab => \n          tab.id === insightUpdates.id\n            ? {\n                ...tab,\n                content: insightUpdates.content,\n                isNew: true,\n                status: 'loaded' as const\n              }\n            : tab\n        );\n      } else {\n        // âœ… Create new subtab dynamically with proper UUID\n        const newTab: SubTab = {\n          id: generateUUID(), // âœ… Generate proper UUID\n          title: this.formatTabTitle(insightUpdates.id),\n          type: this.determineTabType(insightUpdates.id),\n          content: insightUpdates.content,\n          isNew: true,\n          status: 'loaded' as const\n        };\n        return [...existingSubtabs, newTab];\n      }\n    }\n    \n    // No specific insight tags - return existing subtabs unchanged\n    return existingSubtabs;\n  }\n\n  /**\n   * Format subtab ID into readable title\n   */\n  private formatTabTitle(tabId: string): string {\n    return tabId\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  /**\n   * Determine tab type based on ID\n   */\n  private determineTabType(tabId: string): 'chat' | 'walkthrough' | 'tips' | 'strategies' | 'story' | 'characters' | 'items' {\n    if (tabId.includes('story')) {\n      return 'story';\n    }\n    if (tabId.includes('character')) {\n      return 'characters';\n    }\n    if (tabId.includes('strategy') || tabId.includes('tips')) {\n      return 'tips';\n    }\n    if (tabId.includes('boss')) {\n      return 'strategies';\n    }\n    if (tabId.includes('quest') || tabId.includes('walkthrough')) {\n      return 'walkthrough';\n    }\n    if (tabId.includes('item')) {\n      return 'items';\n    }\n    return 'chat';\n  }\n\n  /**\n   * Generate initial AI insights for all sub-tabs\n   * This runs in the background and updates the conversation when complete\n   */\n  private async generateInitialInsights(\n    conversation: Conversation,\n    playerProfile?: PlayerProfile,\n    aiResponse?: AIResponse // âœ… NEW: AI response from screenshot analysis\n  ): Promise<void> {\n    console.error('ðŸ¤– [GameTabService] ðŸ”„ Generating initial insights in background for:', conversation.gameTitle);\n\n    try {\n      // âœ… CRITICAL: Use AI response content as context (not conversation.messages which is empty at creation time!)\n      // Priority 1: Use AI response content (from screenshot analysis)\n      // Priority 2: Use conversation messages (if migrated already)\n      let conversationContext = '';\n      \n      if (aiResponse?.content) {\n        conversationContext = `AI Analysis: ${aiResponse.content}`;\n        console.error('ðŸ¤– [GameTabService] Using AI response as context (length:', aiResponse.content.length, ')');\n      } else if (conversation.messages.length > 0) {\n        conversationContext = conversation.messages\n          .map(msg => `${msg.role === 'user' ? 'User' : 'AI'}: ${msg.content}`)\n          .join('\\n\\n');\n        console.error('ðŸ¤– [GameTabService] Using conversation messages as context (count:', conversation.messages.length, ')');\n      } else {\n        console.error('ðŸ¤– [GameTabService] âš ï¸ No context available, will generate generic subtabs');\n      }\n      \n      console.error('ðŸ¤– [GameTabService] Context preview:', conversationContext.substring(0, 200));\n      \n      // Generate insights for each sub-tab (this is the slow AI call)\n      const insights = await aiService.generateInitialInsights(\n        conversation.gameTitle || 'Unknown Game',\n        conversation.genre || 'Action RPG',\n        playerProfile,\n        conversationContext // âœ… Pass actual conversation for context-aware generation\n      );\n\n      // âœ… Check if insights were actually generated (not empty object from error fallback)\n      const hasInsights = insights && Object.keys(insights).length > 0;\n      if (!hasInsights) {\n        console.error('ðŸ¤– [GameTabService] âš ï¸ AI returned empty insights, using fallback content');\n      } else {\n        console.error('ðŸ¤– [GameTabService] âœ… Background insights generated successfully:', Object.keys(insights).length, 'tabs');\n        console.error('ðŸ¤– [GameTabService] Insights keys:', Object.keys(insights));\n        console.error('ðŸ¤– [GameTabService] First insight preview:', Object.values(insights)[0]?.substring(0, 100));\n      }\n\n      // âœ… CRITICAL FIX: Read fresh conversation data from DB before updating\n      // The conversation parameter might be stale (from before message migration)\n      // We need to get the LATEST version with migrated messages\n      const conversations = await ConversationService.getConversations(true); // skipCache = true\n      const freshConversation = conversations[conversation.id];\n      \n      if (!freshConversation) {\n        console.error('ðŸ¤– [GameTabService] Conversation not found:', conversation.id);\n        return;\n      }\n\n      // ðŸ”¥ MAP insight keys to subtab IDs\n      // AI returns keys like \"story_so_far\" but subtabs have UUID ids\n      // We need to map based on subtab type\n      const typeToKeyMap: Record<string, string> = {\n        'story': 'story_so_far',\n        'walkthrough': 'quest_log',\n        'strategies': 'build_optimization', // First strategies tab\n        'tips': 'hidden_paths'\n      };\n      \n      console.error('ðŸ¤– [GameTabService] Building content mapping for subtabs...');\n      \n      // Update sub-tabs with generated content OR meaningful fallback\n      const updatedSubTabs = freshConversation.subtabs?.map(subTab => {\n        let content: string = '';\n        \n        // Map subtab type to insight key\n        const insightKey = typeToKeyMap[subTab.type];\n        \n        // For multiple tabs of same type, use alternate keys\n        if (subTab.type === 'strategies' && subTab.title.includes('Boss')) {\n          const bossKey = 'boss_strategy';\n          if (hasInsights && insights[bossKey]) {\n            content = insights[bossKey];\n            console.error(`ðŸ¤– [GameTabService] Subtab \"${subTab.title}\" using AI content from key \"${bossKey}\" (${content.length} chars)`);\n          }\n        }\n        \n        if (!content && hasInsights && insightKey && insights[insightKey]) {\n          // Use AI-generated content\n          content = insights[insightKey];\n          console.error(`ðŸ¤– [GameTabService] Subtab \"${subTab.title}\" using AI content from key \"${insightKey}\" (${content.length} chars)`);\n        }\n        \n        if (!content) {\n          // âœ… IMPROVED FALLBACK: Use the actual AI response from initial message\n          // The AI already analyzed the screenshot - use that content!\n          \n          // Extract the relevant part from conversation context based on tab type\n          let fallbackContent = conversationContext;\n          \n          // Try to extract specific sections if they exist in the AI response\n          if (subTab.type === 'story' && conversationContext.includes('Lore:')) {\n            const loreMatch = conversationContext.match(/Lore:(.*?)(?=\\n\\n|\\n[A-Z]|$)/s);\n            fallbackContent = loreMatch ? loreMatch[1].trim() : conversationContext;\n          } else if (subTab.type === 'strategies' && conversationContext.includes('Analysis:')) {\n            const analysisMatch = conversationContext.match(/Analysis:(.*?)(?=\\n\\n|\\n[A-Z]|$)/s);\n            fallbackContent = analysisMatch ? analysisMatch[1].trim() : conversationContext;\n          } else if (subTab.type === 'tips' && conversationContext.includes('Hint:')) {\n            const hintMatch = conversationContext.match(/Hint:(.*?)(?=\\n\\n|\\n[A-Z]|$)/s);\n            fallbackContent = hintMatch ? hintMatch[1].trim() : conversationContext;\n          }\n          \n          content = `## ${subTab.title}\\n\\n${fallbackContent}`;\n          \n          console.error(`ðŸ¤– [GameTabService] Subtab \"${subTab.title}\" using fallback content from AI response (${content.length} chars)`);\n          console.error(`ðŸ¤– [GameTabService] Preview:`, content.substring(0, 150) + '...');\n        }\n        \n        return {\n          ...subTab,\n          content,\n          isNew: false,\n          status: 'loaded' as const\n        };\n      }) || [];\n\n      // ðŸ”¥ CRITICAL FIX: Dual-write to both normalized table AND JSONB\n      // The initial subtab creation uses setSubtabs (dual-write), but updates must too!\n      console.error('ðŸ¤– [GameTabService] Updating subtabs with content...');\n      const subtabsDebug = updatedSubTabs.map(s => ({\n        id: s.id,\n        title: s.title,\n        status: s.status,\n        contentLength: s.content?.length || 0,\n        isNew: s.isNew\n      }));\n      console.error('ðŸ¤– [GameTabService] Subtabs to save:', subtabsDebug);\n      console.error('ðŸ¤– [GameTabService] ALL statuses:', updatedSubTabs.map(s => s.status));\n      \n      // âœ… FIX: Clear cache BEFORE write to prevent stale reads during write\n      console.error('ðŸ¤– [GameTabService] ðŸ—‘ï¸ Clearing cache BEFORE subtabs write...');\n      ConversationService.clearCache();\n      \n      await subtabsService.setSubtabs(conversation.id, updatedSubTabs);\n      console.error('ðŸ¤– [GameTabService] âœ… Subtabs dual-write complete (table + JSONB)');\n      \n      // âœ… FIX: Clear cache AGAIN after write\n      ConversationService.clearCache();\n      \n      // âœ… FIX: Wait 500ms to ensure database write fully propagates\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // âœ… VERIFICATION: Read back immediately to confirm write\n      const verifyConversations = await ConversationService.getConversations(true); // skipCache\n      const verifyConv = verifyConversations[conversation.id];\n      if (verifyConv) {\n        console.error('ðŸ¤– [GameTabService] ðŸ” VERIFICATION: Read back subtabs after write:', \n          verifyConv.subtabs?.map(s => ({ title: s.title, status: s.status })) || 'NO SUBTABS');\n      } else {\n        console.error('ðŸ¤– [GameTabService] âš ï¸ VERIFICATION: Could not find conversation after write!');\n      }\n      \n      // Also update conversation metadata (last updated time, etc.)\n      await ConversationService.updateConversation(conversation.id, {\n        updatedAt: Date.now()\n      });\n      console.error('ðŸ¤– [GameTabService] âœ… Conversation metadata updated');\n\n    } catch (error) {\n      console.error('ðŸ¤– [GameTabService] âŒ Failed to generate initial insights:', error);\n      toastService.warning('Failed to load game insights. You can still chat about the game!');\n      \n      // âœ… CRITICAL FIX: Read fresh conversation before updating error state\n      try {\n        const conversations = await ConversationService.getConversations(true); // skipCache = true\n        const freshConversation = conversations[conversation.id];\n        \n        if (!freshConversation) {\n          console.error('ðŸ¤– [GameTabService] Conversation not found for error update:', conversation.id);\n          return;\n        }\n        \n        // Set error state for sub-tabs\n        const errorSubTabs = freshConversation.subtabs?.map(subTab => ({\n          ...subTab,\n          content: `Failed to load ${subTab.title} content. Please try again later.`,\n          isNew: false,\n          status: 'error' as const\n        })) || [];\n\n        // ðŸ”¥ CRITICAL FIX: Dual-write error state too!\n        await subtabsService.setSubtabs(conversation.id, errorSubTabs);\n        await ConversationService.updateConversation(conversation.id, {\n          updatedAt: Date.now()\n        });\n      } catch (updateError) {\n        console.error('ðŸ¤– [GameTabService] Failed to update error state:', updateError);\n      }\n    }\n  }\n\n  /**\n   * Update a specific sub-tab content\n   */\n  async updateSubTabContent(\n    conversationId: string, \n    subTabId: string, \n    content: string\n  ): Promise<void> {\n    console.error('ðŸ“ [GameTabService] Updating sub-tab content:', { conversationId, subTabId });\n\n    try {\n      // Get current conversation\n      const conversations = await ConversationService.getConversations();\n      const conversation = conversations[conversationId];\n      \n      if (!conversation || !conversation.subtabs) {\n        throw new Error('Conversation or sub-tabs not found');\n      }\n\n      // Update the specific sub-tab\n      const updatedSubTabs = conversation.subtabs.map(tab => \n        tab.id === subTabId \n          ? { ...tab, content, isNew: false, status: 'loaded' as const }\n          : tab\n      );\n\n      // ðŸ”¥ CRITICAL FIX: Dual-write for individual subtab updates too!\n      await subtabsService.setSubtabs(conversationId, updatedSubTabs);\n      await ConversationService.updateConversation(conversationId, {\n        updatedAt: Date.now()\n      });\n    } catch (error) {\n      console.error('Failed to update sub-tab content:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get game tab by conversation ID\n   */\n  async getGameTab(conversationId: string): Promise<GameTab | null> {\n    try {\n      const conversations = await ConversationService.getConversations();\n      const conversation = conversations[conversationId];\n      \n      if (!conversation || !conversation.gameTitle) {\n        return null;\n      }\n\n      return {\n        id: conversation.id,\n        title: conversation.title,\n        gameId: conversation.gameId || conversation.gameTitle.toLowerCase().replace(/\\s+/g, '-'),\n        gameTitle: conversation.gameTitle,\n        genre: conversation.genre || 'Unknown',\n        subtabs: conversation.subtabs || [],\n        createdAt: conversation.createdAt,\n        updatedAt: conversation.updatedAt,\n        isActiveSession: conversation.isActiveSession || false\n      };\n    } catch (error) {\n      console.error('Failed to get game tab:', error);\n      toastService.error('Failed to load game tab.');\n      return null;\n    }\n  }\n\n  /**\n   * Check if a conversation is a game tab\n   */\n  isGameTab(conversation: Conversation): boolean {\n    return !conversation.isGameHub && !!conversation.gameTitle;\n  }\n\n  /**\n   * Generate a unique conversation ID for a game\n   * Note: Removed timestamp to ensure consistent IDs for the same game\n   */\n  generateGameConversationId(gameTitle: string): string {\n    const sanitized = gameTitle.toLowerCase().replace(/[^a-z0-9\\s-]/g, '').replace(/\\s+/g, '-');\n    return `game-${sanitized}`;\n  }\n\n  /**\n   * Update subtabs from AI response (progressive updates)\n   * This allows AI to update existing subtabs based on new information\n   */\n  async updateSubTabsFromAIResponse(\n    conversationId: string,\n    updates: Array<{ tabId: string; title: string; content: string }>\n  ): Promise<void> {\n    console.error('ðŸ“ [GameTabService] Updating subtabs from AI response:', { conversationId, updateCount: updates.length });\n\n    try {\n      // Get current conversation\n      const conversations = await ConversationService.getConversations();\n      const conversation = conversations[conversationId];\n      \n      if (!conversation || !conversation.subtabs) {\n        console.warn('ðŸ“ [GameTabService] Conversation or subtabs not found:', conversationId);\n        return;\n      }\n\n      // Update the specific subtabs with linear progression (append, not overwrite)\n      let updatedCount = 0;\n      const updatedSubTabs = conversation.subtabs.map(tab => {\n        const update = updates.find(u => u.tabId === tab.id);\n        if (update) {\n          updatedCount++;\n          console.error('ðŸ“ [GameTabService] Updating subtab:', { tabId: tab.id, title: update.title });\n          \n          // âœ… LINEAR PROGRESSION: Append new content with timestamp separator\n          const timestamp = new Date().toLocaleString();\n          const separator = '\\n\\n---\\n**Updated: ' + timestamp + '**\\n\\n';\n          \n          // Only append if there's existing content (not \"Loading...\")\n          const shouldAppend = tab.content && \n                               tab.content.trim().length > 0 && \n                               tab.content !== 'Loading...' &&\n                               tab.status === 'loaded';\n          \n          const newContent = shouldAppend\n            ? tab.content + separator + update.content  // âœ… Append to existing\n            : update.content;  // First update or loading state\n          \n          return {\n            ...tab,\n            title: update.title || tab.title, // Update title if provided\n            content: newContent,  // âœ… Accumulated history\n            isNew: true, // Mark as new to show indicator\n            status: 'loaded' as const\n          };\n        }\n        return tab;\n      });\n\n      // Only update if something changed\n      if (updatedCount === 0) {\n        console.error('ðŸ“ [GameTabService] No subtabs matched for update');\n        return;\n      }\n\n      // Update conversation with new subtab content\n      await ConversationService.updateConversation(conversationId, {\n        subtabs: updatedSubTabs,\n        updatedAt: Date.now()\n      });\n\n      console.error('ðŸ“ [GameTabService] Successfully updated', updatedCount, 'subtabs');\n    } catch (error) {\n      console.error('ðŸ“ [GameTabService] Failed to update subtabs from AI response:', error);\n      throw error;\n    }\n  }\n}\n\nexport const gameTabService = new GameTabService();\n","import { StorageService } from './storageService';\r\nimport { User, Usage, UserTier } from '../types';\r\nimport { STORAGE_KEYS, TIER_LIMITS, USER_TIERS } from '../constants';\r\nimport { supabase } from '../lib/supabase';\r\nimport { jsonToRecord, safeParseDate, safeNumber } from '../utils/typeHelpers';\r\n\r\nexport class UserService {\r\n  static getCurrentUser(): User | null {\r\n    return StorageService.get(STORAGE_KEYS.USER, null);\r\n  }\r\n\r\n  static setCurrentUser(user: User): void {\r\n    StorageService.set(STORAGE_KEYS.USER, user);\r\n  }\r\n\r\n  static createUser(email: string, tier: UserTier = USER_TIERS.FREE): User {\r\n    const now = Date.now();\r\n    const limits = TIER_LIMITS[tier];\r\n    \r\n    return {\r\n      id: `user_${now}`,\r\n      authUserId: `user_${now}`,\r\n      email,\r\n      tier,\r\n      hasProfileSetup: false,\r\n      hasSeenSplashScreens: false,\r\n      hasSeenHowToUse: false,\r\n      hasSeenFeaturesConnected: false,\r\n      hasSeenProFeatures: false,\r\n      pcConnected: false,\r\n      pcConnectionSkipped: false,\r\n      onboardingCompleted: false,\r\n      hasWelcomeMessage: false,\r\n      isNewUser: true,\r\n      hasUsedTrial: false,\r\n      lastActivity: now,\r\n      preferences: {},\r\n      // Add these required fields from User interface\r\n      textCount: 0,\r\n      imageCount: 0,\r\n      textLimit: limits.text,\r\n      imageLimit: limits.image,\r\n      totalRequests: 0,\r\n      lastReset: now,\r\n      usage: {\r\n        textCount: 0,\r\n        imageCount: 0,\r\n        textLimit: limits.text,\r\n        imageLimit: limits.image,\r\n        totalRequests: 0,\r\n        lastReset: now,\r\n        tier,\r\n      },\r\n      appState: {},\r\n      profileData: {},\r\n      onboardingData: {},\r\n      behaviorData: {},\r\n      feedbackData: {},\r\n      usageData: {},\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n  }\r\n\r\n  static updateUser(updates: Partial<User>): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const updatedUser = {\r\n      ...currentUser,\r\n      ...updates,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    this.setCurrentUser(updatedUser);\r\n  }\r\n\r\n  static updateUsage(usage: Partial<Usage>): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    this.updateUser({\r\n      usage: {\r\n        ...currentUser.usage,\r\n        ...usage,\r\n      },\r\n    });\r\n  }\r\n\r\n  static resetUsage(): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const limits = TIER_LIMITS[currentUser.tier];\r\n    this.updateUsage({\r\n      textCount: 0,\r\n      imageCount: 0,\r\n      totalRequests: 0,\r\n      lastReset: Date.now(),\r\n      textLimit: limits.text,\r\n      imageLimit: limits.image,\r\n    });\r\n  }\r\n\r\n  static canMakeRequest(type: 'text' | 'image'): boolean {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return false;\r\n    }\r\n\r\n    const { usage } = currentUser;\r\n    if (type === 'text') {\r\n      return usage.textCount < usage.textLimit;\r\n    } else {\r\n      return usage.imageCount < usage.imageLimit;\r\n    }\r\n  }\r\n\r\n  static incrementUsage(type: 'text' | 'image'): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const updates: Partial<Usage> = {\r\n      totalRequests: currentUser.usage.totalRequests + 1,\r\n    };\r\n\r\n    if (type === 'text') {\r\n      updates.textCount = currentUser.usage.textCount + 1;\r\n    } else {\r\n      updates.imageCount = currentUser.usage.imageCount + 1;\r\n    }\r\n\r\n    this.updateUsage(updates);\r\n  }\r\n\r\n  static logout(): void {\r\n    StorageService.remove(STORAGE_KEYS.USER);\r\n  }\r\n\r\n  /**\r\n   * âœ… FIX 8: Get current user with Supabase sync\r\n   * Falls back to localStorage if Supabase unavailable\r\n   */\r\n  static async getCurrentUserAsync(): Promise<User | null> {\r\n    try {\r\n      // 1. Check localStorage first (fast path)\r\n      const cached = StorageService.get<User | null>(STORAGE_KEYS.USER, null);\r\n      \r\n      // 2. Get current auth session\r\n      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();\r\n      if (authError || !authUser) {\r\n        return cached;\r\n      }\r\n      \r\n      // 3. Fetch latest from Supabase (source of truth)\r\n      const { data: dbUser, error: dbError } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('auth_user_id', authUser.id)\r\n        .single();\r\n      \r\n      if (dbError || !dbUser) {\r\n        console.error('Failed to fetch user from Supabase:', dbError);\r\n        return cached; // Fallback to cached\r\n      }\r\n      \r\n      // 4. Map database user to User type\r\n      const user: User = {\r\n        id: dbUser.id,\r\n        authUserId: dbUser.auth_user_id,\r\n        email: dbUser.email,\r\n        tier: dbUser.tier as UserTier,\r\n        \r\n        // Query limits from database\r\n        textCount: dbUser.text_count || 0,\r\n        imageCount: dbUser.image_count || 0,\r\n        textLimit: safeNumber(dbUser.text_limit),\r\n        imageLimit: safeNumber(dbUser.image_limit),\r\n        totalRequests: dbUser.total_requests || 0,\r\n        lastReset: safeParseDate(dbUser.last_reset),\r\n        \r\n        // Onboarding flags\r\n        hasProfileSetup: dbUser.has_profile_setup || false,\r\n        hasSeenSplashScreens: dbUser.has_seen_splash_screens || false,\r\n        hasSeenHowToUse: dbUser.has_seen_how_to_use || false,\r\n        hasSeenFeaturesConnected: dbUser.has_seen_features_connected || false,\r\n        hasSeenProFeatures: dbUser.has_seen_pro_features || false,\r\n        pcConnected: dbUser.pc_connected || false,\r\n        pcConnectionSkipped: dbUser.pc_connection_skipped || false,\r\n        onboardingCompleted: dbUser.onboarding_completed || false,\r\n        hasWelcomeMessage: dbUser.has_welcome_message || false,\r\n        isNewUser: dbUser.is_new_user || false,\r\n        hasUsedTrial: dbUser.has_used_trial || false,\r\n        \r\n        // Other fields\r\n        lastActivity: safeParseDate(dbUser.updated_at),\r\n        preferences: jsonToRecord(dbUser.preferences),\r\n        \r\n        // Legacy nested usage (for backward compatibility)\r\n        usage: {\r\n          textCount: dbUser.text_count || 0,\r\n          imageCount: dbUser.image_count || 0,\r\n          textLimit: safeNumber(dbUser.text_limit),\r\n          imageLimit: safeNumber(dbUser.image_limit),\r\n          totalRequests: dbUser.total_requests || 0,\r\n          lastReset: safeParseDate(dbUser.last_reset),\r\n          tier: dbUser.tier as UserTier,\r\n        },\r\n        \r\n        appState: jsonToRecord(dbUser.app_state),\r\n        profileData: jsonToRecord(dbUser.profile_data),\r\n        onboardingData: jsonToRecord(dbUser.onboarding_data),\r\n        behaviorData: jsonToRecord(dbUser.behavior_data),\r\n        feedbackData: jsonToRecord(dbUser.feedback_data),\r\n        usageData: jsonToRecord(dbUser.usage_data),\r\n        \r\n        createdAt: safeParseDate(dbUser.created_at),\r\n        updatedAt: safeParseDate(dbUser.updated_at),\r\n      };\r\n      \r\n      // 5. Update cache\r\n      StorageService.set(STORAGE_KEYS.USER, user);\r\n      \r\n      return user;\r\n    } catch (error) {\r\n      console.error('Error in getCurrentUserAsync:', error);\r\n      // Fallback to cached user\r\n      return StorageService.get<User | null>(STORAGE_KEYS.USER, null);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * âœ… FIX 8: Set current user with Supabase sync\r\n   * Updates localStorage immediately (optimistic update)\r\n   * Syncs to Supabase in background\r\n   */\r\n  static async setCurrentUserAsync(user: User): Promise<void> {\r\n    try {\r\n      // 1. Update localStorage immediately (optimistic update)\r\n      StorageService.set(STORAGE_KEYS.USER, user);\r\n      \r\n      // 2. Sync to Supabase\r\n      const { error } = await supabase\r\n        .from('users')\r\n        .update({\r\n          tier: user.tier,\r\n          text_count: user.textCount,\r\n          image_count: user.imageCount,\r\n          text_limit: user.textLimit,\r\n          image_limit: user.imageLimit,\r\n          total_requests: user.totalRequests,\r\n          last_reset: new Date(user.lastReset).toISOString(),\r\n          \r\n          // Onboarding flags\r\n          has_profile_setup: user.hasProfileSetup,\r\n          has_seen_splash_screens: user.hasSeenSplashScreens,\r\n          has_seen_how_to_use: user.hasSeenHowToUse,\r\n          has_seen_features_connected: user.hasSeenFeaturesConnected,\r\n          has_seen_pro_features: user.hasSeenProFeatures,\r\n          pc_connected: user.pcConnected,\r\n          pc_connection_skipped: user.pcConnectionSkipped,\r\n          onboarding_completed: user.onboardingCompleted,\r\n          has_welcome_message: user.hasWelcomeMessage,\r\n          has_used_trial: user.hasUsedTrial,\r\n          \r\n          // Data objects\r\n          preferences: user.preferences,\r\n          profile_data: user.profileData,\r\n          app_state: user.appState,\r\n          onboarding_data: user.onboardingData,\r\n          behavior_data: user.behaviorData,\r\n          feedback_data: user.feedbackData,\r\n          usage_data: user.usageData,\r\n          \r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('auth_user_id', user.authUserId);\r\n      \r\n      if (error) {\r\n        console.error('Failed to sync user to Supabase:', error);\r\n        // Don't throw - optimistic update already done\r\n        // User will sync on next getCurrentUserAsync()\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in setCurrentUserAsync:', error);\r\n      // Don't throw - localStorage update succeeded\r\n    }\r\n  }\r\n\r\n  /**\r\n   * âœ… FIX 8: Update usage with Supabase sync\r\n   */\r\n  static async updateUsageAsync(usage: Partial<Usage>): Promise<void> {\r\n    const currentUser = await this.getCurrentUserAsync();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const updatedUser = {\r\n      ...currentUser,\r\n      usage: {\r\n        ...currentUser.usage,\r\n        ...usage,\r\n      },\r\n      // Also update top-level fields\r\n      textCount: usage.textCount ?? currentUser.textCount,\r\n      imageCount: usage.imageCount ?? currentUser.imageCount,\r\n      totalRequests: usage.totalRequests ?? currentUser.totalRequests,\r\n      lastReset: usage.lastReset ?? currentUser.lastReset,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    await this.setCurrentUserAsync(updatedUser);\r\n  }\r\n}\r\n\r\n\r\n","import { Conversation, SubTab } from '../types';\n\n/**\n * Tab Management Service (Command Centre)\n * \n * Handles parsing and execution of @ commands for managing subtabs.\n * Based on the old build's Command Centre feature.\n * \n * Command Formats:\n * - @<tab_name> <instruction>: Update tab with new content\n * - @<tab_name> \\modify <instruction>: Modify/rename tab\n * - @<tab_name> \\delete: Delete tab\n */\n\nexport interface TabCommand {\n  type: 'update' | 'modify' | 'delete';\n  tabId: string;\n  tabName: string;\n  instruction: string;\n}\n\nclass TabManagementService {\n  /**\n   * Check if message contains a tab management command\n   */\n  public hasTabCommand(message: string): boolean {\n    // Check for @ followed by word characters\n    return /^@\\w+/.test(message.trim());\n  }\n\n  /**\n   * Parse tab command from user message\n   * Returns null if no valid command found\n   */\n  public parseTabCommand(message: string, conversation: Conversation): TabCommand | null {\n    const trimmedMessage = message.trim();\n    \n    if (!this.hasTabCommand(trimmedMessage)) {\n      return null;\n    }\n\n    // Extract command parts: @<tab_name> [\\\\modify|\\\\delete] [instruction]\n    const commandMatch = trimmedMessage.match(/^@(\\w+)\\s*(\\\\modify|\\\\delete)?\\s*(.*)$/);\n    \n    if (!commandMatch) {\n      return null;\n    }\n\n    const [, tabName, modifier, instruction] = commandMatch;\n    \n    // Find matching subtab (case-insensitive, fuzzy match)\n    const matchingTab = this.findMatchingTab(tabName, conversation.subtabs || []);\n    \n    if (!matchingTab) {\n      console.warn(`Tab \"${tabName}\" not found in conversation`);\n      return null;\n    }\n\n    // Determine command type\n    let commandType: 'update' | 'modify' | 'delete';\n    if (modifier === '\\\\delete') {\n      commandType = 'delete';\n    } else if (modifier === '\\\\modify') {\n      commandType = 'modify';\n    } else {\n      commandType = 'update';\n    }\n\n    return {\n      type: commandType,\n      tabId: matchingTab.id,\n      tabName: matchingTab.title,\n      instruction: instruction.trim()\n    };\n  }\n\n  /**\n   * Find matching subtab by name (fuzzy match)\n   * Handles variations like \"story_so_far\", \"story so far\", \"story\", etc.\n   */\n  private findMatchingTab(searchName: string, subtabs: SubTab[]): SubTab | null {\n    const normalizedSearch = this.normalizeTabName(searchName);\n    \n    // First try exact match\n    let match = subtabs.find(tab => \n      this.normalizeTabName(tab.id) === normalizedSearch ||\n      this.normalizeTabName(tab.title) === normalizedSearch\n    );\n    \n    if (match) {\n      return match;\n    }\n    \n    // Then try partial match (search term is contained in tab name)\n    match = subtabs.find(tab => \n      this.normalizeTabName(tab.id).includes(normalizedSearch) ||\n      this.normalizeTabName(tab.title).includes(normalizedSearch)\n    );\n    \n    if (match) {\n      return match;\n    }\n    \n    // Finally try reversed partial match (tab name is contained in search term)\n    match = subtabs.find(tab => \n      normalizedSearch.includes(this.normalizeTabName(tab.id)) ||\n      normalizedSearch.includes(this.normalizeTabName(tab.title))\n    );\n    \n    return match || null;\n  }\n\n  /**\n   * Normalize tab name for comparison\n   */\n  private normalizeTabName(name: string): string {\n    return name\n      .toLowerCase()\n      .replace(/[_\\s-]+/g, '')  // Remove separators\n      .replace(/[^a-z0-9]/g, ''); // Remove special chars\n  }\n\n  /**\n   * Get available tab names for autocomplete\n   */\n  public getAvailableTabNames(conversation: Conversation): string[] {\n    if (!conversation.subtabs || conversation.subtabs.length === 0) {\n      return [];\n    }\n\n    return conversation.subtabs.map(tab => ({\n      id: tab.id,\n      title: tab.title,\n      // Create multiple search variations\n      variations: [\n        tab.id,\n        tab.title,\n        tab.id.replace(/_/g, ' '),\n        tab.title.toLowerCase()\n      ]\n    }))\n    // Return primary names (tab IDs for consistency)\n    .map(tab => tab.id);\n  }\n\n  /**\n   * Format command for display in autocomplete\n   */\n  public formatTabSuggestion(tabId: string, _tabTitle: string): string {\n    return `@${tabId}`;\n  }\n\n  /**\n   * Get command help text\n   */\n  public getCommandHelp(): string {\n    return `\n**Tab Commands:**\nâ€¢ @<tab> <text> - Update tab with new info\nâ€¢ @<tab> \\\\modify <text> - Modify/rename tab\nâ€¢ @<tab> \\\\delete - Delete tab\n\nExample: @story_so_far The player defeated the first boss\n    `.trim();\n  }\n\n  /**\n   * Validate command before sending to AI\n   */\n  public validateCommand(command: TabCommand): { valid: boolean; error?: string } {\n    switch (command.type) {\n      case 'update':\n        if (!command.instruction) {\n          return { valid: false, error: 'Update command requires content. Example: @story_so_far The player...' };\n        }\n        break;\n      \n      case 'modify':\n        if (!command.instruction) {\n          return { valid: false, error: 'Modify command requires instructions. Example: @tips \\\\modify Change to combat strategies' };\n        }\n        break;\n      \n      case 'delete':\n        // Delete doesn't need instruction\n        break;\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Get user-friendly description of command\n   */\n  public describeCommand(command: TabCommand): string {\n    switch (command.type) {\n      case 'update':\n        return `Updating \"${command.tabName}\" with: ${command.instruction}`;\n      case 'modify':\n        return `Modifying \"${command.tabName}\": ${command.instruction}`;\n      case 'delete':\n        return `Deleting \"${command.tabName}\"`;\n    }\n  }\n}\n\nexport const tabManagementService = new TabManagementService();\n\n","let synth: SpeechSynthesis;\r\nlet voices: SpeechSynthesisVoice[] = [];\r\nlet isInitialized = false;\r\nlet currentText = '';\r\n\r\nconst SPEECH_RATE_KEY = 'otakonSpeechRate';\r\n\r\n// Function to populate voices, returns a promise that resolves when voices are loaded.\r\nconst populateVoiceList = (): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        if (!synth) {\r\n            return reject(new Error(\"Speech synthesis not initialized.\"));\r\n        }\r\n        voices = synth.getVoices();\r\n        if (voices.length > 0) {\r\n            resolve();\r\n            return;\r\n        }\r\n        synth.onvoiceschanged = () => {\r\n            voices = synth.getVoices();\r\n            resolve();\r\n        };\r\n        // Fallback timeout in case onvoiceschanged never fires\r\n        setTimeout(() => {\r\n            if (voices.length === 0) {\r\n                console.warn(\"TTS voices did not load within a reasonable time.\");\r\n                voices = synth.getVoices(); // Try one last time\r\n            }\r\n            resolve();\r\n        }, 1000);\r\n    });\r\n};\r\n\r\nconst cancel = () => {\r\n    if (synth && synth.speaking) {\r\n        synth.cancel();\r\n    }\r\n    currentText = '';\r\n    if ('mediaSession' in navigator && navigator.mediaSession.playbackState !== 'none') {\r\n        navigator.mediaSession.playbackState = 'paused';\r\n    }\r\n    // Dispatch event for UI updates\r\n    window.dispatchEvent(new CustomEvent('otakon:ttsStopped'));\r\n};\r\n\r\nconst pause = () => {\r\n    if (synth && synth.speaking && !synth.paused) {\r\n        synth.pause();\r\n        if ('mediaSession' in navigator) {\r\n            navigator.mediaSession.playbackState = 'paused';\r\n        }\r\n        window.dispatchEvent(new CustomEvent('otakon:ttsPaused'));\r\n    }\r\n};\r\n\r\nconst resume = () => {\r\n    if (synth && synth.paused) {\r\n        synth.resume();\r\n        if ('mediaSession' in navigator) {\r\n            navigator.mediaSession.playbackState = 'playing';\r\n        }\r\n        window.dispatchEvent(new CustomEvent('otakon:ttsResumed'));\r\n    }\r\n};\r\n\r\nconst restart = async () => {\r\n    if (currentText) {\r\n        cancel();\r\n        await speak(currentText);\r\n    }\r\n};\r\n\r\nconst isSpeaking = (): boolean => {\r\n    return synth ? synth.speaking : false;\r\n};\r\n\r\nconst cancelAndDisableHandsFree = () => {\r\n    cancel();\r\n    window.dispatchEvent(new CustomEvent('otakon:disableHandsFree'));\r\n};\r\n\r\nconst setupMediaSession = () => {\r\n    if ('mediaSession' in navigator) {\r\n        navigator.mediaSession.setActionHandler('play', () => { /* Let audio play naturally */ });\r\n        navigator.mediaSession.setActionHandler('pause', cancelAndDisableHandsFree);\r\n        navigator.mediaSession.setActionHandler('stop', cancelAndDisableHandsFree);\r\n    }\r\n};\r\n\r\nconst init = async () => {\r\n    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {\r\n        if (isInitialized) {\r\n          return;\r\n        }\r\n        isInitialized = true;\r\n        synth = window.speechSynthesis;\r\n        await populateVoiceList();\r\n        setupMediaSession();\r\n        // On some browsers (like Chrome on desktop), getVoices() is empty until speak() is called.\r\n        // This empty utterance is a workaround to trigger the onvoiceschanged event.\r\n        if (synth.getVoices().length === 0) {\r\n            synth.speak(new SpeechSynthesisUtterance(''));\r\n        }\r\n    } else {\r\n        console.warn(\"Speech Synthesis not supported in this browser.\");\r\n    }\r\n};\r\n\r\nconst getAvailableVoices = (): SpeechSynthesisVoice[] => {\r\n    return voices.filter(v => v.lang.startsWith('en-'));\r\n};\r\n\r\nconst speak = async (text: string): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (!synth) {\r\n                console.error(\"Text-to-Speech is not available on this browser.\");\r\n                return reject(new Error(\"Text-to-Speech is not available on this browser.\"));\r\n            }\r\n            \r\n            if (!text.trim()) {\r\n                return resolve();\r\n            }\r\n\r\n            cancel(); // Cancel any ongoing speech\r\n\r\n            currentText = text; // Store for restart functionality\r\n            const utterance = new SpeechSynthesisUtterance(text);\r\n            \r\n            const storedRate = localStorage.getItem(SPEECH_RATE_KEY);\r\n            utterance.rate = storedRate ? parseFloat(storedRate) : 0.94; // Use stored rate or default to 94%\r\n            \r\n            const preferredVoiceURI = localStorage.getItem('otakonPreferredVoiceURI');\r\n            \r\n            const availableVoices = getAvailableVoices();\r\n            let voiceToUse: SpeechSynthesisVoice | undefined;\r\n\r\n            if (preferredVoiceURI) {\r\n                voiceToUse = availableVoices.find(v => v.voiceURI === preferredVoiceURI);\r\n            }\r\n            \r\n            // If no preferred voice is set or the saved one is no longer available\r\n            if (!voiceToUse && availableVoices.length > 0) {\r\n                // Prioritize voices with \"Female\" in the name as a default.\r\n                const femaleVoice = availableVoices.find(v => v.name.toLowerCase().includes('female'));\r\n                if (femaleVoice) {\r\n                    voiceToUse = femaleVoice;\r\n                } else {\r\n                    // As a fallback, use the first available voice.\r\n                    voiceToUse = availableVoices[0];\r\n                }\r\n            }\r\n\r\n            if (voiceToUse) {\r\n                utterance.voice = voiceToUse;\r\n            }\r\n\r\n            utterance.onstart = () => {\r\n                if ('mediaSession' in navigator) {\r\n                    navigator.mediaSession.playbackState = 'playing';\r\n                    navigator.mediaSession.metadata = new MediaMetadata({\r\n                        title: 'Otakon Voice Response',\r\n                        artist: 'Your AI Gaming Companion',\r\n                        album: 'Otakon',\r\n                        artwork: [{ src: '/icon.svg', sizes: 'any', type: 'image/svg+xml' }]\r\n                    });\r\n                }\r\n                window.dispatchEvent(new CustomEvent('otakon:ttsStarted'));\r\n            };\r\n\r\n            utterance.onend = () => {\r\n                currentText = '';\r\n                if ('mediaSession' in navigator) {\r\n                    navigator.mediaSession.playbackState = 'paused';\r\n                }\r\n                window.dispatchEvent(new CustomEvent('otakon:ttsStopped'));\r\n                resolve();\r\n            };\r\n            \r\n            utterance.onerror = (e) => {\r\n                console.error(\"SpeechSynthesis Utterance Error\", e);\r\n                cancel();\r\n                reject(e);\r\n            };\r\n\r\n            synth.speak(utterance);\r\n        } catch (error) {\r\n            console.error(\"TTS Error:\", error);\r\n            reject(error);\r\n        }\r\n    });\r\n};\r\n\r\nexport const ttsService = {\r\n    init,\r\n    getAvailableVoices,\r\n    speak,\r\n    cancel,\r\n    pause,\r\n    resume,\r\n    restart,\r\n    isSpeaking,\r\n};\r\n\r\n\r\n","/* eslint-disable no-console */\r\nimport { ConversationService } from './conversationService';\r\nimport { ChatMessage, Conversations } from '../types';\r\n\r\n/**\r\n * Message Routing Service\r\n * Handles atomic message migration between tabs to prevent race conditions\r\n */\r\nexport class MessageRoutingService {\r\n  /**\r\n   * Atomically migrate messages from one conversation to another\r\n   * This prevents race conditions by doing all operations in a single transaction\r\n   */\r\n  static async migrateMessagesAtomic(\r\n    messageIds: string[],\r\n    fromConversationId: string,\r\n    toConversationId: string\r\n  ): Promise<void> {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ“¦ [MessageRouting] Starting atomic migration:', {\r\n        messageIds,\r\n        from: fromConversationId,\r\n        to: toConversationId\r\n      });\r\n    }\r\n\r\n    // âœ… FIX: Use cached data (in-memory) which has the most recent state\r\n    // Including the newly created game tab AND the game-hub with its messages\r\n    // skipCache=true was causing issues because game-hub might not be synced to Supabase yet\r\n    const conversations = await ConversationService.getConversations(false); // Use cache\r\n    \r\n    const fromConv = conversations[fromConversationId];\r\n    const toConv = conversations[toConversationId];\r\n    \r\n    if (!fromConv) {\r\n      console.error('ðŸ“¦ [MessageRouting] Source conversation not found:', fromConversationId);\r\n      console.error('ðŸ“¦ [MessageRouting] Available conversations:', Object.keys(conversations));\r\n      throw new Error(`Source conversation ${fromConversationId} not found`);\r\n    }\r\n    \r\n    if (!toConv) {\r\n      console.error('ðŸ“¦ [MessageRouting] Destination conversation not found:', toConversationId);\r\n      console.error('ðŸ“¦ [MessageRouting] Available conversations:', Object.keys(conversations));\r\n      throw new Error(`Destination conversation ${toConversationId} not found`);\r\n    }\r\n    \r\n    // Get messages to move\r\n    const messagesToMove = fromConv.messages.filter(m => messageIds.includes(m.id));\r\n    \r\n    if (messagesToMove.length === 0) {\r\n      console.warn('âš ï¸ [MessageRouting] No messages found to migrate');\r\n      return;\r\n    }\r\n    \r\n    // Check for duplicates in destination (prevent duplicate messages)\r\n    const messagesToAdd = messagesToMove.filter(msg => \r\n      !toConv.messages.some(existing => existing.id === msg.id)\r\n    );\r\n    \r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ“¦ [MessageRouting] Migration details:', {\r\n        found: messagesToMove.length,\r\n        toAdd: messagesToAdd.length,\r\n        duplicatesSkipped: messagesToMove.length - messagesToAdd.length\r\n      });\r\n    }\r\n    \r\n    // ATOMIC UPDATE: Modify both conversations in a single object\r\n    const updatedConversations: Conversations = {\r\n      ...conversations,\r\n      [toConversationId]: {\r\n        ...toConv,\r\n        messages: [...toConv.messages, ...messagesToAdd],\r\n        updatedAt: Date.now()\r\n      },\r\n      [fromConversationId]: {\r\n        ...fromConv,\r\n        messages: fromConv.messages.filter(m => !messageIds.includes(m.id)),\r\n        updatedAt: Date.now()\r\n      }\r\n    };\r\n    \r\n    // Single write operation\r\n    await ConversationService.setConversations(updatedConversations);\r\n    \r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('âœ… [MessageRouting] Migration complete:', {\r\n        migrated: messagesToAdd.length,\r\n        fromMessages: updatedConversations[fromConversationId].messages.length,\r\n        toMessages: updatedConversations[toConversationId].messages.length\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a message should be routed to a different tab based on game detection\r\n   */\r\n  static shouldRouteMessage(\r\n    currentTabId: string,\r\n    targetGameTabId: string | null,\r\n    isGameHub: boolean\r\n  ): boolean {\r\n    // Don't route if no target game detected\r\n    if (!targetGameTabId) {\r\n      return false;\r\n    }\r\n    \r\n    // Don't route if already in the target tab\r\n    if (currentTabId === targetGameTabId) {\r\n      return false;\r\n    }\r\n    \r\n    // Route if currently in Game Hub and game detected\r\n    if (isGameHub && targetGameTabId) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Duplicate check for messages before adding\r\n   */\r\n  static messageExists(messages: ChatMessage[], messageId: string): boolean {\r\n    return messages.some(m => m.id === messageId);\r\n  }\r\n}\r\n","import { Conversation, ChatMessage } from '../types';\r\nimport { aiService } from './aiService';\r\n\r\ninterface SummarizationResult {\r\n  summary: string;\r\n  wordCount: number;\r\n  messagesIncluded: number;\r\n  originalWordCount: number;\r\n}\r\n\r\n/**\r\n * Context Summarization Service\r\n * Keeps conversation context manageable by summarizing message history to 300-word limit\r\n */\r\nclass ContextSummarizationService {\r\n  private readonly MAX_WORDS = 300;\r\n  private readonly RECENT_MESSAGE_COUNT = 8; // Keep last 8 messages unsummarized for context continuity\r\n\r\n  /**\r\n   * Count words in text\r\n   */\r\n  private countWords(text: string): number {\r\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\r\n  }\r\n\r\n  /**\r\n   * Calculate total word count of messages\r\n   */\r\n  private getTotalWordCount(messages: ChatMessage[]): number {\r\n    return messages.reduce((total, msg) => {\r\n      const contentWords = this.countWords(msg.content);\r\n      return total + contentWords;\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Check if conversation needs summarization\r\n   */\r\n  shouldSummarize(conversation: Conversation): boolean {\r\n    if (!conversation.messages || conversation.messages.length <= this.RECENT_MESSAGE_COUNT) {\r\n      return false; // Too few messages to benefit from summarization\r\n    }\r\n\r\n    const totalWords = this.getTotalWordCount(conversation.messages);\r\n    console.log(`ðŸ“Š [ContextSummarization] Total words in conversation: ${totalWords}`);\r\n\r\n    // Summarize if exceeding 3x the target (900 words) to keep context manageable\r\n    return totalWords > this.MAX_WORDS * 3;\r\n  }\r\n\r\n  /**\r\n   * Split messages into \"to summarize\" and \"to keep\"\r\n   */\r\n  private splitMessages(messages: ChatMessage[]): { toSummarize: ChatMessage[]; toKeep: ChatMessage[] } {\r\n    if (messages.length <= this.RECENT_MESSAGE_COUNT) {\r\n      return { toSummarize: [], toKeep: messages };\r\n    }\r\n\r\n    const splitIndex = messages.length - this.RECENT_MESSAGE_COUNT;\r\n    return {\r\n      toSummarize: messages.slice(0, splitIndex),\r\n      toKeep: messages.slice(splitIndex)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a concise summary of older messages\r\n   */\r\n  async summarizeMessages(\r\n    messages: ChatMessage[], \r\n    gameTitle?: string,\r\n    genre?: string\r\n  ): Promise<SummarizationResult> {\r\n    console.log(`ðŸ“ [ContextSummarization] Summarizing ${messages.length} messages`);\r\n\r\n    const originalWordCount = this.getTotalWordCount(messages);\r\n\r\n    // Build context for summarization\r\n    const conversationText = messages\r\n      .map(msg => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)\r\n      .join('\\n\\n');\r\n\r\n    const contextInfo = gameTitle && genre\r\n      ? `This is a conversation about \"${gameTitle}\" (${genre}).`\r\n      : 'This is a general conversation.';\r\n\r\n    const summaryPrompt = `${contextInfo}\r\n\r\nPlease provide a concise summary of the following conversation history. Focus on:\r\n- Key topics discussed\r\n- Important decisions or choices made\r\n- Game progress or story developments (if applicable)\r\n- User preferences or interests mentioned\r\n\r\nKeep the summary under ${this.MAX_WORDS} words while preserving essential context.\r\n\r\nConversation to summarize:\r\n${conversationText}\r\n\r\nProvide ONLY the summary, no additional commentary.`;\r\n\r\n    try {\r\n      // Create a temporary conversation for summarization\r\n      const tempConversation: Conversation = {\r\n        id: 'temp-summary',\r\n        title: 'Summary Request',\r\n        messages: [{ \r\n          id: 'summary-msg-' + Date.now(),\r\n          role: 'user', \r\n          content: summaryPrompt, \r\n          timestamp: Date.now() \r\n        }],\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n        isActive: false,\r\n        isGameHub: false\r\n      };\r\n\r\n      // Get AI summary using getChatResponse\r\n      // Create minimal user object for summarization\r\n      const summaryUser = {\r\n        id: 'system',\r\n        email: 'system@otakon.ai',\r\n        profileData: null\r\n      } as any;\r\n\r\n      const response = await aiService.getChatResponse(\r\n        tempConversation,\r\n        summaryUser,\r\n        summaryPrompt,\r\n        false, // Not active session\r\n        false // No images\r\n      );\r\n\r\n      const summary = response.content.trim();\r\n      const summaryWordCount = this.countWords(summary);\r\n\r\n      console.log(`âœ… [ContextSummarization] Summary generated: ${summaryWordCount} words (reduced from ${originalWordCount})`);\r\n\r\n      return {\r\n        summary,\r\n        wordCount: summaryWordCount,\r\n        messagesIncluded: messages.length,\r\n        originalWordCount\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('âŒ [ContextSummarization] Failed to generate summary:', error);\r\n      \r\n      // Fallback: Create simple concatenated summary\r\n      const fallbackSummary = messages\r\n        .slice(0, 5) // Take first 5 messages\r\n        .map(msg => msg.content.substring(0, 100)) // Truncate each\r\n        .join(' ... ')\r\n        .substring(0, this.MAX_WORDS * 6); // Rough word limit\r\n\r\n      return {\r\n        summary: `[Previous conversation context] ${fallbackSummary}`,\r\n        wordCount: this.countWords(fallbackSummary),\r\n        messagesIncluded: messages.length,\r\n        originalWordCount\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply summarization to conversation\r\n   * Returns updated conversation with summarized history\r\n   */\r\n  async applyContextSummarization(conversation: Conversation): Promise<Conversation> {\r\n    if (!this.shouldSummarize(conversation)) {\r\n      console.log('ðŸ“Š [ContextSummarization] No summarization needed');\r\n      return conversation;\r\n    }\r\n\r\n    console.log('ðŸ”„ [ContextSummarization] Applying context summarization...');\r\n\r\n    const { toSummarize, toKeep } = this.splitMessages(conversation.messages);\r\n\r\n    if (toSummarize.length === 0) {\r\n      return conversation; // Nothing to summarize\r\n    }\r\n\r\n    // Generate summary of older messages\r\n    const summaryResult = await this.summarizeMessages(\r\n      toSummarize,\r\n      conversation.gameTitle,\r\n      conversation.genre\r\n    );\r\n\r\n    // Create summary message\r\n    const summaryMessage: ChatMessage = {\r\n      id: 'summary-' + Date.now(),\r\n      role: 'system',\r\n      content: summaryResult.summary,\r\n      timestamp: toSummarize[toSummarize.length - 1].timestamp,\r\n      metadata: {\r\n        isSummary: true,\r\n        messagesIncluded: summaryResult.messagesIncluded,\r\n        originalWordCount: summaryResult.originalWordCount,\r\n        summaryWordCount: summaryResult.wordCount\r\n      }\r\n    };\r\n\r\n    // Build new message array: [summary] + [recent messages]\r\n    const updatedMessages = [summaryMessage, ...toKeep];\r\n\r\n    // Store text-only summary (max 500 words) for persistence\r\n    const textOnlySummary = summaryResult.summary.replace(/!\\[.*?\\]\\(data:image\\/.*?\\)/g, '');\r\n    const words = textOnlySummary.split(/\\s+/).filter(w => w.length > 0);\r\n    const cappedSummary = words.length > 500 \r\n      ? words.slice(0, 500).join(' ') + '...'\r\n      : textOnlySummary;\r\n\r\n    console.log(`âœ… [ContextSummarization] Context optimized: ${conversation.messages.length} messages â†’ ${updatedMessages.length} (${summaryResult.originalWordCount} words â†’ ${summaryResult.wordCount} + recent)`);\r\n\r\n    return {\r\n      ...conversation,\r\n      messages: updatedMessages,\r\n      contextSummary: cappedSummary,  // Store persistent summary (500 word cap)\r\n      lastSummarizedAt: Date.now(),   // Track when summarization occurred\r\n      updatedAt: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get context-aware message history for AI\r\n   * Ensures context stays under limit before sending to AI\r\n   */\r\n  async getOptimizedContext(conversation: Conversation): Promise<ChatMessage[]> {\r\n    if (!this.shouldSummarize(conversation)) {\r\n      return conversation.messages;\r\n    }\r\n\r\n    const optimizedConversation = await this.applyContextSummarization(conversation);\r\n    return optimizedConversation.messages;\r\n  }\r\n\r\n  /**\r\n   * Estimate if next message will trigger summarization\r\n   */\r\n  willTriggerSummarization(conversation: Conversation): boolean {\r\n    const totalWords = this.getTotalWordCount(conversation.messages);\r\n    // Will trigger if we're at 80% of the threshold\r\n    return totalWords > (this.MAX_WORDS * 3 * 0.8);\r\n  }\r\n}\r\n\r\nexport const contextSummarizationService = new ContextSummarizationService();\r\n"],"names":["CacheService","__publicField","key","value","ttl","cacheType","userId","expires","error","supabase","memoryOnly","memoryItem","supabaseRequest","data","expiresAt","memoryDeleted","now","entries","item","b","context","memory","gameId","user","conversationId","conversation","cacheService","ErrorService","userMessage","operation","time","message","ToastService","listener","type","options","id","toast","index","t","promise","messages","dismiss","result","successMessage","errorMessage","toastService","_OnboardingService","status","profileData","defaultValue","hasSeenSplashScreens","hasSeenHowToUse","hasSeenFeaturesConnected","hasSeenProFeatures","pcConnected","pcConnectionSkipped","step","action","reason","progressError","userError","totalUsers","completedUsers","dropoffData","dropoffByStep","record","eventData","OnboardingService","onboardingService","ws","SERVER_ADDRESS","reconnectAttempts","maxBackoffMs","sendQueue","lastCode","handlers","heartbeatTimer","HEARTBEAT_MS","connect","code","onOpen","onMessage","onError","onClose","fullUrl","e","payload","event","base","jitter","delay","send","disconnect","WaitlistService","email","source","insertData","insertError","existing","checkError","count","stats","entry","StorageService","ChatMemoryService","summary","_userId","chatMemoryService","parseOtakonTags","rawContent","tags","tagRegex","cleanContent","match","tagName","tagValue","_ProfileAwareTabService","profile","gameContext","tabs","hintStyle","instructions","_profile","a","priorityOrder","modifiers","playerFocus","spoilerTolerance","preferredTone","ProfileAwareTabService","profileAwareTabService","OTAKON_TAG_DEFINITIONS","COMMAND_CENTRE_INSTRUCTIONS","getGeneralAssistantPrompt","getGameCompanionPrompt","isActiveSession","playerProfile","subtabContext","_a","tab","recentMessages","m","historicalContext","profileContext","_b","getScreenshotAnalysisPrompt","_conversation","_user","getPromptForPersona","hasImages","ErrorRecoveryService","retryCount","current","ms","resolve","additionalInfo","errorRecoveryService","CharacterImmersionService","genre","tone","immersionText","response","enhancedResponse","_context","baseSuggestions","tabType","gameTitle","contentTemplates","characterImmersionService","SuggestedPromptsService","stored","prompts","lastResetTime","prompt","nextResetTime","newsPrompts","suggestions","suggestionsArray","cleanedSuggestions","parsed","s","suggestion","isGameHub","suggestedPromptsService","SessionSummaryService","playingMessages","msg","keyPoints","objectives","point","obj","planningMessages","sessionSummaryService","_SubtabsService","subtabs","tableSuccess","jsonbSuccess","subtab","tableResult","subtabId","updates","metadata","deleteError","subtabsToInsert","existingSubtabs","nextOrderIndex","safeString","dbUpdates","currentMetadata","updatedSubtabs","conversations","successCount","failedCount","migrationPromises","conv","SubtabsService","subtabsService","generateUUID","c","r","GameTabService","existingConv","ConversationService","subTabs","tabId","content","update","extractedSubtabs","_c","baseTabs","insightTabsConfig","tabConfig","profileTabs","aiResponse","insightUpdates","newTab","word","conversationContext","insights","aiService","hasInsights","freshConversation","typeToKeyMap","updatedSubTabs","subTab","insightKey","bossKey","fallbackContent","loreMatch","analysisMatch","hintMatch","subtabsDebug","verifyConv","errorSubTabs","_d","updateError","subTabId","updatedCount","u","separator","newContent","gameTabService","UserService","STORAGE_KEYS","tier","USER_TIERS","limits","TIER_LIMITS","currentUser","updatedUser","usage","cached","authUser","authError","dbUser","dbError","safeNumber","safeParseDate","jsonToRecord","TabManagementService","trimmedMessage","commandMatch","tabName","modifier","instruction","matchingTab","commandType","searchName","normalizedSearch","name","_tabTitle","command","tabManagementService","synth","voices","isInitialized","currentText","SPEECH_RATE_KEY","populateVoiceList","reject","cancel","pause","resume","restart","speak","isSpeaking","cancelAndDisableHandsFree","setupMediaSession","init","getAvailableVoices","v","text","utterance","storedRate","preferredVoiceURI","availableVoices","voiceToUse","femaleVoice","ttsService","MessageRoutingService","messageIds","fromConversationId","toConversationId","fromConv","toConv","messagesToMove","messagesToAdd","updatedConversations","currentTabId","targetGameTabId","messageId","ContextSummarizationService","total","contentWords","totalWords","splitIndex","originalWordCount","conversationText","summaryPrompt","tempConversation","summaryUser","summaryWordCount","fallbackSummary","toSummarize","toKeep","summaryResult","updatedMessages","textOnlySummary","words","w","cappedSummary","contextSummarizationService"],"mappings":"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"}