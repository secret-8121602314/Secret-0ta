var E=Object.defineProperty;var C=(u,e,t)=>e in u?E(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t;var l=(u,e,t)=>C(u,typeof e!="symbol"?e+"":e,t);import{s as g}from"./auth-BYRgI0hh.js";class I{constructor(){l(this,"memoryCache",new Map);l(this,"DEFAULT_TTL",300*1e3);l(this,"CACHE_TABLE","app_cache");l(this,"MAX_MEMORY_CACHE_SIZE",100);l(this,"pendingRequests",new Map)}async set(e,t,s=this.DEFAULT_TTL,r="general",n){const o=Date.now()+s;this.memoryCache.set(e,{value:t,expires:o});try{const{error:c}=await g.from(this.CACHE_TABLE).upsert({key:e,value:JSON.stringify(t),expires_at:new Date(o).toISOString(),updated_at:new Date().toISOString(),cache_type:r,user_id:n||null,size_bytes:JSON.stringify(t).length});c&&console.debug("[CacheService] Cache write failed:",c.message)}catch{}this.memoryCache.size>this.MAX_MEMORY_CACHE_SIZE&&this.cleanupMemoryCache()}async get(e,t=!1){if(this.pendingRequests.has(e))return await this.pendingRequests.get(e);const s=this.memoryCache.get(e);if(s&&Date.now()<=s.expires)return console.log(`[CacheService] Cache HIT (memory): ${e}`),s.value;if(s&&this.memoryCache.delete(e),t)return console.log(`[CacheService] Cache MISS (memory-only mode): ${e}`),null;const r=this.fetchFromSupabase(e);this.pendingRequests.set(e,r);try{return await r}finally{this.pendingRequests.delete(e)}}async fetchFromSupabase(e){try{console.log(`[CacheService] Cache MISS (memory), trying Supabase: ${e}`);const{data:t,error:s}=await g.from(this.CACHE_TABLE).select("value, expires_at").eq("key",e).maybeSingle();if(s)return null;if(!t)return console.log(`[CacheService] Cache MISS (Supabase): ${e}`),null;const r=new Date(t.expires_at).getTime();if(Date.now()>r)return console.log(`[CacheService] Cache EXPIRED (Supabase): ${e}`),await this.delete(e),null;console.log(`[CacheService] Cache HIT (Supabase): ${e}`);const n=JSON.parse(typeof t.value=="string"?t.value:"{}");return this.memoryCache.set(e,{value:n,expires:r}),n}catch{return null}}async has(e){return await this.get(e)!==null}async delete(e){const t=this.memoryCache.delete(e);try{const{error:s}=await g.from(this.CACHE_TABLE).delete().eq("key",e);s&&console.debug("[CacheService] Delete failed:",s.message)}catch{}return t}async clear(){this.memoryCache.clear(),this.pendingRequests.clear();try{const{error:e}=await g.from(this.CACHE_TABLE).delete().neq("key","never_delete");e&&console.debug("[CacheService] Clear failed:",e.message)}catch{}}async cleanup(){const e=Date.now();this.cleanupMemoryCache();try{const{error:t}=await g.from(this.CACHE_TABLE).delete().lt("expires_at",new Date(e).toISOString());t&&console.debug("[CacheService] Cleanup failed:",t.message)}catch{}}cleanupMemoryCache(){const e=Date.now(),t=Array.from(this.memoryCache.entries());t.forEach(([s,r])=>{e>r.expires&&this.memoryCache.delete(s)}),this.memoryCache.size>this.MAX_MEMORY_CACHE_SIZE&&t.filter(([n])=>this.memoryCache.has(n)).sort((n,o)=>n[1].expires-o[1].expires).slice(0,this.memoryCache.size-this.MAX_MEMORY_CACHE_SIZE).forEach(([n])=>this.memoryCache.delete(n))}getStats(){return{memorySize:this.memoryCache.size,memoryKeys:Array.from(this.memoryCache.keys())}}async getSupabaseStats(){try{const{data:e,error:t}=await g.rpc("get_cache_stats");return t?null:e}catch{return null}}async getPerformanceMetrics(){try{const{data:e,error:t}=await g.rpc("get_cache_performance_metrics");return t?null:e}catch{return null}}async getUserCacheEntries(e){try{const{data:t,error:s}=await g.rpc("get_user_cache_entries",{p_user_id:e});return s?[]:t||[]}catch{return[]}}async clearUserCache(e){try{const{data:t,error:s}=await g.rpc("clear_user_cache",{p_user_id:e});return s?0:t||0}catch{return 0}}async setChatContext(e,t){await this.set(`chat_context:${e}`,t,2160*60*60*1e3,"context",e)}async getChatContext(e){return await this.get(`chat_context:${e}`)}async setUserMemory(e,t){await this.set(`user_memory:${e}`,t,365*24*60*60*1e3,"memory",e)}async getUserMemory(e){return await this.get(`user_memory:${e}`)}async setGameContext(e,t,s){await this.set(`game_context:${e}:${t}`,s,2160*60*60*1e3,"context",e)}async getGameContext(e,t){return await this.get(`game_context:${e}:${t}`)}async setUser(e,t){await this.set(`user:${e}`,t,365*24*60*60*1e3,"user",e)}async getUser(e){return await this.get(`user:${e}`)}async setRateLimit(e,t){await this.set(`rate_limit:${e}`,t,900*1e3,"rate_limit")}async getRateLimit(e){return await this.get(`rate_limit:${e}`)}async setConversation(e,t,s){await this.set(`conversation:${e}`,t,365*24*60*60*1e3,"conversation",s)}async getConversation(e){return await this.get(`conversation:${e}`)}async initializeCacheTable(){try{const{error:e}=await g.from(this.CACHE_TABLE).select("key").limit(1);e&&e.code}catch{}}}const y=new I;y.initializeCacheTable().catch(()=>{});setInterval(()=>{y.cleanup()},300*1e3);const h=class h{constructor(){l(this,"currentSessionId",null);l(this,"sessionStartTime",null);l(this,"activityCount",0);l(this,"heartbeatInterval",null)}static getInstance(){return h.instance||(h.instance=new h),h.instance}async startSession(e,t){try{this.currentSessionId&&await this.endSession();const s={initialRoute:t,activityCount:0,deviceInfo:this.getDeviceInfo()},{data:r,error:n}=await g.from("user_sessions").insert({user_id:e,started_at:new Date().toISOString(),session_data:s}).select("id").single();return n?(console.error("Failed to start session:",n),null):(this.currentSessionId=r.id,this.sessionStartTime=Date.now(),this.activityCount=0,this.startHeartbeat(),this.currentSessionId)}catch(s){return console.error("Error starting session:",s),null}}async endSession(){if(!(!this.currentSessionId||!this.sessionStartTime))try{const e=Math.floor((Date.now()-this.sessionStartTime)/1e3),{error:t}=await g.from("user_sessions").update({ended_at:new Date().toISOString(),duration_seconds:e,session_data:{activityCount:this.activityCount,lastActivity:new Date().toISOString()}}).eq("id",this.currentSessionId);t?console.error("Failed to end session:",t):console.log(`✅ Session ended: ${this.currentSessionId} (${e}s)`),this.stopHeartbeat(),this.currentSessionId=null,this.sessionStartTime=null,this.activityCount=0}catch(e){console.error("Error ending session:",e)}}trackActivity(e){this.currentSessionId&&(this.activityCount++,g.from("user_sessions").update({session_data:{activityCount:this.activityCount,lastActivity:new Date().toISOString(),lastActivityType:e}}).eq("id",this.currentSessionId).then(({error:t})=>{t&&console.error("Failed to track activity:",t)}))}async updateSessionData(e){if(this.currentSessionId)try{const{error:t}=await g.from("user_sessions").update({session_data:e}).eq("id",this.currentSessionId);t&&console.error("Failed to update session data:",t)}catch(t){console.error("Error updating session data:",t)}}getCurrentSessionId(){return this.currentSessionId}getSessionDuration(){return this.sessionStartTime?Math.floor((Date.now()-this.sessionStartTime)/1e3):0}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.trackActivity("heartbeat")},300*1e3)}stopHeartbeat(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null)}getDeviceInfo(){const{userAgent:e}=navigator,t=/Mobile|Android|iPhone|iPad/.test(e),s=/Tablet|iPad/.test(e);let r="desktop";return t&&!s&&(r="mobile"),s&&(r="tablet"),r}cleanup(){this.stopHeartbeat(),this.currentSessionId&&this.endSession().catch(console.error)}};l(h,"instance");let S=h;const M=S.getInstance();typeof window<"u"&&window.addEventListener("beforeunload",()=>{M.cleanup()});class f{static get(e,t){try{const s=localStorage.getItem(e);return s?JSON.parse(s):t}catch(s){return console.error(`Error getting ${e} from localStorage:`,s),t}}static set(e,t){try{const s=JSON.stringify(t);localStorage.setItem(e,s)}catch(s){if(s instanceof DOMException&&s.name==="QuotaExceededError"&&this.handleQuotaExceeded(e,t))try{localStorage.setItem(e,JSON.stringify(t));return}catch{console.error("Failed to save to localStorage after cleanup")}console.error(`Error setting ${e} in localStorage:`,s)}}static remove(e){try{localStorage.removeItem(e)}catch(t){console.error(`Error removing ${e} from localStorage:`,t)}}static clear(){try{localStorage.clear()}catch(e){console.error("Error clearing localStorage:",e)}}static getStorageStats(){let e=0;for(const s in localStorage)Object.prototype.hasOwnProperty.call(localStorage,s)&&(e+=(localStorage[s].length+s.length)*2);const t=5*1024*1024;return{used:e,available:t-e,percentage:e/t}}static handleQuotaExceeded(e,t){const s="otakon_conversations";try{if(e===s){const n=this.trimConversations(t);n!==t&&Object.assign(t,n)}return this.clearOldCacheEntries(),this.getStorageStats().percentage<this.CRITICAL_STORAGE_THRESHOLD}catch(r){return console.error("Error during quota cleanup:",r),!1}}static trimConversations(e){if(!e||typeof e!="object")return e;const t={...e};for(const s of Object.values(t)){const r=s;r!=null&&r.messages&&Array.isArray(r.messages)&&r.messages.length>this.MAX_MESSAGES_PER_CONVERSATION&&(r.messages=r.messages.slice(-this.MAX_MESSAGES_PER_CONVERSATION))}return t}static clearOldCacheEntries(){const e=Object.keys(localStorage);for(const t of e)if(t.startsWith("igdb_")||t.startsWith("cache_"))try{const s=localStorage.getItem(t);if(s){const r=JSON.parse(s),n=Date.now()-(r.timestamp||0),o=10080*60*1e3;n>o&&localStorage.removeItem(t)}}catch{localStorage.removeItem(t)}}}l(f,"MAX_MESSAGES_PER_CONVERSATION",50),l(f,"CRITICAL_STORAGE_THRESHOLD",.9);class w{async generatePlayingSessionSummary(e){const t=e.messages.slice(-10),s=this.extractKeyPointsIntelligent(t,"playing"),r=this.extractObjectivesIntelligent(t,e),n=this.generateProgressContext(e),o=`**Playing Session Summary for ${e.gameTitle}**

${n}

**Session Activity:**
${s.length>0?s.map(c=>`• ${c}`).join(`
`):"• Session progress recorded"}

**Current Objectives:**
${r.length>0?r.map(c=>`• ${c}`).join(`
`):"• Continue progression"}

**Recent Activity:**
${this.extractRecentActivity(t,3)}

*Switching to Planning Mode - Progress saved.*`;return{mode:"playing",gameTitle:e.gameTitle||"Unknown Game",conversationId:e.id,summary:o,keyPoints:s,objectives:r,timestamp:Date.now(),aiGenerated:!0}}async generatePlanningSessionSummary(e){const t=e.messages.slice(-10),s=this.extractKeyPointsIntelligent(t,"planning"),r=this.extractObjectivesIntelligent(t,e),n=this.extractStrategicNotes(t),o=`**Planning Session Summary for ${e.gameTitle}**

**Strategies Discussed:**
${s.length>0?s.map(c=>`• ${c}`).join(`
`):"• No strategies noted this session"}

**Planning Objectives:**
${r.length>0?r.map(c=>`• ${c}`).join(`
`):"• Continue exploration"}

${n?`**Strategic Notes:**
${n}
`:""}
*Switching to Playing Mode - Session ready to begin.*`;return{mode:"planning",gameTitle:e.gameTitle||"Unknown Game",conversationId:e.id,summary:o,keyPoints:s,objectives:r,timestamp:Date.now(),aiGenerated:!0}}generateProgressContext(e){const t=[];return e.gameProgress&&e.gameProgress>0&&t.push(`**Progress:** ${e.gameProgress}%`),e.activeObjective&&t.push(`**Current Focus:** ${e.activeObjective}`),t.length>0?t.join(`
`):"**Progress:** Session in progress"}extractKeyPointsIntelligent(e,t){const s=[],r=new Set,c=t==="playing"?[{pattern:/completed|finished|cleared|resolved/i,template:i=>this.extractContext(i,"task-completion")},{pattern:/found|discovered|obtained|acquired|received/i,template:i=>this.extractContext(i,"discovery")},{pattern:/unlocked|gained|learned|achieved/i,template:i=>this.extractContext(i,"progress")},{pattern:/defeated|overcame|resolved|handled/i,template:i=>this.extractContext(i,"challenge")},{pattern:/reached|arrived|accessed|entered/i,template:i=>this.extractContext(i,"milestone")}]:[{pattern:/build|spec|loadout|equipment/i,template:i=>this.extractContext(i,"build")},{pattern:/strategy|approach|tactic/i,template:i=>this.extractContext(i,"strategy")},{pattern:/should|recommend|best|optimal/i,template:i=>this.extractContext(i,"recommendation")},{pattern:/prepare|before|need to/i,template:i=>this.extractContext(i,"preparation")}];for(const i of e)if(i.role==="assistant"){for(const{pattern:b,template:_}of c)if(b.test(i.content)){const m=_(i.content),p=m.toLowerCase().substring(0,30);if(m&&!r.has(p)&&(r.add(p),s.push(m),s.length>=5))break}if(s.length>=5)break}return s}extractContext(e,t){const s=e.split(/[.!?]+/).filter(r=>r.trim().length>10);for(const r of s){const n=r.trim();if(!(n.length>150)&&(t==="task-completion"&&/complet|finish|clear|resolv/i.test(n)||t==="discovery"&&/found|discover|obtain|receiv|acquir/i.test(n)||t==="progress"&&/unlock|gain|learn|achiev|progress/i.test(n)||t==="challenge"&&/defeat|overc|resolv|handl|complet/i.test(n)||t==="milestone"&&/reach|arriv|access|enter|milestone/i.test(n)||t==="build"&&/build|spec|loadout|equipment/i.test(n)||t==="strategy"&&/strategy|approach|tactic/i.test(n)||t==="recommendation"&&/should|recommend|best|optimal/i.test(n)||t==="preparation"&&/prepare|before|need/i.test(n)))return n.substring(0,100)+(n.length>100?"...":"")}return""}extractObjectivesIntelligent(e,t){const s=[];t.activeObjective&&s.push(t.activeObjective);for(const r of e){if(r.role!=="assistant")continue;const n=[/next.*(?:step|objective|goal).*[:is]\s*([^.!?\n]+)/i,/you (?:should|need to|must)\s+([^.!?\n]+)/i,/(?:focus on|head to|go to)\s+([^.!?\n]+)/i];for(const o of n){const c=r.content.match(o);if(c&&c[1]){const i=c[1].trim().substring(0,80);if(i&&!s.includes(i)&&(s.push(i),s.length>=3))break}}if(s.length>=3)break}return s}extractStrategicNotes(e){const t=[];for(const s of e){if(s.role!=="assistant")continue;const r=s.content.match(/[•\-*]\s+[^\n]+/g);if(r)for(const n of r.slice(0,3))t.push(n.trim());if(t.length>=3)break}return t.join(`
`)}extractRecentActivity(e,t){const s=e.filter(r=>r.role==="assistant").slice(-t);return s.length===0?"• No recent activity recorded":s.map(r=>{var c;const o=(((c=r.content.split(/[.!?]+/)[0])==null?void 0:c.trim())||"").replace(/\*\*/g,"").replace(/Hint:\s*/i,"").substring(0,80);return o?`• ${o}...`:null}).filter(Boolean).join(`
`)}async storeSessionSummary(e,t){}async getLatestSessionSummary(e){return null}}const T=new w,A="otagon-offline-db",x=1,a={MESSAGES:"pending-messages",VOICE:"pending-voice",IMAGES:"pending-images",SYNC_META:"sync-metadata"};class v{constructor(){l(this,"db",null);l(this,"isSupported",!0);l(this,"initPromise",null);l(this,"MAX_QUEUE_SIZE",10);typeof indexedDB>"u"&&(console.warn("[IndexedDB] Not supported, falling back to localStorage"),this.isSupported=!1)}async init(){if(this.isSupported&&!this.db)return this.initPromise?this.initPromise:(this.initPromise=new Promise((e,t)=>{try{const s=indexedDB.open(A,x);s.onerror=()=>{console.error("[IndexedDB] Failed to open database:",s.error),this.isSupported=!1,e()},s.onsuccess=()=>{this.db=s.result,console.log("[IndexedDB] Database opened successfully"),e()},s.onupgradeneeded=r=>{const n=r.target.result;if(!n.objectStoreNames.contains(a.MESSAGES)){const o=n.createObjectStore(a.MESSAGES,{keyPath:"id"});o.createIndex("conversationId","conversationId",{unique:!1}),o.createIndex("timestamp","timestamp",{unique:!1})}n.objectStoreNames.contains(a.VOICE)||n.createObjectStore(a.VOICE,{keyPath:"id"}),n.objectStoreNames.contains(a.IMAGES)||n.createObjectStore(a.IMAGES,{keyPath:"id"}).createIndex("conversationId","conversationId",{unique:!1}),n.objectStoreNames.contains(a.SYNC_META)||n.createObjectStore(a.SYNC_META,{keyPath:"id"}),console.log("[IndexedDB] Database schema created/upgraded")}}catch(s){console.error("[IndexedDB] Initialization error:",s),this.isSupported=!1,e()}}),this.initPromise)}async canQueueMessage(){return await this.getPendingMessageCount()>=this.MAX_QUEUE_SIZE?{allowed:!1,reason:`Offline queue is full (${this.MAX_QUEUE_SIZE} messages). Please wait for connection to restore.`}:{allowed:!0}}async queueMessage(e){await this.init();const t={...e,id:`msg_${Date.now()}_${Math.random().toString(36).substring(7)}`,timestamp:Date.now(),retryCount:0};return!this.isSupported||!this.db?this.queueMessageToLocalStorage(t):new Promise((s,r)=>{try{if(!this.db){s(this.queueMessageToLocalStorage(t));return}const c=this.db.transaction([a.MESSAGES],"readwrite").objectStore(a.MESSAGES).add(t);c.onsuccess=()=>{console.log("[IndexedDB] Message queued:",t.id),s(t.id)},c.onerror=()=>{console.error("[IndexedDB] Failed to queue message:",c.error),s(this.queueMessageToLocalStorage(t))}}catch(n){console.error("[IndexedDB] Error queuing message:",n),s(this.queueMessageToLocalStorage(t))}})}async getPendingMessages(){return await this.init(),!this.isSupported||!this.db?this.getPendingMessagesFromLocalStorage():new Promise(e=>{try{if(!this.db){e(this.getPendingMessagesFromLocalStorage());return}const r=this.db.transaction([a.MESSAGES],"readonly").objectStore(a.MESSAGES).getAll();r.onsuccess=()=>{e(r.result||[])},r.onerror=()=>{console.error("[IndexedDB] Failed to get messages:",r.error),e(this.getPendingMessagesFromLocalStorage())}}catch(t){console.error("[IndexedDB] Error getting messages:",t),e(this.getPendingMessagesFromLocalStorage())}})}async getPendingMessageCount(){return await this.init(),!this.isSupported||!this.db?this.getPendingMessagesFromLocalStorage().length:new Promise(e=>{try{if(!this.db){e(this.getPendingMessagesFromLocalStorage().length);return}const r=this.db.transaction([a.MESSAGES],"readonly").objectStore(a.MESSAGES).count();r.onsuccess=()=>{e(r.result)},r.onerror=()=>{e(this.getPendingMessagesFromLocalStorage().length)}}catch{e(this.getPendingMessagesFromLocalStorage().length)}})}async removeMessage(e){return await this.init(),!this.isSupported||!this.db?this.removeMessageFromLocalStorage(e):new Promise(t=>{try{if(!this.db){t(this.removeMessageFromLocalStorage(e));return}const n=this.db.transaction([a.MESSAGES],"readwrite").objectStore(a.MESSAGES).delete(e);n.onsuccess=()=>{console.log("[IndexedDB] Message removed:",e),t(!0)},n.onerror=()=>{console.error("[IndexedDB] Failed to remove message:",n.error),t(this.removeMessageFromLocalStorage(e))}}catch(s){console.error("[IndexedDB] Error removing message:",s),t(this.removeMessageFromLocalStorage(e))}})}async clearAllMessages(){if(await this.init(),!this.isSupported||!this.db){localStorage.removeItem("otakon_pending_messages");return}return new Promise(e=>{try{if(!this.db){localStorage.removeItem("otakon_pending_messages"),e();return}const r=this.db.transaction([a.MESSAGES],"readwrite").objectStore(a.MESSAGES).clear();r.onsuccess=()=>{console.log("[IndexedDB] All messages cleared"),e()},r.onerror=()=>{console.error("[IndexedDB] Failed to clear messages:",r.error),localStorage.removeItem("otakon_pending_messages"),e()}}catch{localStorage.removeItem("otakon_pending_messages"),e()}})}async queueImage(e){await this.init();const t={...e,id:`img_${Date.now()}_${Math.random().toString(36).substring(7)}`,timestamp:Date.now()};return!this.isSupported||!this.db?(console.warn("[IndexedDB] Cannot queue large image data to localStorage"),null):new Promise(s=>{try{if(!this.db){s(null);return}const o=this.db.transaction([a.IMAGES],"readwrite").objectStore(a.IMAGES).add(t);o.onsuccess=()=>{console.log("[IndexedDB] Image queued:",t.id),s(t.id)},o.onerror=()=>{console.error("[IndexedDB] Failed to queue image:",o.error),s(null)}}catch(r){console.error("[IndexedDB] Error queuing image:",r),s(null)}})}async getPendingImages(){return await this.init(),!this.isSupported||!this.db?[]:new Promise(e=>{try{if(!this.db){e([]);return}const r=this.db.transaction([a.IMAGES],"readonly").objectStore(a.IMAGES).getAll();r.onsuccess=()=>{e(r.result||[])},r.onerror=()=>{e([])}}catch{e([])}})}async clearAllImages(){if(await this.init(),!(!this.isSupported||!this.db))return new Promise(e=>{try{if(!this.db){e();return}this.db.transaction([a.IMAGES],"readwrite").objectStore(a.IMAGES).clear(),e()}catch{e()}})}queueMessageToLocalStorage(e){try{const t=this.getPendingMessagesFromLocalStorage();return t.push(e),localStorage.setItem("otakon_pending_messages",JSON.stringify(t)),console.log("[IndexedDB] Message queued to localStorage fallback:",e.id),e.id}catch(t){return console.error("[IndexedDB] localStorage fallback failed:",t),e.id}}getPendingMessagesFromLocalStorage(){try{const e=localStorage.getItem("otakon_pending_messages");return e?JSON.parse(e):[]}catch{return[]}}removeMessageFromLocalStorage(e){try{const s=this.getPendingMessagesFromLocalStorage().filter(r=>r.id!==e);return localStorage.setItem("otakon_pending_messages",JSON.stringify(s)),!0}catch{return!1}}async updateSyncMetadata(e){await this.init();const t={lastSyncAttempt:e.lastSyncAttempt||Date.now(),pendingCount:e.pendingCount||0,lastSuccessfulSync:e.lastSuccessfulSync||0};if(!this.isSupported||!this.db){localStorage.setItem("otakon_sync_metadata",JSON.stringify(t));return}return new Promise(s=>{try{if(!this.db){localStorage.setItem("otakon_sync_metadata",JSON.stringify(t)),s();return}this.db.transaction([a.SYNC_META],"readwrite").objectStore(a.SYNC_META).put({id:"sync-status",...t}),s()}catch{localStorage.setItem("otakon_sync_metadata",JSON.stringify(t)),s()}})}async getSyncMetadata(){if(await this.init(),!this.isSupported||!this.db)try{const e=localStorage.getItem("otakon_sync_metadata");return e?JSON.parse(e):null}catch{return null}return new Promise(e=>{try{if(!this.db){e(null);return}const r=this.db.transaction([a.SYNC_META],"readonly").objectStore(a.SYNC_META).get("sync-status");r.onsuccess=()=>{e(r.result||null)},r.onerror=()=>{e(null)}}catch{e(null)}})}isAvailable(){return this.isSupported&&this.db!==null}}const d=new v,P={queueMessage:u=>d.queueMessage(u),getPendingMessages:()=>d.getPendingMessages(),removePendingMessage:u=>d.removeMessage(u),clearAllMessages:()=>d.clearAllMessages(),canQueueMessage:()=>d.canQueueMessage(),getPendingMessageCount:()=>d.getPendingMessageCount()},j=Object.freeze(Object.defineProperty({__proto__:null,indexedDBService:d,offlineQueueService:P},Symbol.toStringTag,{value:"Module"}));export{f as S,T as a,y as c,j as i,P as o,M as s};
