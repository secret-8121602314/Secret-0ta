{"version":3,"file":"services-BND8mY4U.js","sources":["../../src/services/cacheService.ts","../../src/services/errorService.ts","../../src/services/toastService.ts","../../src/services/onboardingService.ts","../../src/services/websocketService.ts","../../src/services/waitlistService.ts","../../src/services/storageService.ts","../../src/services/chatMemoryService.ts","../../src/services/otakonTags.ts","../../src/services/profileAwareTabService.ts","../../src/services/promptSystem.ts","../../src/services/errorRecoveryService.ts","../../src/services/characterImmersionService.ts","../../src/services/suggestedPromptsService.ts","../../src/services/sessionSummaryService.ts","../../src/services/subtabsService.ts","../../src/services/gameTabService.ts","../../src/services/userService.ts","../../src/services/tabManagementService.ts","../../src/services/ttsService.ts","../../src/services/messageRoutingService.ts","../../src/services/contextSummarizationService.ts"],"sourcesContent":["import { supabase } from '../lib/supabase';\r\n\r\n/**\r\n * Centralized cache service using Supabase for persistent caching\r\n * Replaces multiple cache instances across services with database-backed cache\r\n */\r\nclass CacheService {\r\n  private memoryCache = new Map<string, { value: any; expires: number }>();\r\n  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes\r\n  private readonly CACHE_TABLE = 'app_cache';\r\n  private readonly MAX_MEMORY_CACHE_SIZE = 100; // Prevent memory bloat\r\n  \r\n  // Request deduplication - prevent multiple simultaneous calls for the same key\r\n  private pendingRequests = new Map<string, Promise<any>>();\r\n\r\n  /**\r\n   * Set a value in both memory and Supabase cache\r\n   */\r\n  async set(key: string, value: any, ttl: number = this.DEFAULT_TTL, cacheType: string = 'general', userId?: string): Promise<void> {\r\n    const expires = Date.now() + ttl;\r\n    \r\n    // Store in memory cache for fast access\r\n    this.memoryCache.set(key, { value, expires });\r\n    console.log(`[CacheService] Stored in memory cache: ${key}`);\r\n    \r\n    // Store in Supabase for persistence\r\n    try {\r\n      console.log(`[CacheService] Storing in Supabase: ${key} (type: ${cacheType}, user: ${userId || 'none'})`);\r\n      const { error } = await supabase\r\n        .from(this.CACHE_TABLE)\r\n        .upsert({\r\n          key,\r\n          value: JSON.stringify(value),\r\n          expires_at: new Date(expires).toISOString(),\r\n          updated_at: new Date().toISOString(),\r\n          cache_type: cacheType,\r\n          user_id: userId || null,\r\n          size_bytes: JSON.stringify(value).length\r\n        });\r\n      \r\n      if (error) {\r\n        console.warn(`[CacheService] Failed to store cache in Supabase for key ${key}:`, error);\r\n      } else {\r\n        console.log(`[CacheService] Successfully stored in Supabase: ${key}`);\r\n      }\r\n    } catch (error) {\r\n      console.warn(`[CacheService] Supabase cache unavailable for key ${key}, using memory only:`, error);\r\n    }\r\n    \r\n    // Cleanup memory cache if it gets too large\r\n    if (this.memoryCache.size > this.MAX_MEMORY_CACHE_SIZE) {\r\n      this.cleanupMemoryCache();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a value from cache (memory first, then Supabase)\r\n   * Implements request deduplication to prevent multiple simultaneous calls\r\n   * @param key - Cache key\r\n   * @param memoryOnly - If true, only check memory cache (faster for real-time operations)\r\n   */\r\n  async get<T>(key: string, memoryOnly: boolean = false): Promise<T | null> {\r\n    // Check if there's already a pending request for this key\r\n    if (this.pendingRequests.has(key)) {\r\n      console.log(`[CacheService] Request deduplication: waiting for pending request for key: ${key}`);\r\n      return await this.pendingRequests.get(key) as T | null;\r\n    }\r\n    \r\n    // Try memory cache first\r\n    const memoryItem = this.memoryCache.get(key);\r\n    if (memoryItem && Date.now() <= memoryItem.expires) {\r\n      console.log(`[CacheService] Cache HIT (memory): ${key}`);\r\n      return memoryItem.value as T;\r\n    }\r\n    \r\n    // Remove expired memory item\r\n    if (memoryItem) {\r\n      this.memoryCache.delete(key);\r\n    }\r\n    \r\n    // If memory-only mode, return null instead of checking Supabase\r\n    if (memoryOnly) {\r\n      console.log(`[CacheService] Cache MISS (memory-only mode): ${key}`);\r\n      return null;\r\n    }\r\n    \r\n    // Create a promise for the Supabase request and store it\r\n    const supabaseRequest = this.fetchFromSupabase<T>(key);\r\n    this.pendingRequests.set(key, supabaseRequest);\r\n    \r\n    try {\r\n      const result = await supabaseRequest;\r\n      return result;\r\n    } finally {\r\n      // Clean up the pending request\r\n      this.pendingRequests.delete(key);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Fetch data from Supabase cache\r\n   */\r\n  private async fetchFromSupabase<T>(key: string): Promise<T | null> {\r\n    try {\r\n      console.log(`[CacheService] Cache MISS (memory), trying Supabase: ${key}`);\r\n      const { data, error } = await supabase\r\n        .from(this.CACHE_TABLE)\r\n        .select('value, expires_at')\r\n        .eq('key', key)\r\n        .maybeSingle(); // Use maybeSingle() instead of single() to avoid 406 errors\r\n      \r\n      if (error) {\r\n        console.warn(`[CacheService] Supabase error for key ${key}:`, error);\r\n        return null;\r\n      }\r\n      \r\n      if (!data) {\r\n        console.log(`[CacheService] Cache MISS (Supabase): ${key}`);\r\n        return null;\r\n      }\r\n      \r\n      const expiresAt = new Date(data.expires_at).getTime();\r\n      if (Date.now() > expiresAt) {\r\n        console.log(`[CacheService] Cache EXPIRED (Supabase): ${key}`);\r\n        await this.delete(key);\r\n        return null;\r\n      }\r\n      \r\n      console.log(`[CacheService] Cache HIT (Supabase): ${key}`);\r\n      const value = JSON.parse(typeof data.value === 'string' ? data.value : '{}');\r\n      this.memoryCache.set(key, { value, expires: expiresAt });\r\n      return value as T;\r\n      \r\n    } catch (error) {\r\n      console.warn(`[CacheService] Error retrieving cache for key ${key}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a key exists and is not expired\r\n   */\r\n  async has(key: string): Promise<boolean> {\r\n    const value = await this.get(key);\r\n    return value !== null;\r\n  }\r\n\r\n  /**\r\n   * Delete a specific key from both memory and Supabase\r\n   */\r\n  async delete(key: string): Promise<boolean> {\r\n    // Remove from memory\r\n    const memoryDeleted = this.memoryCache.delete(key);\r\n    \r\n    // Remove from Supabase\r\n    try {\r\n      const { error } = await supabase\r\n        .from(this.CACHE_TABLE)\r\n        .delete()\r\n        .eq('key', key);\r\n      \r\n      if (error) {\r\n        console.warn(`[CacheService] Failed to delete cache from Supabase:`, error);\r\n      }\r\n    } catch (error) {\r\n      console.warn(`[CacheService] Error deleting cache:`, error);\r\n    }\r\n    \r\n    return memoryDeleted;\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries from both memory and Supabase\r\n   */\r\n  async clear(): Promise<void> {\r\n    // Clear memory cache\r\n    this.memoryCache.clear();\r\n    \r\n    // Clear pending requests\r\n    this.pendingRequests.clear();\r\n    \r\n    // Clear Supabase cache\r\n    try {\r\n      const { error } = await supabase\r\n        .from(this.CACHE_TABLE)\r\n        .delete()\r\n        .neq('key', 'never_delete'); // Delete all except this placeholder\r\n      \r\n      if (error) {\r\n        console.warn(`[CacheService] Failed to clear Supabase cache:`, error);\r\n      }\r\n    } catch (error) {\r\n      console.warn(`[CacheService] Error clearing cache:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear expired entries from both memory and Supabase\r\n   */\r\n  async cleanup(): Promise<void> {\r\n    const now = Date.now();\r\n    \r\n    // Cleanup memory cache\r\n    this.cleanupMemoryCache();\r\n    \r\n    // Cleanup Supabase cache\r\n    try {\r\n      const { error } = await supabase\r\n        .from(this.CACHE_TABLE)\r\n        .delete()\r\n        .lt('expires_at', new Date(now).toISOString());\r\n      \r\n      if (error) {\r\n        console.warn(`[CacheService] Failed to cleanup Supabase cache:`, error);\r\n      }\r\n    } catch (error) {\r\n      console.warn(`[CacheService] Error cleaning up cache:`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup memory cache to prevent bloat\r\n   */\r\n  private cleanupMemoryCache(): void {\r\n    const now = Date.now();\r\n    const entries = Array.from(this.memoryCache.entries());\r\n    \r\n    // Remove expired entries\r\n    entries.forEach(([key, item]) => {\r\n      if (now > item.expires) {\r\n        this.memoryCache.delete(key);\r\n      }\r\n    });\r\n    \r\n    // If still too large, remove oldest entries\r\n    if (this.memoryCache.size > this.MAX_MEMORY_CACHE_SIZE) {\r\n      const sortedEntries = entries\r\n        .filter(([key]) => this.memoryCache.has(key))\r\n        .sort((a, b) => a[1].expires - b[1].expires);\r\n      \r\n      const toRemove = sortedEntries.slice(0, this.memoryCache.size - this.MAX_MEMORY_CACHE_SIZE);\r\n      toRemove.forEach(([key]) => this.memoryCache.delete(key));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats(): { memorySize: number; memoryKeys: string[] } {\r\n    return {\r\n      memorySize: this.memoryCache.size,\r\n      memoryKeys: Array.from(this.memoryCache.keys()),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive cache statistics from Supabase\r\n   */\r\n  async getSupabaseStats(): Promise<any> {\r\n    try {\r\n      const { data, error } = await supabase.rpc('get_cache_stats');\r\n      if (error) {\r\n        console.warn('[CacheService] Failed to get Supabase stats:', error);\r\n        return null;\r\n      }\r\n      return data;\r\n    } catch (error) {\r\n      console.warn('[CacheService] Error getting Supabase stats:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache performance metrics\r\n   */\r\n  async getPerformanceMetrics(): Promise<any> {\r\n    try {\r\n      const { data, error } = await supabase.rpc('get_cache_performance_metrics');\r\n      if (error) {\r\n        console.warn('[CacheService] Failed to get performance metrics:', error);\r\n        return null;\r\n      }\r\n      return data;\r\n    } catch (error) {\r\n      console.warn('[CacheService] Error getting performance metrics:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user-specific cache entries\r\n   */\r\n  async getUserCacheEntries(userId: string): Promise<any[]> {\r\n    try {\r\n      const { data, error } = await supabase.rpc('get_user_cache_entries', { p_user_id: userId });\r\n      if (error) {\r\n        console.warn('[CacheService] Failed to get user cache entries:', error);\r\n        return [];\r\n      }\r\n      return data || [];\r\n    } catch (error) {\r\n      console.warn('[CacheService] Error getting user cache entries:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries for a specific user\r\n   */\r\n  async clearUserCache(userId: string): Promise<number> {\r\n    try {\r\n      const { data, error } = await supabase.rpc('clear_user_cache', { p_user_id: userId });\r\n      if (error) {\r\n        console.warn('[CacheService] Failed to clear user cache:', error);\r\n        return 0;\r\n      }\r\n      return data || 0;\r\n    } catch (error) {\r\n      console.warn('[CacheService] Error clearing user cache:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set chat context data\r\n   */\r\n  async setChatContext(userId: string, context: any): Promise<void> {\r\n    // Store for 90 days - chat context should persist but can expire after extended inactivity\r\n    await this.set(`chat_context:${userId}`, context, 90 * 24 * 60 * 60 * 1000, 'context', userId); // 90 days\r\n  }\r\n\r\n  /**\r\n   * Get chat context data\r\n   */\r\n  async getChatContext<T>(userId: string): Promise<T | null> {\r\n    return await this.get<T>(`chat_context:${userId}`);\r\n  }\r\n\r\n  /**\r\n   * Set user memory data\r\n   */\r\n  async setUserMemory(userId: string, memory: any): Promise<void> {\r\n    // Store indefinitely (365 days) - user memory should persist until explicitly deleted\r\n    await this.set(`user_memory:${userId}`, memory, 365 * 24 * 60 * 60 * 1000, 'memory', userId); // 1 year\r\n  }\r\n\r\n  /**\r\n   * Get user memory data\r\n   */\r\n  async getUserMemory<T>(userId: string): Promise<T | null> {\r\n    return await this.get<T>(`user_memory:${userId}`);\r\n  }\r\n\r\n  /**\r\n   * Set game context data\r\n   */\r\n  async setGameContext(userId: string, gameId: string, context: any): Promise<void> {\r\n    // Store for 90 days - game context should persist but can expire after extended inactivity\r\n    await this.set(`game_context:${userId}:${gameId}`, context, 90 * 24 * 60 * 60 * 1000, 'context', userId); // 90 days\r\n  }\r\n\r\n  /**\r\n   * Get game context data\r\n   */\r\n  async getGameContext<T>(userId: string, gameId: string): Promise<T | null> {\r\n    return await this.get<T>(`game_context:${userId}:${gameId}`);\r\n  }\r\n\r\n  /**\r\n   * Set user data with appropriate TTL\r\n   */\r\n  async setUser(userId: string, user: any): Promise<void> {\r\n    // Store indefinitely (365 days) - user data should persist until explicitly deleted\r\n    await this.set(`user:${userId}`, user, 365 * 24 * 60 * 60 * 1000, 'user', userId); // 1 year\r\n  }\r\n\r\n  /**\r\n   * Get user data\r\n   */\r\n  async getUser<T>(userId: string): Promise<T | null> {\r\n    return await this.get<T>(`user:${userId}`);\r\n  }\r\n\r\n  /**\r\n   * Set rate limit data\r\n   */\r\n  async setRateLimit(key: string, data: { count: number; resetTime: number }): Promise<void> {\r\n    await this.set(`rate_limit:${key}`, data, 15 * 60 * 1000, 'rate_limit'); // 15 minutes\r\n  }\r\n\r\n  /**\r\n   * Get rate limit data\r\n   */\r\n  async getRateLimit(key: string): Promise<{ count: number; resetTime: number } | null> {\r\n    return await this.get<{ count: number; resetTime: number }>(`rate_limit:${key}`);\r\n  }\r\n\r\n  /**\r\n   * Set conversation data\r\n   */\r\n  async setConversation(conversationId: string, conversation: any, userId?: string): Promise<void> {\r\n    // Store indefinitely (365 days) - conversations should persist until explicitly deleted\r\n    await this.set(`conversation:${conversationId}`, conversation, 365 * 24 * 60 * 60 * 1000, 'conversation', userId); // 1 year\r\n  }\r\n\r\n  /**\r\n   * Get conversation data\r\n   */\r\n  async getConversation<T>(conversationId: string): Promise<T | null> {\r\n    return await this.get<T>(`conversation:${conversationId}`);\r\n  }\r\n\r\n  /**\r\n   * Initialize cache table if it doesn't exist\r\n   */\r\n  async initializeCacheTable(): Promise<void> {\r\n    try {\r\n      // Check if table exists by trying to select from it\r\n      const { error } = await supabase\r\n        .from(this.CACHE_TABLE)\r\n        .select('key')\r\n        .limit(1);\r\n      \r\n      if (error && error.code === 'PGRST116') {\r\n        // Table doesn't exist, create it\r\n        console.log('[CacheService] Creating cache table...');\r\n        // Note: This would typically be done via a migration\r\n        // For now, we'll just log that it needs to be created\r\n        console.warn('[CacheService] Cache table needs to be created in Supabase');\r\n      }\r\n    } catch (error) {\r\n      // Silently fail - cache table initialization is optional\r\n      // This prevents errors on landing page before auth\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const cacheService = new CacheService();\r\n\r\n// Initialize cache table on startup (non-blocking, silent failures)\r\ncacheService.initializeCacheTable().catch(() => {\r\n  // Silently catch errors - cache will work without the table check\r\n});\r\n\r\n// Auto-cleanup every 5 minutes\r\nsetInterval(() => {\r\n  cacheService.cleanup();\r\n}, 5 * 60 * 1000);\r\n","/**\r\n * Centralized error handling service\r\n * Provides consistent error handling across the application\r\n */\r\nclass ErrorService {\r\n  private static errorCount = 0;\r\n  private static maxErrorsPerMinute = 10;\r\n  private static errorWindow = 60 * 1000; // 1 minute\r\n  private static recentErrors: number[] = [];\r\n\r\n  /**\r\n   * Handle an error with context and optional user message\r\n   */\r\n  static handle(error: Error, context: string, userMessage?: string): void {\r\n    // Increment error count\r\n    this.errorCount++;\r\n    \r\n    // Check if we're hitting error rate limits\r\n    if (this.isErrorRateLimited()) {\r\n      console.warn(`[ErrorService] Error rate limit exceeded, suppressing error:`, error);\r\n      return;\r\n    }\r\n\r\n    // Log error with context\r\n    console.error(`[${context}]`, {\r\n      message: error.message,\r\n      stack: error.stack,\r\n      context,\r\n      timestamp: new Date().toISOString(),\r\n      errorCount: this.errorCount,\r\n    });\r\n\r\n    // Show user-friendly message if provided\r\n    if (userMessage) {\r\n      this.showUserMessage(userMessage);\r\n    }\r\n\r\n    // Report to monitoring service (if configured)\r\n    this.reportError(error, context);\r\n  }\r\n\r\n  /**\r\n   * Handle authentication errors\r\n   */\r\n  static handleAuthError(error: Error, operation: string): void {\r\n    const userMessage = this.getAuthErrorMessage(operation);\r\n    this.handle(error, `AuthService:${operation}`, userMessage);\r\n  }\r\n\r\n  /**\r\n   * Handle WebSocket errors\r\n   */\r\n  static handleWebSocketError(error: Error, operation: string): void {\r\n    const userMessage = this.getWebSocketErrorMessage(operation);\r\n    this.handle(error, `WebSocketService:${operation}`, userMessage);\r\n  }\r\n\r\n  /**\r\n   * Handle conversation errors\r\n   */\r\n  static handleConversationError(error: Error, operation: string): void {\r\n    const userMessage = this.getConversationErrorMessage(operation);\r\n    this.handle(error, `ConversationService:${operation}`, userMessage);\r\n  }\r\n\r\n  /**\r\n   * Handle database errors\r\n   */\r\n  static handleDatabaseError(error: Error, operation: string): void {\r\n    const userMessage = this.getDatabaseErrorMessage(operation);\r\n    this.handle(error, `DatabaseService:${operation}`, userMessage);\r\n  }\r\n\r\n  /**\r\n   * Check if error rate is too high\r\n   */\r\n  private static isErrorRateLimited(): boolean {\r\n    const now = Date.now();\r\n    \r\n    // Remove old errors from the window\r\n    this.recentErrors = this.recentErrors.filter(time => now - time < this.errorWindow);\r\n    \r\n    // Add current error\r\n    this.recentErrors.push(now);\r\n    \r\n    // Check if we're over the limit\r\n    return this.recentErrors.length > this.maxErrorsPerMinute;\r\n  }\r\n\r\n  /**\r\n   * Show user-friendly error message\r\n   */\r\n  private static showUserMessage(message: string): void {\r\n    // TODO: Implement toast notification system\r\n    // For now, we'll use console.warn as a placeholder\r\n    console.warn(`[User Message] ${message}`);\r\n    \r\n    // In a real implementation, this would:\r\n    // 1. Show a toast notification\r\n    // 2. Update UI state to show error\r\n    // 3. Log to user activity tracking\r\n  }\r\n\r\n  /**\r\n   * Report error to monitoring service\r\n   */\r\n  private static reportError(error: Error, context: string): void {\r\n    // TODO: Implement error reporting to monitoring service\r\n    // For now, we'll just log it\r\n    console.warn(`[Error Reporting] Would report error to monitoring service:`, {\r\n      error: error.message,\r\n      context,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get user-friendly auth error messages\r\n   */\r\n  private static getAuthErrorMessage(operation: string): string {\r\n    const messages: Record<string, string> = {\r\n      'signIn': 'Failed to sign in. Please check your credentials and try again.',\r\n      'signOut': 'Failed to sign out. Please try again.',\r\n      'loadUser': 'Failed to load user data. Please refresh the page.',\r\n      'createUser': 'Failed to create user account. Please try again.',\r\n      'refreshUser': 'Failed to refresh user data. Please try again.',\r\n    };\r\n    \r\n    return messages[operation] || 'An authentication error occurred. Please try again.';\r\n  }\r\n\r\n  /**\r\n   * Get user-friendly WebSocket error messages\r\n   */\r\n  private static getWebSocketErrorMessage(operation: string): string {\r\n    const messages: Record<string, string> = {\r\n      'connect': 'Failed to connect to server. Please check your internet connection.',\r\n      'send': 'Failed to send message. Please try again.',\r\n      'disconnect': 'Failed to disconnect. Please try again.',\r\n    };\r\n    \r\n    return messages[operation] || 'A connection error occurred. Please try again.';\r\n  }\r\n\r\n  /**\r\n   * Get user-friendly conversation error messages\r\n   */\r\n  private static getConversationErrorMessage(operation: string): string {\r\n    const messages: Record<string, string> = {\r\n      'create': 'Failed to create conversation. Please try again.',\r\n      'load': 'Failed to load conversations. Please refresh the page.',\r\n      'save': 'Failed to save conversation. Please try again.',\r\n      'delete': 'Failed to delete conversation. Please try again.',\r\n    };\r\n    \r\n    return messages[operation] || 'A conversation error occurred. Please try again.';\r\n  }\r\n\r\n  /**\r\n   * Get user-friendly database error messages\r\n   */\r\n  private static getDatabaseErrorMessage(operation: string): string {\r\n    const messages: Record<string, string> = {\r\n      'save': 'Failed to save data. Please try again.',\r\n      'load': 'Failed to load data. Please refresh the page.',\r\n      'update': 'Failed to update data. Please try again.',\r\n      'delete': 'Failed to delete data. Please try again.',\r\n    };\r\n    \r\n    return messages[operation] || 'A database error occurred. Please try again.';\r\n  }\r\n\r\n  /**\r\n   * Get error statistics\r\n   */\r\n  static getStats(): { totalErrors: number; recentErrors: number; isRateLimited: boolean } {\r\n    return {\r\n      totalErrors: this.errorCount,\r\n      recentErrors: this.recentErrors.length,\r\n      isRateLimited: this.isErrorRateLimited(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset error statistics\r\n   */\r\n  static reset(): void {\r\n    this.errorCount = 0;\r\n    this.recentErrors = [];\r\n  }\r\n}\r\n\r\nexport { ErrorService };\r\n","/**\r\n * Toast Notification Service\r\n * Provides user-friendly feedback for operations throughout the app\r\n * Replaces silent console.error calls with visible notifications\r\n */\r\n\r\nexport type ToastType = 'success' | 'error' | 'warning' | 'info';\r\n\r\nexport interface ToastAction {\r\n  label: string;\r\n  onClick: () => void | Promise<void>;\r\n}\r\n\r\nexport interface Toast {\r\n  id: string;\r\n  message: string;\r\n  type: ToastType;\r\n  duration?: number;\r\n  action?: ToastAction;\r\n  dismissible?: boolean;\r\n}\r\n\r\nexport interface ToastOptions {\r\n  duration?: number;\r\n  action?: ToastAction;\r\n  dismissible?: boolean;\r\n}\r\n\r\ntype ToastListener = (toasts: Toast[]) => void;\r\n\r\nclass ToastService {\r\n  private toasts: Toast[] = [];\r\n  private listeners: Set<ToastListener> = new Set();\r\n  private maxToasts = 5; // Maximum visible toasts\r\n\r\n  /**\r\n   * Subscribe to toast updates\r\n   * @returns Unsubscribe function\r\n   */\r\n  subscribe(listener: ToastListener): () => void {\r\n    this.listeners.add(listener);\r\n    // Immediately notify with current toasts\r\n    listener(this.toasts);\r\n    \r\n    return () => {\r\n      this.listeners.delete(listener);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Notify all listeners of toast changes\r\n   */\r\n  private notify(): void {\r\n    this.listeners.forEach(listener => listener([...this.toasts]));\r\n  }\r\n\r\n  /**\r\n   * Show a toast notification\r\n   * @param message - Message to display\r\n   * @param type - Toast type (success, error, warning, info)\r\n   * @param options - Additional options\r\n   * @returns Toast ID for manual dismissal\r\n   */\r\n  show(\r\n    message: string,\r\n    type: ToastType = 'info',\r\n    options: ToastOptions = {}\r\n  ): string {\r\n    const id = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    const toast: Toast = {\r\n      id,\r\n      message,\r\n      type,\r\n      duration: options.duration ?? this.getDefaultDuration(type),\r\n      action: options.action,\r\n      dismissible: options.dismissible ?? true,\r\n    };\r\n\r\n    // Add to beginning of array (newest first)\r\n    this.toasts.unshift(toast);\r\n\r\n    // Limit number of visible toasts\r\n    if (this.toasts.length > this.maxToasts) {\r\n      this.toasts = this.toasts.slice(0, this.maxToasts);\r\n    }\r\n\r\n    this.notify();\r\n\r\n    // Auto-dismiss after duration\r\n    if (toast.duration && toast.duration > 0) {\r\n      setTimeout(() => this.dismiss(id), toast.duration);\r\n    }\r\n\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Show success toast\r\n   */\r\n  success(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'success', {\r\n      duration: 3000,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show error toast with optional retry action\r\n   */\r\n  error(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'error', {\r\n      duration: 7000,\r\n      dismissible: true,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show warning toast\r\n   */\r\n  warning(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'warning', {\r\n      duration: 5000,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Show info toast\r\n   */\r\n  info(message: string, options?: ToastOptions): string {\r\n    return this.show(message, 'info', {\r\n      duration: 4000,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Dismiss a specific toast\r\n   */\r\n  dismiss(id: string): void {\r\n    const index = this.toasts.findIndex(t => t.id === id);\r\n    if (index !== -1) {\r\n      this.toasts.splice(index, 1);\r\n      this.notify();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dismiss all toasts\r\n   */\r\n  dismissAll(): void {\r\n    this.toasts = [];\r\n    this.notify();\r\n  }\r\n\r\n  /**\r\n   * Get default duration based on toast type\r\n   */\r\n  private getDefaultDuration(type: ToastType): number {\r\n    switch (type) {\r\n      case 'success':\r\n        return 3000;\r\n      case 'error':\r\n        return 7000;\r\n      case 'warning':\r\n        return 5000;\r\n      case 'info':\r\n        return 4000;\r\n      default:\r\n        return 4000;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show loading toast that stays until dismissed\r\n   * Returns dismiss function\r\n   */\r\n  loading(message: string): () => void {\r\n    const id = this.show(message, 'info', {\r\n      duration: 0, // Don't auto-dismiss\r\n      dismissible: false,\r\n    });\r\n\r\n    return () => this.dismiss(id);\r\n  }\r\n\r\n  /**\r\n   * Show promise-based toast\r\n   * Shows loading, then success or error based on promise result\r\n   */\r\n  async promise<T>(\r\n    promise: Promise<T>,\r\n    messages: {\r\n      loading: string;\r\n      success: string | ((data: T) => string);\r\n      error: string | ((error: Error) => string);\r\n    }\r\n  ): Promise<T> {\r\n    const dismiss = this.loading(messages.loading);\r\n\r\n    try {\r\n      const result = await promise;\r\n      dismiss();\r\n      \r\n      const successMessage = typeof messages.success === 'function'\r\n        ? messages.success(result)\r\n        : messages.success;\r\n      \r\n      this.success(successMessage);\r\n      return result;\r\n    } catch (error) {\r\n      dismiss();\r\n      \r\n      const errorMessage = typeof messages.error === 'function'\r\n        ? messages.error(error as Error)\r\n        : messages.error;\r\n      \r\n      this.error(errorMessage);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const toastService = new ToastService();\r\n\r\n// System notification helpers for screen-locked scenarios\r\nlet isScreenLocked = false;\r\n\r\n// Track screen lock state\r\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\r\n  document.addEventListener('visibilitychange', () => {\r\n    isScreenLocked = document.hidden;\r\n  });\r\n  \r\n  window.addEventListener('blur', () => {\r\n    isScreenLocked = true;\r\n  });\r\n  \r\n  window.addEventListener('focus', () => {\r\n    if (!document.hidden) {\r\n      isScreenLocked = false;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Show system notification for AI response\r\n * Only shows when screen is locked/hidden\r\n */\r\nexport const showAINotification = async (\r\n  messagePreview: string,\r\n  conversationName: string = 'Otagon AI'\r\n): Promise<void> => {\r\n  // Only show if screen is locked/hidden\r\n  if (!isScreenLocked && !document.hidden) {\r\n    return;\r\n  }\r\n  \r\n  // Check permission\r\n  if (!('Notification' in window) || Notification.permission !== 'granted') {\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    const preview = messagePreview.length > 100 \r\n      ? messagePreview.substring(0, 97) + '...' \r\n      : messagePreview;\r\n\r\n    const notification = new Notification(conversationName, {\r\n      body: preview,\r\n      icon: '/Otagon/icon-192.png',\r\n      badge: '/Otagon/icon-192.png',\r\n      tag: 'otagon-ai-response',\r\n      renotify: true,\r\n      requireInteraction: false,\r\n      silent: false,\r\n      vibrate: [200, 100, 200]\r\n    });\r\n\r\n    setTimeout(() => notification.close(), 10000);\r\n    \r\n    notification.onclick = () => {\r\n      window.focus();\r\n      notification.close();\r\n    };\r\n  } catch (error) {\r\n    console.error('Failed to show notification:', error);\r\n  }\r\n};\r\n\r\nexport const isScreenLockedOrHidden = (): boolean => isScreenLocked || document.hidden;\r\n","import { supabase } from '../lib/supabase';\r\n\r\n// ========================================\r\n// TYPES\r\n// ========================================\r\n\r\nexport type OnboardingStep = \r\n  | 'login'               // LoginSplashScreen\r\n  | 'loading'             // Loading screen during auth processing\r\n  | 'initial'             // InitialSplashScreen  \r\n  | 'how-to-use'          // SplashScreen (PC Connection with 6-digit code)\r\n  | 'features-connected'  // HowToUseSplashScreen (Only if PC connection successful)\r\n  | 'pro-features'        // ProFeaturesSplashScreen (Supercharge with Otagon Pro)\r\n  | 'profile-setup'       // Profile Setup Modal (sets has_profile_setup flag)\r\n  | 'complete';           // Main App (Onboarding fully complete)\r\n\r\nexport interface OnboardingProgress {\r\n  step: OnboardingStep;\r\n  completed_at: string;\r\n  data: any;\r\n}\r\n\r\nexport interface OnboardingStatus {\r\n  is_new_user: boolean;\r\n  has_seen_splash_screens: boolean;\r\n  has_profile_setup: boolean;\r\n  has_welcome_message: boolean;\r\n  has_seen_how_to_use: boolean;\r\n  has_seen_features_connected: boolean;\r\n  has_seen_pro_features: boolean;\r\n  pc_connected: boolean;\r\n  pc_connection_skipped: boolean;\r\n  onboarding_completed: boolean;\r\n  tier: string;\r\n}\r\n\r\n// ========================================\r\n// ONBOARDING SERVICE\r\n// ========================================\r\n\r\nclass OnboardingService {\r\n  private static instance: OnboardingService;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): OnboardingService {\r\n    if (!OnboardingService.instance) {\r\n      OnboardingService.instance = new OnboardingService();\r\n    }\r\n    return OnboardingService.instance;\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING STATUS MANAGEMENT\r\n  // ========================================\r\n\r\n  async getOnboardingStatus(userId: string): Promise<OnboardingStatus | null> {\r\n    try {\r\n      console.log('ðŸŽ¯ [OnboardingService] Getting onboarding status for user:', userId);\r\n      const { data, error } = await supabase.rpc('get_user_onboarding_status', {\r\n        p_user_id: userId\r\n      });\r\n\r\n      if (error) {\r\n        console.error('ðŸŽ¯ [OnboardingService] Error getting onboarding status:', error);\r\n        return null;\r\n      }\r\n\r\n      console.log('ðŸŽ¯ [OnboardingService] Onboarding status raw data:', data);\r\n      \r\n      // The RPC function returns a TABLE (array), so we need to get the first element\r\n      if (!data || data.length === 0) {\r\n        console.log('ðŸŽ¯ [OnboardingService] No onboarding data found for user');\r\n        return null;\r\n      }\r\n      \r\n      const status = data[0];\r\n      console.log('ðŸŽ¯ [OnboardingService] Onboarding status (first element):', status);\r\n      return status;\r\n\r\n    } catch (error) {\r\n      console.error('ðŸŽ¯ [OnboardingService] Error getting onboarding status:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async updateOnboardingStatus(userId: string, status: OnboardingStep, data: any = {}): Promise<boolean> {\r\n    try {\r\n      const { error } = await supabase.rpc('update_user_onboarding_status', {\r\n        p_user_id: userId,\r\n        p_step: status,\r\n        p_data: data\r\n      });\r\n\r\n      if (error) {\r\n        console.error('Error updating onboarding status:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Error updating onboarding status:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getOnboardingProgress(userId: string): Promise<OnboardingProgress[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('onboarding_progress')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .order('completed_at', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error getting onboarding progress:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []).map(item => ({\r\n        step: item.step as OnboardingStep,\r\n        completed_at: item.created_at || '',\r\n        data: item.data || {}\r\n      }));\r\n\r\n    } catch (error) {\r\n      console.error('Error getting onboarding progress:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // STEP-SPECIFIC METHODS\r\n  // ========================================\r\n\r\n  async markSplashScreensSeen(userId: string): Promise<boolean> {\r\n    return this.updateOnboardingStatus(userId, 'initial', {\r\n      splash_screens_seen: true,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  async markProfileSetupComplete(userId: string, profileData: any): Promise<boolean> {\r\n    // Profile setup is now handled in the chat screen, not as part of onboarding\r\n    // This function is kept for backward compatibility but doesn't affect onboarding flow\r\n    try {\r\n      const { error } = await supabase\r\n        .from('users')\r\n        .update({\r\n          has_profile_setup: true,\r\n          profile_data: profileData,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('auth_user_id', userId);\r\n\r\n      if (error) {\r\n        console.error('Error marking profile setup complete:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error marking profile setup complete:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async markWelcomeMessageShown(userId: string): Promise<boolean> {\r\n    return this.updateOnboardingStatus(userId, 'complete', {\r\n      welcome_message_shown: true,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  async markOnboardingComplete(userId: string): Promise<boolean> {\r\n    return this.updateOnboardingStatus(userId, 'complete', {\r\n      onboarding_complete: true,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING FLOW LOGIC\r\n  // ========================================\r\n\r\n  // Helper function to safely get boolean values with defaults\r\n  private getBooleanValue(value: any, defaultValue: boolean = false): boolean {\r\n    if (value === null || value === undefined) {\r\n      return defaultValue;\r\n    }\r\n    return Boolean(value);\r\n  }\r\n\r\n  async getNextOnboardingStep(userId: string): Promise<OnboardingStep> {\r\n    try {\r\n      console.log('ðŸŽ¯ [OnboardingService] Getting next step for user:', userId);\r\n      const status = await this.getOnboardingStatus(userId);\r\n      console.log('ðŸŽ¯ [OnboardingService] User status:', status);\r\n      \r\n      if (!status) {\r\n        console.log('ðŸŽ¯ [OnboardingService] No status found, returning login');\r\n        return 'login';\r\n      }\r\n\r\n\r\n      // Safely get boolean values with defaults\r\n      const hasSeenSplashScreens = this.getBooleanValue(status.has_seen_splash_screens);\r\n      const hasSeenHowToUse = this.getBooleanValue(status.has_seen_how_to_use);\r\n      const hasSeenFeaturesConnected = this.getBooleanValue(status.has_seen_features_connected);\r\n      const hasSeenProFeatures = this.getBooleanValue(status.has_seen_pro_features);\r\n      const pcConnected = this.getBooleanValue(status.pc_connected);\r\n      const pcConnectionSkipped = this.getBooleanValue(status.pc_connection_skipped);\r\n\r\n      console.log('ðŸŽ¯ [OnboardingService] Processed values:', {\r\n        hasSeenSplashScreens,\r\n        hasSeenHowToUse,\r\n        hasSeenFeaturesConnected,\r\n        hasSeenProFeatures,\r\n        pcConnected,\r\n        pcConnectionSkipped\r\n      });\r\n\r\n      // Check onboarding steps in order (matching old build logic)\r\n      if (!hasSeenSplashScreens) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User hasn\\'t seen splash screens, returning initial');\r\n        return 'initial';\r\n      }\r\n\r\n      // After initial splash, go to how-to-use (PC connection)\r\n      if (hasSeenSplashScreens && !hasSeenHowToUse) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User needs to see how-to-use screen, returning how-to-use');\r\n        return 'how-to-use';\r\n      }\r\n\r\n      // If PC connection was successful, show features-connected\r\n      if (hasSeenHowToUse && pcConnected && !hasSeenFeaturesConnected) {\r\n        console.log('ðŸŽ¯ [OnboardingService] PC connected, showing features-connected screen');\r\n        return 'features-connected';\r\n      }\r\n\r\n      // If PC connection was skipped, go to pro-features\r\n      if (hasSeenHowToUse && !pcConnected && pcConnectionSkipped && !hasSeenProFeatures) {\r\n        console.log('ðŸŽ¯ [OnboardingService] PC connection skipped, showing pro-features screen');\r\n        return 'pro-features';\r\n      }\r\n\r\n      // If PC connection failed (not skipped), go back to how-to-use\r\n      if (hasSeenHowToUse && !pcConnected && !pcConnectionSkipped) {\r\n        console.log('ðŸŽ¯ [OnboardingService] PC connection failed, returning to how-to-use screen');\r\n        return 'how-to-use';\r\n      }\r\n\r\n      // After features-connected, go to pro-features\r\n      if (hasSeenFeaturesConnected && !hasSeenProFeatures) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User needs to see pro-features screen, returning pro-features');\r\n        return 'pro-features';\r\n      }\r\n\r\n      // After pro features, onboarding is complete (profile setup is now an overlay)\r\n      if (hasSeenProFeatures) {\r\n        console.log('ðŸŽ¯ [OnboardingService] User has seen pro features, onboarding complete');\r\n        return 'complete';\r\n      }\r\n\r\n      // âœ… FIX: If we reach here, the flow logic has a bug - throw error instead of silently recovering\r\n      // This makes flow bugs visible rather than masking them with fallback behavior\r\n      console.error('ðŸŽ¯ [OnboardingService] ERROR: Unexpected onboarding flow state', {\r\n        hasSeenSplashScreens,\r\n        hasSeenHowToUse,\r\n        hasSeenFeaturesConnected,\r\n        hasSeenProFeatures,\r\n        pcConnected,\r\n        pcConnectionSkipped\r\n      });\r\n      \r\n      // For production stability, return to a safe screen rather than crashing\r\n      // But log the full state so we can diagnose and fix the underlying issue\r\n      return 'how-to-use';\r\n\r\n    } catch (error) {\r\n      console.error('ðŸŽ¯ [OnboardingService] Error getting next onboarding step:', error);\r\n      return 'login';\r\n    }\r\n  }\r\n\r\n  async shouldShowOnboarding(userId: string): Promise<boolean> {\r\n    try {\r\n      const status = await this.getOnboardingStatus(userId);\r\n      \r\n      if (!status) {\r\n        return true;\r\n      }\r\n\r\n      // Check if onboarding is complete\r\n      return !status.onboarding_completed;\r\n\r\n    } catch (error) {\r\n      console.error('Error checking if should show onboarding:', error);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING ANALYTICS\r\n  // ========================================\r\n\r\n  async trackOnboardingStep(userId: string, step: OnboardingStep, action: string, data: any = {}): Promise<void> {\r\n    try {\r\n      await supabase\r\n        .from('user_analytics')\r\n        .insert({\r\n          user_id: userId,\r\n          event_type: 'onboarding_step',\r\n          event_data: {\r\n            step,\r\n            action,\r\n            data,\r\n            timestamp: new Date().toISOString()\r\n          }\r\n        });\r\n\r\n    } catch (error) {\r\n      console.error('Error tracking onboarding step:', error);\r\n    }\r\n  }\r\n\r\n  async trackOnboardingDropOff(userId: string, step: OnboardingStep, reason: string, data: any = {}): Promise<void> {\r\n    try {\r\n      await supabase\r\n        .from('user_analytics')\r\n        .insert({\r\n          user_id: userId,\r\n          event_type: 'onboarding_dropoff',\r\n          event_data: {\r\n            step,\r\n            reason,\r\n            data,\r\n            timestamp: new Date().toISOString()\r\n          }\r\n        });\r\n\r\n    } catch (error) {\r\n      console.error('Error tracking onboarding dropoff:', error);\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING RESET\r\n  // ========================================\r\n\r\n  async resetOnboarding(userId: string): Promise<boolean> {\r\n    try {\r\n      // Clear onboarding progress\r\n      const { error: progressError } = await supabase\r\n        .from('onboarding_progress')\r\n        .delete()\r\n        .eq('user_id', userId);\r\n\r\n      if (progressError) {\r\n        console.error('Error clearing onboarding progress:', progressError);\r\n        return false;\r\n      }\r\n\r\n      // Reset user onboarding flags\r\n      const { error: userError } = await supabase\r\n        .from('users')\r\n        .update({\r\n          is_new_user: true,\r\n          has_seen_splash_screens: false,\r\n          has_profile_setup: false,\r\n          has_welcome_message: false,\r\n          onboarding_completed: false,\r\n          onboarding_data: {}\r\n        })\r\n        .eq('id', userId);\r\n\r\n      if (userError) {\r\n        console.error('Error resetting user onboarding flags:', userError);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Error resetting onboarding:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ========================================\r\n  // ONBOARDING STATISTICS\r\n  // ========================================\r\n\r\n  async getOnboardingStats(): Promise<{\r\n    total_users: number;\r\n    completed_onboarding: number;\r\n    dropoff_by_step: Record<string, number>;\r\n  }> {\r\n    try {\r\n      // Get total users\r\n      const { count: totalUsers } = await supabase\r\n        .from('users')\r\n        .select('*', { count: 'exact', head: true });\r\n\r\n      // Get users who completed onboarding\r\n      const { count: completedUsers } = await supabase\r\n        .from('users')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('onboarding_completed', true);\r\n\r\n      // Get dropoff by step\r\n      const { data: dropoffData } = await supabase\r\n        .from('user_analytics')\r\n        .select('event_data')\r\n        .eq('event_type', 'onboarding_dropoff');\r\n\r\n      const dropoffByStep: Record<string, number> = {};\r\n      if (dropoffData) {\r\n        dropoffData.forEach(record => {\r\n          const eventData = record.event_data;\r\n          if (typeof eventData === 'object' && eventData !== null && !Array.isArray(eventData)) {\r\n            const step = (eventData as Record<string, unknown>).step;\r\n            if (typeof step === 'string') {\r\n              dropoffByStep[step] = (dropoffByStep[step] || 0) + 1;\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      return {\r\n        total_users: totalUsers || 0,\r\n        completed_onboarding: completedUsers || 0,\r\n        dropoff_by_step: dropoffByStep\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Error getting onboarding stats:', error);\r\n      return {\r\n        total_users: 0,\r\n        completed_onboarding: 0,\r\n        dropoff_by_step: {}\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// ========================================\r\n// EXPORT SINGLETON INSTANCE\r\n// ========================================\r\n\r\nexport const onboardingService = OnboardingService.getInstance();\r\nexport default onboardingService;\r\n","let ws: WebSocket | null = null;\r\nconst SERVER_ADDRESS = 'wss://otakon-relay.onrender.com';\r\n\r\nlet reconnectAttempts = 0;\r\nconst maxBackoffMs = 5000;\r\nconst sendQueue: object[] = [];\r\nlet lastCode: string | null = null;\r\nlet handlers: { onOpen: () => void; onMessage: (data: any) => void; onError: (error: string) => void; onClose: () => void } | null = null;\r\nlet heartbeatTimer: number | null = null;\r\nlet shouldReconnect = true; // âœ… FIX: Flag to prevent reconnection after explicit disconnect\r\nconst HEARTBEAT_MS = 30000; // 30s - more frequent heartbeat to maintain connection\r\n\r\n\r\nconst connect = (\r\n  code: string,\r\n  onOpen: () => void,\r\n  onMessage: (data: any) => void,\r\n  onError: (error: string) => void,\r\n  onClose: () => void\r\n) => {\r\n\r\n  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {\r\n    // Skip logging for already connected state\r\n    return;\r\n  }\r\n\r\n  // Only accept 6-digit codes\r\n  if (!/^\\d{6}$/.test(code)) {\r\n    onError(\"Invalid code format. Please enter a 6-digit code.\");\r\n    return;\r\n  }\r\n\r\n  lastCode = code;\r\n  handlers = { onOpen, onMessage, onError, onClose };\r\n  shouldReconnect = true; // âœ… FIX: Enable reconnection for new connections\r\n\r\n  const fullUrl = `${SERVER_ADDRESS}/${code}`;\r\n\r\n  try {\r\n    ws = new WebSocket(fullUrl);\r\n  } catch (e) {\r\n    const message = e instanceof Error ? e.message : \"An unknown error occurred.\";\r\n    onError(`Connection failed: ${message}. Please check the URL and your network connection.`);\r\n    return;\r\n  }\r\n\r\n  ws.onopen = () => {\r\n    // Connection established - no need to log every connection\r\n    reconnectAttempts = 0;\r\n    onOpen();\r\n    // Flush queued messages\r\n    while (sendQueue.length && ws && ws.readyState === WebSocket.OPEN) {\r\n      const payload = sendQueue.shift();\r\n      try { \r\n        ws.send(JSON.stringify(payload)); \r\n      } catch {\r\n        // Ignore send errors during queue processing\r\n      }\r\n    }\r\n\r\n    // Start heartbeat\r\n    if (heartbeatTimer) {\r\n      clearInterval(heartbeatTimer);\r\n      heartbeatTimer = null;\r\n    }\r\n    heartbeatTimer = window.setInterval(() => {\r\n      if (ws && ws.readyState === WebSocket.OPEN) {\r\n        try { \r\n          ws.send(JSON.stringify({ type: 'ping', ts: Date.now() })); \r\n        } catch {\r\n          // Ignore heartbeat send errors\r\n        }\r\n      }\r\n    }, HEARTBEAT_MS);\r\n  };\r\n\r\n  ws.onmessage = (event) => {\r\n    try {\r\n      const data = JSON.parse(event.data);\r\n      // Only log errors in development, not every message\r\n      onMessage(data);\r\n    } catch (e) {\r\n      if (process.env.NODE_ENV === 'development') {\r\n        console.error(\"Failed to parse WebSocket message:\", event.data, e);\r\n      }\r\n      // Ignore non-JSON\r\n    }\r\n  };\r\n\r\n  ws.onerror = () => {\r\n    // Handled by onclose\r\n  };\r\n\r\n  ws.onclose = (event: CloseEvent) => {\r\n    // Only log unexpected closures\r\n    if (!event.wasClean && process.env.NODE_ENV === 'development') {\r\n      console.warn(`WebSocket connection closed unexpectedly. Code: ${event.code}, Reason: '${event.reason}'`);\r\n    }\r\n\r\n    if (!event.wasClean) {\r\n      let errorMessage = \"Connection closed unexpectedly.\";\r\n      if (event.code === 1006) {\r\n        errorMessage = \"Connection to the server failed. Please check your network, verify the code, and ensure the PC client is running.\";\r\n      } else if (event.reason) {\r\n        errorMessage = `Connection closed: ${event.reason}`;\r\n      }\r\n      onError(errorMessage);\r\n    }\r\n\r\n    ws = null;\r\n    onClose();\r\n\r\n    // Stop heartbeat\r\n    if (heartbeatTimer) {\r\n      clearInterval(heartbeatTimer);\r\n      heartbeatTimer = null;\r\n    }\r\n\r\n    // Auto-reconnect with backoff+jitter (only if not explicitly disconnected)\r\n    // âœ… FIX: Check shouldReconnect flag to prevent reconnection after explicit disconnect\r\n    if (shouldReconnect && lastCode && handlers) {\r\n      reconnectAttempts += 1;\r\n      const base = Math.min(maxBackoffMs, 500 * Math.pow(2, reconnectAttempts - 1));\r\n      const jitter = Math.random() * 300;\r\n      const delay = base + jitter;\r\n      setTimeout(() => {\r\n        if (!ws && handlers && shouldReconnect) {\r\n          connect(lastCode!, handlers.onOpen, handlers.onMessage, handlers.onError, handlers.onClose);\r\n        }\r\n      }, delay);\r\n    }\r\n  };\r\n};\r\n\r\nconst send = (data: object) => {\r\n  if (ws && ws.readyState === WebSocket.OPEN) {\r\n    ws.send(JSON.stringify(data));\r\n  } else {\r\n    // Queue and let onopen flush\r\n    sendQueue.push(data);\r\n    // Message queued - no need to log every queued message\r\n  }\r\n};\r\n\r\nconst disconnect = () => {\r\n  // âœ… FIX: Set flag FIRST to prevent race condition with onclose handler\r\n  shouldReconnect = false;\r\n  \r\n  if (ws) {\r\n    ws.close(1000, \"User disconnected\");\r\n    ws = null;\r\n  }\r\n  reconnectAttempts = 0;\r\n  if (heartbeatTimer) {\r\n    clearInterval(heartbeatTimer);\r\n    heartbeatTimer = null;\r\n  }\r\n  \r\n  // Clear all connection state to prevent auto-reconnection after logout\r\n  lastCode = null;\r\n  handlers = null;\r\n  \r\n  // Clear any pending reconnection attempts\r\n  if (process.env.NODE_ENV === 'development') {\r\n    console.log(\"ðŸ”Œ WebSocket disconnected and all reconnection state cleared\");\r\n  }\r\n};\r\n\r\nexport { connect, disconnect, send };\r\n","import { supabase } from '../lib/supabase';\r\n\r\nexport interface WaitlistEntry {\r\n  id?: string;\r\n  email: string;\r\n  created_at?: string;\r\n  source?: string;\r\n  status?: 'pending' | 'approved' | 'rejected';\r\n}\r\n\r\nexport class WaitlistService {\r\n  static async addToWaitlist(email: string, source: string = 'landing_page'): Promise<{ success: boolean; error?: string; alreadyExists?: boolean }> {\r\n    try {\r\n      console.log('Adding to waitlist using direct table operations');\r\n      \r\n      // Try to insert directly first - this will fail if email already exists\r\n      const { data: insertData, error: insertError } = await supabase\r\n        .from('waitlist')\r\n        .insert({\r\n          email,\r\n          source,\r\n          status: 'pending'\r\n        })\r\n        .select();\r\n\r\n      if (insertError) {\r\n        console.error('Error adding to waitlist:', insertError);\r\n        console.error('Insert error details:', {\r\n          message: insertError.message,\r\n          code: insertError.code,\r\n          details: insertError.details,\r\n          hint: insertError.hint\r\n        });\r\n        \r\n        // Check if it's a duplicate key error (email already exists)\r\n        if (insertError.code === '23505') {\r\n          return { \r\n            success: true, \r\n            alreadyExists: true,\r\n            error: 'You\\'re already on our waitlist! We\\'ll email you when access is ready.'\r\n          };\r\n        }\r\n        \r\n        // For other errors, try to check if email exists first\r\n        const { data: existing, error: checkError } = await supabase\r\n          .from('waitlist')\r\n          .select('email, status, created_at')\r\n          .eq('email', email)\r\n          .maybeSingle();\r\n\r\n        if (checkError) {\r\n          console.error('Error checking existing email:', checkError);\r\n          return { success: false, error: `Failed to add to waitlist: ${insertError.message}` };\r\n        }\r\n\r\n        if (existing) {\r\n          return { \r\n            success: true, \r\n            alreadyExists: true,\r\n            error: 'You\\'re already on our waitlist! We\\'ll email you when access is ready.'\r\n          };\r\n        }\r\n        \r\n        return { success: false, error: `Failed to add to waitlist: ${insertError.message}` };\r\n      }\r\n\r\n      console.log('Successfully added to waitlist:', insertData);\r\n      return { \r\n        success: true, \r\n        alreadyExists: false,\r\n        error: undefined\r\n      };\r\n    } catch (error) {\r\n      console.error('Waitlist service error:', error);\r\n      return { success: false, error: 'An unexpected error occurred' };\r\n    }\r\n  }\r\n\r\n  // Get waitlist count (for display purposes)\r\n  static async getWaitlistCount(): Promise<{ count?: number; error?: string }> {\r\n    try {\r\n      // Use direct table query (no function calls to avoid 404 errors)\r\n      const { count, error } = await supabase\r\n        .from('waitlist')\r\n        .select('*', { count: 'exact', head: true });\r\n\r\n      if (error) {\r\n        console.error('Error getting waitlist count:', error);\r\n        return { error: 'Failed to get count' };\r\n      }\r\n\r\n      return { count: count || 0 };\r\n    } catch (error) {\r\n      console.error('Error getting waitlist count:', error);\r\n      return { error: 'Failed to get count' };\r\n    }\r\n  }\r\n\r\n  static async getWaitlistStats(): Promise<{ total: number; pending: number; invited: number; converted: number }> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('waitlist')\r\n        .select('status');\r\n\r\n      if (error) {\r\n        console.error('Error fetching waitlist stats:', error);\r\n        // Return default stats instead of zeros to maintain UI consistency\r\n        return { total: 137, pending: 137, invited: 0, converted: 0 };\r\n      }\r\n\r\n      const stats = {\r\n        total: data.length,\r\n        pending: 0,\r\n        invited: 0,\r\n        converted: 0\r\n      };\r\n\r\n      data.forEach(entry => {\r\n        const status = entry.status || 'pending';\r\n        if (status === 'pending') {\r\n          stats.pending++;\r\n        } else if (status === 'approved') {\r\n          stats.invited++;\r\n        } else if (status === 'rejected') {\r\n          stats.converted++;\r\n        }\r\n      });\r\n\r\n      return stats;\r\n    } catch (error) {\r\n      console.error('Error fetching waitlist stats:', error);\r\n      // Return default stats instead of zeros to maintain UI consistency\r\n      return { total: 137, pending: 137, invited: 0, converted: 0 };\r\n    }\r\n  }\r\n}\r\n","export class StorageService {\r\n  static get<T>(key: string, defaultValue: T): T {\r\n    try {\r\n      const item = localStorage.getItem(key);\r\n      return item ? JSON.parse(item) : defaultValue;\r\n    } catch (error) {\r\n      console.error(`Error getting ${key} from localStorage:`, error);\r\n      return defaultValue;\r\n    }\r\n  }\r\n\r\n  static set<T>(key: string, value: T): void {\r\n    try {\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n    } catch (error) {\r\n      console.error(`Error setting ${key} in localStorage:`, error);\r\n    }\r\n  }\r\n\r\n  static remove(key: string): void {\r\n    try {\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.error(`Error removing ${key} from localStorage:`, error);\r\n    }\r\n  }\r\n\r\n  static clear(): void {\r\n    try {\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error);\r\n    }\r\n  }\r\n}\r\n","import { cacheService } from './cacheService';\r\nimport { Conversation, ChatMessage } from '../types';\r\n\r\n/**\r\n * Chat Memory Service using centralized cache\r\n * Handles chat persistence, context, and memory management\r\n */\r\nclass ChatMemoryService {\r\n  private readonly CONVERSATION_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days\r\n  private readonly CONTEXT_TTL = 24 * 60 * 60 * 1000; // 24 hours\r\n\r\n  /**\r\n   * Save conversation with full context\r\n   */\r\n  async saveConversation(conversation: Conversation, userId?: string): Promise<void> {\r\n    const key = `conversation:${conversation.id}`;\r\n    await cacheService.set(key, conversation, this.CONVERSATION_TTL, 'conversation', userId);\r\n  }\r\n\r\n  /**\r\n   * Load conversation with context\r\n   */\r\n  async loadConversation(conversationId: string): Promise<Conversation | null> {\r\n    const key = `conversation:${conversationId}`;\r\n    return await cacheService.get<Conversation>(key);\r\n  }\r\n\r\n  /**\r\n   * Save chat context (recent messages, user preferences, etc.)\r\n   */\r\n  async saveChatContext(userId: string, context: {\r\n    recentMessages: ChatMessage[];\r\n    userPreferences: any;\r\n    gameContext: any;\r\n    conversationSummary: string;\r\n  }): Promise<void> {\r\n    await cacheService.setChatContext(userId, context);\r\n  }\r\n\r\n  /**\r\n   * Load chat context\r\n   */\r\n  async loadChatContext(userId: string): Promise<any | null> {\r\n    return await cacheService.getChatContext(userId);\r\n  }\r\n\r\n  /**\r\n   * Save AI memory/insights about user\r\n   */\r\n  async saveUserMemory(userId: string, memory: {\r\n    preferences: any;\r\n    playStyle: string;\r\n    favoriteGames: string[];\r\n    lastInteractions: any[];\r\n    personalityProfile: any;\r\n  }): Promise<void> {\r\n    await cacheService.setUserMemory(userId, memory);\r\n  }\r\n\r\n  /**\r\n   * Load AI memory about user\r\n   */\r\n  async loadUserMemory(userId: string): Promise<any | null> {\r\n    return await cacheService.getUserMemory(userId);\r\n  }\r\n\r\n  /**\r\n   * Save conversation summary for quick context\r\n   */\r\n  async saveConversationSummary(conversationId: string, summary: {\r\n    keyPoints: string[];\r\n    userQuestions: string[];\r\n    aiInsights: string[];\r\n    gameContext: any;\r\n  }): Promise<void> {\r\n    const key = `conversation_summary:${conversationId}`;\r\n    await cacheService.set(key, summary, this.CONTEXT_TTL);\r\n  }\r\n\r\n  /**\r\n   * Load conversation summary\r\n   */\r\n  async loadConversationSummary(conversationId: string): Promise<any | null> {\r\n    const key = `conversation_summary:${conversationId}`;\r\n    return await cacheService.get(key);\r\n  }\r\n\r\n  /**\r\n   * Save game-specific context\r\n   */\r\n  async saveGameContext(userId: string, gameId: string, context: {\r\n    currentProgress: any;\r\n    lastScreenshot: string;\r\n    recentHints: string[];\r\n    userFrustrationLevel: number;\r\n    preferredHintStyle: string;\r\n  }): Promise<void> {\r\n    await cacheService.setGameContext(userId, gameId, context);\r\n  }\r\n\r\n  /**\r\n   * Load game-specific context\r\n   */\r\n  async loadGameContext(userId: string, gameId: string): Promise<any | null> {\r\n    return await cacheService.getGameContext(userId, gameId);\r\n  }\r\n\r\n  /**\r\n   * Get all user conversations (for sidebar)\r\n   */\r\n  async getUserConversations(_userId: string): Promise<Conversation[]> {\r\n    // This would need a different approach - maybe a separate table\r\n    // For now, we'll use a pattern-based approach\r\n    const conversations: Conversation[] = [];\r\n    \r\n    // In a real implementation, you'd query a conversations table\r\n    // or use a different caching strategy for this\r\n    return conversations;\r\n  }\r\n\r\n  /**\r\n   * Clear all chat data for a user\r\n   */\r\n  async clearUserChatData(userId: string): Promise<void> {\r\n    // Use the enhanced cache service to clear all user data\r\n    await cacheService.clearUserCache(userId);\r\n  }\r\n}\r\n\r\nexport const chatMemoryService = new ChatMemoryService();\r\n","/**\r\n * Parses AI responses to extract OTAKON tags and clean content\r\n */\r\nexport const parseOtakonTags = (rawContent: string): { cleanContent: string; tags: Map<string, any> } => {\r\n  const tags = new Map<string, any>();\r\n  const tagRegex = /\\[OTAKON_([A-Z_]+):\\s*(.*?)\\]/g;\r\n\r\n  let cleanContent = rawContent;\r\n  let match;\r\n\r\n  while ((match = tagRegex.exec(rawContent)) !== null) {\r\n    const tagName = match[1];\r\n    let tagValue: any = match[2].trim();\r\n\r\n    console.log(`ðŸ” [OtakonTags] Found tag: ${tagName}, raw value: \"${tagValue}\"`);\r\n\r\n    // Parse JSON for complex tags\r\n    try {\r\n      if (tagValue.startsWith('{') && tagValue.endsWith('}')) {\r\n        tagValue = JSON.parse(tagValue);\r\n        console.log(`ðŸ” [OtakonTags] Parsed as JSON object:`, tagValue);\r\n      }\r\n      if (tagValue.startsWith('[') && tagValue.endsWith(']')) {\r\n        tagValue = JSON.parse(tagValue.replace(/'/g, '\"'));\r\n        console.log(`ðŸ” [OtakonTags] Parsed as JSON array:`, tagValue);\r\n      }\r\n    } catch (_e) {\r\n      console.log(`ðŸ” [OtakonTags] JSON parsing failed, keeping as string:`, tagValue);\r\n      // Keep as string if not valid JSON\r\n    }\r\n\r\n    tags.set(tagName, tagValue);\r\n    cleanContent = cleanContent.replace(match[0], '');\r\n  }\r\n\r\n  // Clean up extra whitespace and empty lines\r\n  cleanContent = cleanContent\r\n    .replace(/^Hint:\\s*\\n\\s*Hint:\\s*/gm, 'Hint: ') // Fix duplicate Hint headers\r\n    .replace(/^Hint:\\s*\\n\\s*Hint:\\s*/gm, 'Hint: ') // Fix multiple duplicate Hint headers\r\n    .replace(/\\s*\\]\\s*$/, '') // Remove trailing ] characters with surrounding whitespace\r\n    .replace(/\\s*\\[\\s*$/, '') // Remove trailing [ characters with surrounding whitespace\r\n    .replace(/^\\s*\\]\\s*/, '') // Remove leading ] characters with surrounding whitespace\r\n    .replace(/^\\s*\\[\\s*/, '') // Remove leading [ characters with surrounding whitespace\r\n    // âœ… Fix malformed bold markers (spaces between ** and text)\r\n    .replace(/\\*\\*\\s+([^*]+?)\\s+\\*\\*/g, '**$1**') // Fix ** text ** â†’ **text**\r\n    .replace(/\\*\\*\\s+([^*]+?):/g, '**$1:**') // Fix ** Header: â†’ **Header:**\r\n    // âœ… Format section headers with proper spacing and bold\r\n    // First, ensure headers are properly closed with ** and add line breaks\r\n    .replace(/\\*\\*Hint:\\*\\*\\s*/gi, '**Hint:**\\n') // Add line break after Hint (handles trailing space)\r\n    .replace(/\\*\\*Lore:\\*\\*\\s*/gi, '\\n\\n**Lore:**\\n') // Add line breaks around Lore\r\n    .replace(/\\*\\*Places of Interest:\\*\\*\\s*/gi, '\\n\\n**Places of Interest:**\\n') // Add line breaks around Places\r\n    .replace(/\\*\\*Strategy:\\*\\*\\s*/gi, '\\n\\n**Strategy:**\\n') // Add line breaks around Strategy\r\n    .replace(/\\*\\*What to focus on:\\*\\*\\s*/gi, '\\n\\n**What to focus on:**\\n') // Add line breaks around What to focus\r\n    // Handle headers without existing bold (with or without trailing space)\r\n    .replace(/^Hint:\\s*/i, '**Hint:**\\n') // First Hint at very start\r\n    .replace(/\\nHint:\\s*/gi, '\\n\\n**Hint:**\\n') // Subsequent Hints after newline\r\n    .replace(/\\nLore:\\s*/gi, '\\n\\n**Lore:**\\n') // Lore after newline\r\n    .replace(/\\nPlaces of Interest:\\s*/gi, '\\n\\n**Places of Interest:**\\n') // Places after newline\r\n    .replace(/\\nStrategy:\\s*/gi, '\\n\\n**Strategy:**\\n') // Strategy after newline  \r\n    .replace(/\\nWhat to focus on:\\s*/gi, '\\n\\n**What to focus on:**\\n') // What to focus after newline\r\n    // Clean up spacing\r\n    .replace(/\\n{3,}/g, '\\n\\n') // Remove excessive line breaks (3+ newlines â†’ 2)\r\n    .replace(/^\\s+|\\s+$/g, '') // Trim start and end\r\n    .trim();\r\n\r\n  return { cleanContent, tags };\r\n};\r\n\r\n","import { SubTab, PlayerProfile } from '../types';\r\n\r\nexport interface GameContext {\r\n  playthroughCount?: number;\r\n  lastSessionDate?: number;\r\n  totalPlayTime?: number;\r\n  objectivesCompleted?: string[];\r\n  secretsFound?: string[];\r\n}\r\n\r\nexport interface ProfileSpecificTab extends Omit<SubTab, 'content' | 'isNew' | 'status'> {\r\n  priority: 'high' | 'medium' | 'low';\r\n  isProfileSpecific: boolean;\r\n}\r\n\r\nclass ProfileAwareTabService {\r\n  private static instance: ProfileAwareTabService;\r\n\r\n  private constructor() {}\r\n\r\n  static getInstance(): ProfileAwareTabService {\r\n    if (!ProfileAwareTabService.instance) {\r\n      ProfileAwareTabService.instance = new ProfileAwareTabService();\r\n    }\r\n    return ProfileAwareTabService.instance;\r\n  }\r\n\r\n  /**\r\n   * Generate additional tabs based on player profile\r\n   * These tabs are added to the base genre tabs\r\n   */\r\n  generateProfileSpecificTabs(\r\n    profile: PlayerProfile,\r\n    gameContext?: GameContext\r\n  ): ProfileSpecificTab[] {\r\n    const tabs: ProfileSpecificTab[] = [];\r\n\r\n    // Add tabs based on player focus\r\n    if (profile.playerFocus === 'Story-Driven') {\r\n      tabs.push({\r\n        id: 'narrative_themes',\r\n        title: 'Narrative Themes',\r\n        type: 'story',\r\n        priority: 'high',\r\n        isProfileSpecific: true,\r\n        instruction: this.getNarrativeThemesInstruction(profile.hintStyle),\r\n      });\r\n    }\r\n\r\n    if (profile.playerFocus === 'Completionist') {\r\n      tabs.push({\r\n        id: 'secret_hunting',\r\n        title: 'Secret Hunting',\r\n        type: 'tips',\r\n        priority: 'high',\r\n        isProfileSpecific: true,\r\n        instruction: this.getSecretHuntingInstruction(profile.hintStyle),\r\n      });\r\n    }\r\n\r\n    if (profile.playerFocus === 'Strategist') {\r\n      tabs.push({\r\n        id: 'optimization_guide',\r\n        title: 'Optimization Guide',\r\n        type: 'strategies',\r\n        priority: 'high',\r\n        isProfileSpecific: true,\r\n        instruction: this.getOptimizationInstruction(profile.hintStyle),\r\n      });\r\n    }\r\n\r\n    // Add playthrough-specific tabs for returning players\r\n    if (gameContext?.playthroughCount && gameContext.playthroughCount > 1) {\r\n      tabs.push({\r\n        id: 'playthrough_comparison',\r\n        title: 'Playthrough Comparison',\r\n        type: 'tips',\r\n        priority: 'medium',\r\n        isProfileSpecific: true,\r\n        instruction: this.getPlaythroughComparisonInstruction(profile),\r\n      });\r\n    }\r\n\r\n    return tabs;\r\n  }\r\n\r\n  /**\r\n   * Get custom instructions for Narrative Themes tab based on hint style\r\n   */\r\n  private getNarrativeThemesInstruction(hintStyle: string): string {\r\n    const instructions: Record<string, string> = {\r\n      Cryptic:\r\n        'Provide subtle hints about story themes without revealing major plot points. Use metaphorical language and thematic connections.',\r\n      Balanced:\r\n        'Discuss narrative elements with moderate detail, balancing spoiler avoidance with meaningful insight into themes and character arcs.',\r\n      Direct:\r\n        'Explain story themes clearly while maintaining appropriate spoiler warnings. Provide direct analysis of narrative elements encountered so far.',\r\n    };\r\n    return instructions[hintStyle] || instructions['Balanced'];\r\n  }\r\n\r\n  /**\r\n   * Get custom instructions for Secret Hunting tab based on hint style\r\n   */\r\n  private getSecretHuntingInstruction(hintStyle: string): string {\r\n    const instructions: Record<string, string> = {\r\n      Cryptic:\r\n        'Give mysterious clues about hidden content locations. Use environmental riddles and subtle hints that require exploration.',\r\n      Balanced:\r\n        'Provide clear directions to secrets with some exploration challenge. Balance helpfulness with maintaining the joy of discovery.',\r\n      Direct:\r\n        'Give precise locations and requirements for finding secrets. Include step-by-step instructions and exact coordinates when helpful.',\r\n    };\r\n    return instructions[hintStyle] || instructions['Balanced'];\r\n  }\r\n\r\n  /**\r\n   * Get custom instructions for Optimization Guide tab based on hint style\r\n   */\r\n  private getOptimizationInstruction(hintStyle: string): string {\r\n    const instructions: Record<string, string> = {\r\n      Cryptic:\r\n        'Suggest optimization strategies through hints and examples. Let the player discover the optimal path with guidance.',\r\n      Balanced:\r\n        'Provide balanced optimization advice with clear explanations. Suggest effective approaches while leaving room for experimentation.',\r\n      Direct:\r\n        'Give specific optimization recommendations with detailed steps. Provide exact stat allocations, builds, and strategies for maximum efficiency.',\r\n    };\r\n    return instructions[hintStyle] || instructions['Direct'];\r\n  }\r\n\r\n  /**\r\n   * Get custom instructions for Playthrough Comparison tab\r\n   */\r\n  private getPlaythroughComparisonInstruction(profile: PlayerProfile): string {\r\n    return `Compare different playthrough approaches based on ${profile.playerFocus} style and ${profile.hintStyle} preferences. Highlight what's different this time and suggest new strategies to explore.`;\r\n  }\r\n\r\n  /**\r\n   * Prioritize tabs based on player profile\r\n   * Profile-specific tabs get higher priority, then by assigned priority level\r\n   */\r\n  prioritizeTabsForProfile(\r\n    tabs: ProfileSpecificTab[],\r\n    _profile: PlayerProfile\r\n  ): ProfileSpecificTab[] {\r\n    return tabs.sort((a, b) => {\r\n      // Profile-specific tabs get highest priority\r\n      if (a.isProfileSpecific && !b.isProfileSpecific) {\r\n        return -1;\r\n      }\r\n      if (!a.isProfileSpecific && b.isProfileSpecific) {\r\n        return 1;\r\n      }\r\n\r\n      // Then by priority level\r\n      const priorityOrder = { high: 3, medium: 2, low: 1 };\r\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get hint style modifier for AI prompts\r\n   * This modifies how AI generates content based on user preference\r\n   */\r\n  getHintStyleModifier(hintStyle: string): string {\r\n    const modifiers: Record<string, string> = {\r\n      Cryptic:\r\n        'Use subtle, metaphorical hints. Avoid direct answers. Make the player think and discover.',\r\n      Balanced:\r\n        'Provide clear guidance while leaving room for exploration. Balance helpfulness with discovery.',\r\n      Direct:\r\n        'Give explicit, step-by-step instructions. Be precise and comprehensive in explanations.',\r\n    };\r\n    return modifiers[hintStyle] || modifiers['Balanced'];\r\n  }\r\n\r\n  /**\r\n   * Get player focus modifier for AI prompts\r\n   * This adjusts content emphasis based on what the player cares about\r\n   */\r\n  getPlayerFocusModifier(playerFocus: string): string {\r\n    const modifiers: Record<string, string> = {\r\n      'Story-Driven':\r\n        'Emphasize narrative elements, character development, and story context. Prioritize lore and thematic content.',\r\n      Completionist:\r\n        'Focus on collectibles, hidden items, side quests, and 100% completion strategies. Highlight missable content.',\r\n      Strategist:\r\n        'Prioritize optimal strategies, build optimization, and efficient progression. Focus on mechanics and systems.',\r\n    };\r\n    return modifiers[playerFocus] || modifiers['Strategist'];\r\n  }\r\n\r\n  /**\r\n   * Get spoiler tolerance modifier for AI prompts\r\n   * Controls how much future content can be hinted at\r\n   */\r\n  getSpoilerToleranceModifier(spoilerTolerance: string): string {\r\n    const modifiers: Record<string, string> = {\r\n      Strict:\r\n        'NEVER mention future events, characters, or plot points. Only discuss content up to current progress.',\r\n      Moderate:\r\n        'You may hint at upcoming content in vague terms, but avoid specific spoilers.',\r\n      Relaxed:\r\n        'You can discuss future content more freely, but still mark major spoilers clearly.',\r\n    };\r\n    return modifiers[spoilerTolerance] || modifiers['Strict'];\r\n  }\r\n\r\n  /**\r\n   * Get tone modifier for AI prompts\r\n   * Adjusts the conversational style of responses\r\n   */\r\n  getToneModifier(preferredTone: string): string {\r\n    const modifiers: Record<string, string> = {\r\n      Encouraging:\r\n        'Use an enthusiastic, supportive tone. Celebrate achievements and provide positive reinforcement.',\r\n      Professional:\r\n        'Maintain a knowledgeable, respectful tone. Provide expertise without excessive casualness.',\r\n      Casual:\r\n        'Use a friendly, conversational tone. Feel free to use gaming terminology and be relaxed.',\r\n    };\r\n    return modifiers[preferredTone] || modifiers['Professional'];\r\n  }\r\n\r\n  /**\r\n   * Build complete profile context for AI prompts\r\n   * Combines all profile modifiers into a single instruction block\r\n   */\r\n  buildProfileContext(profile: PlayerProfile): string {\r\n    const parts = [\r\n      `Hint Style: ${this.getHintStyleModifier(profile.hintStyle)}`,\r\n      `Player Focus: ${this.getPlayerFocusModifier(profile.playerFocus)}`,\r\n      `Spoiler Tolerance: ${this.getSpoilerToleranceModifier(profile.spoilerTolerance)}`,\r\n      `Tone: ${this.getToneModifier(profile.preferredTone)}`,\r\n    ];\r\n\r\n    return parts.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Get default profile for users who skipped profile setup\r\n   */\r\n  getDefaultProfile(): PlayerProfile {\r\n    return {\r\n      hintStyle: 'Balanced',\r\n      playerFocus: 'Strategist',\r\n      preferredTone: 'Professional',\r\n      spoilerTolerance: 'Strict',\r\n    };\r\n  }\r\n}\r\n\r\nexport const profileAwareTabService = ProfileAwareTabService.getInstance();\r\n\r\n","import { Conversation, User, PlayerProfile } from '../types';\r\nimport { profileAwareTabService } from './profileAwareTabService';\r\n\r\n// OTAKON tag definitions for the AI\r\nconst OTAKON_TAG_DEFINITIONS = `\r\nYou MUST use the following tags to structure your response. Do not put them in a code block.\r\n- [OTAKON_GAME_ID: Game Name]: The full, official name of the game you've identified.\r\n- [OTAKON_CONFIDENCE: high|low]: Your confidence in the game identification.\r\n- [OTAKON_GENRE: Genre]: The primary genre of the identified game. Must be one of:\r\n  â€¢ Action RPG - Action-focused RPGs with real-time combat (Dark Souls, God of War, etc.)\r\n  â€¢ RPG - Traditional role-playing games with deep stories and character progression\r\n  â€¢ Souls-like - Challenging action games inspired by Dark Souls (Elden Ring, Sekiro, Hollow Knight, etc.)\r\n  â€¢ Metroidvania - Non-linear exploration platformers with ability-gated progression\r\n  â€¢ Open-World - Large open-world games with exploration focus (GTA, Zelda: BOTW, etc.)\r\n  â€¢ Survival-Crafting - Survival games with resource gathering and crafting mechanics\r\n  â€¢ First-Person Shooter - FPS games\r\n  â€¢ Strategy - Strategy and tactical games (RTS, turn-based, 4X)\r\n  â€¢ Adventure - Story-driven adventure and narrative games\r\n  â€¢ Simulation - Simulation and management games\r\n  â€¢ Sports - Sports games and sports management sims\r\n  â€¢ Multiplayer Shooter - Competitive multiplayer FPS games\r\n  â€¢ Multiplayer Sports - Competitive multiplayer sports games\r\n  â€¢ Racing - Racing games and driving sims\r\n  â€¢ Fighting - Fighting games\r\n  â€¢ Battle Royale - Battle royale games\r\n  â€¢ MMORPG - Massively multiplayer online RPGs\r\n  â€¢ Puzzle - Puzzle games\r\n  â€¢ Horror - Horror and survival horror games\r\n  â€¢ Default - Use this only if none of the above genres fit\r\n  **Important**: Use the EXACT genre names listed above. Choose the MOST SPECIFIC genre that fits the game.\r\n- [OTAKON_GAME_STATUS: unreleased]: ONLY include this tag if the game is NOT YET RELEASED. Verify the release date before including this tag.\r\n- [OTAKON_IS_FULLSCREEN: true|false]: Whether the screenshot shows fullscreen gameplay (not menus, launchers, or non-game screens).\r\n- [OTAKON_TRIUMPH: {\"type\": \"boss_defeated\", \"name\": \"Boss Name\"}]: When analyzing a victory screen.\r\n- [OTAKON_OBJECTIVE_SET: {\"description\": \"New objective\"}]: When a new player objective is identified.\r\n- [OTAKON_INSIGHT_UPDATE: {\"id\": \"sub_tab_id\", \"content\": \"content\"}]: To update a specific sub-tab.\r\n- [OTAKON_INSIGHT_MODIFY_PENDING: {\"id\": \"sub_tab_id\", \"title\": \"New Title\", \"content\": \"New content\"}]: When user asks to modify a subtab via @command.\r\n- [OTAKON_INSIGHT_DELETE_REQUEST: {\"id\": \"sub_tab_id\"}]: When user asks to delete a subtab via @command.\r\n- [OTAKON_SUGGESTIONS: [\"suggestion1\", \"suggestion2\", \"suggestion3\"]]: Three contextual follow-up prompts for the user. Make these short, specific questions that help the user learn more about the current situation, get tips, or understand what to do next.\r\n`;\r\n\r\n// Command Centre instructions for subtab management\r\nconst COMMAND_CENTRE_INSTRUCTIONS = `\r\n**Command Centre - Subtab Management:**\r\nUsers can manage subtabs using @ commands:\r\n1. **@<tab_name> <instruction>**: Update a subtab with new information\r\n   - Example: \"@story_so_far The player just defeated the first boss\"\r\n   - Response: Include [OTAKON_INSIGHT_UPDATE: {\"id\": \"story_so_far\", \"content\": \"The player has...[updated content based on instruction]\"}]\r\n   \r\n2. **@<tab_name> \\\\modify**: Modify or rename a subtab\r\n   - Example: \"@tips \\\\modify change this to combat strategies\"\r\n   - Response: Include [OTAKON_INSIGHT_MODIFY_PENDING: {\"id\": \"tips\", \"title\": \"Combat Strategies\", \"content\": \"[updated content]\"}]\r\n   \r\n3. **@<tab_name> \\\\delete**: Delete a subtab\r\n   - Example: \"@unused_tab \\\\delete\"\r\n   - Response: Include [OTAKON_INSIGHT_DELETE_REQUEST: {\"id\": \"unused_tab\"}] and acknowledge the deletion\r\n\r\nWhen you see an @ command:\r\n- Acknowledge the command in your response (\"I've updated the [tab name] tab...\")\r\n- Include the appropriate OTAKON tag to execute the action\r\n- Provide confirmation of what was changed\r\n`;\r\n\r\nconst getGeneralAssistantPrompt = (userMessage: string): string => {\r\n  return `\r\n**Persona: General Gaming Assistant**\r\nYou are Otagon, a helpful and knowledgeable AI gaming assistant for the \"Game Hub\" tab.\r\n\r\n**CRITICAL: Use Real Information**\r\n- Today's date is ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}\r\n- You have access to Google Search grounding for current information\r\n- ALWAYS cite specific game titles, release dates, and accurate details from web search results\r\n- NEVER use placeholders like \"[Hypothetical Game A]\" or \"[Insert Today's Date]\"\r\n- For questions about recent releases, new updates, or announcements, use the grounded web search data\r\n- Your knowledge cutoff is January 2025 - use web search for anything after that date\r\n- Always provide specific, real game titles and accurate information\r\n\r\n**Task:**\r\n1. Thoroughly answer the user's query: \"${userMessage}\".\r\n2. If the query is about a SPECIFIC RELEASED GAME that the user mentions by name, you MUST include these tags:\r\n   - [OTAKON_GAME_ID: Full Game Name] - The complete, official name of the game\r\n   - [OTAKON_CONFIDENCE: high|low] - Your confidence in the identification\r\n   - [OTAKON_GENRE: Genre] - The primary genre (e.g., Action RPG, FPS, Strategy)\r\n   - [OTAKON_GAME_STATUS: unreleased] - ONLY if the game is NOT YET RELEASED\r\n3. Provide three relevant suggested prompts using the [OTAKON_SUGGESTIONS] tag.\r\n\r\n**IMPORTANT - When to use game tags:**\r\nâœ… User asks: \"How do I beat the first boss in Elden Ring?\" â†’ Include [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG]\r\nâœ… User asks: \"What's the best build for Cyberpunk 2077?\" â†’ Include [OTAKON_GAME_ID: Cyberpunk 2077] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG]\r\nâŒ User asks: \"What's a good RPG to play?\" â†’ NO game tags (general question)\r\nâŒ User asks: \"Tell me about open world games\" â†’ NO game tags (general question)\r\n\r\n**Tag Definitions:**\r\n${OTAKON_TAG_DEFINITIONS}\r\n\r\n**Response Style:**\r\n- Be helpful and knowledgeable about gaming\r\n- Keep responses concise but informative\r\n- Use gaming terminology appropriately\r\n- For game-specific queries, start with \"Hint:\" and provide actionable advice\r\n- Focus on useful information, not obvious descriptions\r\n- Make responses engaging and immersive\r\n`;\r\n};\r\n\r\nconst getGameCompanionPrompt = (\r\n  conversation: Conversation, \r\n  userMessage: string, \r\n  user: User, \r\n  isActiveSession: boolean,\r\n  playerProfile?: PlayerProfile\r\n): string => {\r\n  // Gather subtab context\r\n  const subtabContext = conversation.subtabs\r\n    ?.filter(tab => tab.status === 'loaded' && tab.content)\r\n    .map(tab => `### ${tab.title} (ID: ${tab.id})\\n${tab.content}`)\r\n    .join('\\n\\n') || 'No subtabs available yet.';\r\n\r\n  // Gather recent conversation history (last 10 messages for better context)\r\n  const recentMessages = conversation.messages\r\n    .slice(-10)\r\n    .map(m => `${m.role === 'user' ? 'User' : 'Otagon'}: ${m.content}`)\r\n    .join('\\n');\r\n\r\n  // Include historical context summary if available\r\n  const historicalContext = conversation.contextSummary\r\n    ? `**Historical Context (Previous Sessions):**\\n${conversation.contextSummary}\\n\\n`\r\n    : '';\r\n\r\n  // Get player profile context if available\r\n  const profile = playerProfile || profileAwareTabService.getDefaultProfile();\r\n  const profileContext = profileAwareTabService.buildProfileContext(profile);\r\n\r\n  return `\r\n**Persona: Game Companion**\r\nYou are Otagon, an immersive AI companion for the game \"${conversation.gameTitle}\".\r\nThe user's spoiler preference is: \"${user.preferences?.spoilerPreference || 'none'}\".\r\nThe user's current session mode is: ${isActiveSession ? 'ACTIVE (currently playing)' : 'PLANNING (not playing)'}.\r\n\r\n**Web Search Grounding Available:**\r\n- You have access to Google Search for current information about this game\r\n- Use web search for: patch notes, updates, DLC announcements, strategy guides, wiki information\r\n- Your knowledge cutoff is January 2025 - use grounding for recent game updates or patches\r\n- Always cite specific sources when using grounded information\r\n\r\n**Game Context:**\r\n- Game: ${conversation.gameTitle} (${conversation.genre})\r\n- Current Objective: ${conversation.activeObjective || 'Not set'}\r\n- Game Progress: ${conversation.gameProgress || 0}%\r\n\r\n**Player Profile:**\r\n${profileContext}\r\n\r\n**Current Subtabs (Your Knowledge Base):**\r\n${subtabContext}\r\n\r\n${historicalContext}**Recent Conversation History:**\r\n${recentMessages}\r\n\r\n**User Query:** \"${userMessage}\"\r\n\r\n**Task:**\r\n1. Respond to the user's query in an immersive, in-character way that matches the tone of the game.\r\n2. Use the subtab context above to provide informed, consistent answers.\r\n3. **IMPORTANT: Adapt your response style based on the Player Profile above.**\r\n4. If the query provides new information, update relevant subtabs using [OTAKON_INSIGHT_UPDATE].\r\n5. If the query implies progress, identify new objectives using [OTAKON_OBJECTIVE_SET].\r\n6. ${isActiveSession ? 'Provide concise, actionable advice for immediate use.' : 'Provide more detailed, strategic advice for planning.'}\r\n7. Generate three contextual suggested prompts using the [OTAKON_SUGGESTIONS] tag.\r\n\r\n${COMMAND_CENTRE_INSTRUCTIONS}\r\n\r\n**Suggestions Guidelines:**\r\nGenerate 3 short, specific follow-up questions that help the user:\r\n- Get immediate help with their current situation\r\n- Learn more about game mechanics or story elements\r\n- Get strategic advice for their next steps\r\n- Understand character motivations or plot points\r\n- Explore related game content or areas\r\n\r\nExamples of good suggestions:\r\n- \"What's the best strategy for this boss?\"\r\n- \"Tell me more about this character's backstory\"\r\n- \"What should I do next in this area?\"\r\n- \"How do I unlock this feature?\"\r\n- \"What items should I prioritize here?\"\r\n\r\n**Tag Definitions:**\r\n${OTAKON_TAG_DEFINITIONS}\r\n\r\n**Response Style:**\r\n- Match the tone and atmosphere of ${conversation.gameTitle}\r\n- Be spoiler-free beyond current progress\r\n- Provide practical, actionable advice\r\n- Use game-specific terminology and references\r\n- Start with \"Hint:\" for game-specific queries\r\n- Include lore and story context appropriate to player's progress\r\n- When updating subtabs, seamlessly integrate the update into your response\r\n`;\r\n};\r\n\r\nconst getScreenshotAnalysisPrompt = (\r\n  _conversation: Conversation, \r\n  userMessage: string, \r\n  _user: User,\r\n  playerProfile?: PlayerProfile\r\n): string => {\r\n  // Get player profile context if available\r\n  const profile = playerProfile || profileAwareTabService.getDefaultProfile();\r\n  const profileContext = profileAwareTabService.buildProfileContext(profile);\r\n\r\n  return `\r\n**Persona: Game Lore Expert & Screenshot Analyst**\r\nYou are Otagon, an expert at analyzing game visuals and providing immersive, lore-rich assistance.\r\n\r\n**Player Profile:**\r\n${profileContext}\r\n\r\n**Task:**\r\n1. Analyze the screenshot to identify the game\r\n2. **CRITICAL TAG REQUIREMENTS - Include ALL of these tags:**\r\n   - [OTAKON_GAME_ID: Full Game Name] - The complete, official name of the game\r\n   - [OTAKON_CONFIDENCE: high|low] - Your confidence in the identification\r\n   - [OTAKON_GENRE: Genre] - The primary genre (e.g., Action RPG, FPS, Strategy)\r\n   - [OTAKON_IS_FULLSCREEN: true|false] - Is this fullscreen gameplay? (For informational purposes)\r\n   - [OTAKON_GAME_STATUS: unreleased] - ONLY include this if the game is NOT YET RELEASED (verify release date!)\r\n3. Answer: \"${userMessage}\" with focus on game lore, significance, and useful context\r\n4. Provide 3 contextual suggestions using [OTAKON_SUGGESTIONS: [\"suggestion1\", \"suggestion2\", \"suggestion3\"]]\r\n\r\n**Tag Usage Examples:**\r\nâœ… Gameplay screenshot (CREATES TAB): [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG] [OTAKON_IS_FULLSCREEN: true]\r\nâœ… In-game inventory menu (CREATES TAB): [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG] [OTAKON_IS_FULLSCREEN: true]\r\nâœ… Main menu before starting (STAYS IN GAME HUB): [OTAKON_GAME_ID: Elden Ring] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action RPG] [OTAKON_IS_FULLSCREEN: false]\r\nâœ… Unreleased game: [OTAKON_GAME_ID: GTA VI] [OTAKON_CONFIDENCE: high] [OTAKON_GENRE: Action Adventure] [OTAKON_IS_FULLSCREEN: true] [OTAKON_GAME_STATUS: unreleased]\r\n\r\n**IMPORTANT - Game Tab Creation:**\r\n- Screenshots showing ACTIVE GAMEPLAY or IN-GAME MENUS will create a dedicated game tab\r\n- Set [OTAKON_IS_FULLSCREEN: true] for gameplay, in-game menus, or any screen accessed DURING a play session\r\n- Main menus, character selection, launchers should use [OTAKON_IS_FULLSCREEN: false]\r\n- These pre-game screens will be handled in the \"Game Hub\" for quick questions\r\n\r\n**What counts as fullscreen gameplay (for IS_FULLSCREEN tag = true, CREATES TAB):**\r\n- In-game world exploration with HUD visible\r\n- Combat encounters with player character visible\r\n- Active gameplay with health/stamina/ammo displays\r\n- **In-game menus: inventory, map, skill tree, quest log, crafting, loadout**\r\n- **Character stats, equipment, loot screens accessed during gameplay**\r\n- Pause menus DURING gameplay (game world visible or obscured)\r\n- Cutscenes during gameplay with game UI\r\n\r\n**What is NOT fullscreen gameplay (IS_FULLSCREEN = false, STAYS IN GAME HUB):**\r\n- Main menus BEFORE starting game (Press Start, New Game, Continue, Load Game)\r\n- Settings/Options menus accessed before gameplay begins\r\n- Character creation/selection screens at game start\r\n- Loading screens or splash screens\r\n- Launchers (Steam, Epic, etc.) or desktop with game icon\r\n- Store pages or promotional images\r\n- Tutorial screens before gameplay starts\r\n\r\n**Response Style for Text Queries:**\r\n- Be conversational and contextual - respond naturally to the user's question\r\n- Build on previous conversation context progressively\r\n- NO structured headers (Hint/Lore/Places) for text conversations\r\n- Use natural paragraphs and flowing prose\r\n- Reference previous messages when relevant\r\n- Adapt tone to match user's question (casual question = casual response, serious question = detailed response)\r\n\r\n**Response Style for Image Uploads ONLY:**\r\n- Use structured format with section headers\r\n- Focus on GAME LORE, SIGNIFICANCE, and USEFUL CONTEXT rather than describing obvious UI elements\r\n- Make the response immersive and engaging\r\n\r\n**MANDATORY FORMAT FOR IMAGES - Use this exact structure with bold section headers:**\r\n**Hint:** [Game Name] - [Brief, actionable hint about what the player should do or focus on]\r\n\r\n**Lore:** [Rich lore explanation about the current situation, characters, story significance, or world-building context]\r\n\r\n**Places of Interest:** [Nearby locations, shops, NPCs, or areas where the player can find useful items, quests, or important interactions]\r\n\r\n**What to focus on:**\r\n- Story significance and lore implications\r\n- Character relationships and motivations\r\n- Location importance and world-building\r\n- Gameplay mechanics and strategic advice\r\n- Narrative context and plot relevance\r\n- Cultural or thematic elements\r\n\r\n**What to avoid:**\r\n- Describing obvious UI elements (health bars, buttons, etc.)\r\n- Stating the obvious (\"you can see buildings\", \"there's text on screen\")\r\n- Generic descriptions that don't add value\r\n- Deviating from the mandatory format above\r\n\r\n**Genre Classification Confirmation:**\r\nAfter providing your response, if there's ANY ambiguity about the genre classification, add a brief confirmation question:\r\n- Example: \"I've classified this as a Souls-like game. Does that match your understanding, or would you prefer a different categorization?\"\r\n- Example: \"This appears to be an Open-World adventure game. If you think it fits better in another category (like RPG or Action RPG), let me know!\"\r\n- Only include this if the genre could reasonably fit multiple categories\r\n- Keep it brief and natural - don't add it for obvious genre matches like \"Call of Duty = First-Person Shooter\"\r\n\r\n**Suggestions Guidelines:**\r\nGenerate 3 short, specific follow-up questions that help the user:\r\n- Learn more about the current situation or location\r\n- Get tactical advice for what they're seeing\r\n- Understand story implications or character motivations\r\n- Get tips for gameplay mechanics shown in the screenshot\r\n- Explore related game content or areas\r\n\r\nExamples of good suggestions:\r\n- \"What's the significance of this location?\"\r\n- \"How do I handle this type of enemy?\"\r\n- \"What should I do next here?\"\r\n- \"Tell me about this character's backstory\"\r\n- \"What items should I look for in this area?\"\r\n\r\n**Tag Definitions:**\r\n${OTAKON_TAG_DEFINITIONS}\r\n`;\r\n};\r\n\r\n/**\r\n * Determines the correct persona and returns the master prompt.\r\n */\r\nexport const getPromptForPersona = (\r\n  conversation: Conversation,\r\n  userMessage: string,\r\n  user: User,\r\n  isActiveSession: boolean,\r\n  hasImages: boolean,\r\n  playerProfile?: PlayerProfile\r\n): string => {\r\n  if (hasImages) {\r\n    return getScreenshotAnalysisPrompt(conversation, userMessage, user, playerProfile);\r\n  }\r\n  \r\n  if (!conversation.isGameHub && conversation.gameTitle) {\r\n    return getGameCompanionPrompt(conversation, userMessage, user, isActiveSession, playerProfile);\r\n  }\r\n  \r\n  return getGeneralAssistantPrompt(userMessage);\r\n};\r\n","export interface ErrorContext {\r\n  operation: string;\r\n  conversationId?: string;\r\n  userId?: string;\r\n  timestamp: number;\r\n  retryCount: number;\r\n}\r\n\r\nexport interface RecoveryAction {\r\n  type: 'retry' | 'fallback' | 'user_notification' | 'skip';\r\n  message?: string;\r\n  action?: () => Promise<void>;\r\n}\r\n\r\nclass ErrorRecoveryService {\r\n  private retryAttempts = new Map<string, number>();\r\n  private readonly MAX_RETRIES = 3;\r\n  private readonly RETRY_DELAYS = [1000, 2000, 4000]; // Progressive delays\r\n\r\n  /**\r\n   * Handle AI service errors with intelligent recovery\r\n   */\r\n  async handleAIError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\r\n    console.error(`ðŸ¤– [ErrorRecovery] AI Error in ${context.operation}:`, error);\r\n\r\n    // Check if we should retry\r\n    if (this.shouldRetry(context)) {\r\n      const delay = this.getRetryDelay(context.retryCount);\r\n      console.log(`ðŸ”„ [ErrorRecovery] Retrying ${context.operation} in ${delay}ms`);\r\n      \r\n      await this.delay(delay);\r\n      return {\r\n        type: 'retry',\r\n        action: async () => {\r\n          // The retry will be handled by the calling function\r\n        }\r\n      };\r\n    }\r\n\r\n    // Determine fallback action based on error type\r\n    if (error.message.includes('API key') || error.message.includes('authentication')) {\r\n      return {\r\n        type: 'user_notification',\r\n        message: 'AI service authentication failed. Please check your API key in settings.'\r\n      };\r\n    }\r\n\r\n    if (error.message.includes('rate limit') || error.message.includes('quota')) {\r\n      return {\r\n        type: 'user_notification',\r\n        message: 'AI service is temporarily busy. Please try again in a few moments.'\r\n      };\r\n    }\r\n\r\n    if (error.message.includes('network') || error.message.includes('timeout')) {\r\n      return {\r\n        type: 'user_notification',\r\n        message: 'Network connection issue. Please check your internet connection and try again.'\r\n      };\r\n    }\r\n\r\n    // Generic fallback\r\n    return {\r\n      type: 'user_notification',\r\n      message: 'AI service is temporarily unavailable. Please try again later.'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle conversation service errors\r\n   */\r\n  async handleConversationError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\r\n    console.error(`ðŸ’¬ [ErrorRecovery] Conversation Error in ${context.operation}:`, error);\r\n\r\n    if (error.message.includes('not found')) {\r\n      return {\r\n        type: 'fallback',\r\n        message: 'Conversation not found. Creating a new one.',\r\n        action: async () => {\r\n          // This would be handled by the calling function\r\n        }\r\n      };\r\n    }\r\n\r\n    if (error.message.includes('permission') || error.message.includes('unauthorized')) {\r\n      return {\r\n        type: 'user_notification',\r\n        message: 'Permission denied. Please log in again.'\r\n      };\r\n    }\r\n\r\n    return {\r\n      type: 'user_notification',\r\n      message: 'Failed to save conversation. Your data may not be persisted.'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle cache service errors\r\n   */\r\n  async handleCacheError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\r\n    console.error(`ðŸ’¾ [ErrorRecovery] Cache Error in ${context.operation}:`, error);\r\n\r\n    // Cache errors are usually non-critical, so we can skip\r\n    return {\r\n      type: 'skip',\r\n      message: 'Cache unavailable. Continuing without caching.'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle WebSocket connection errors\r\n   */\r\n  async handleWebSocketError(error: Error, context: ErrorContext): Promise<RecoveryAction> {\r\n    console.error(`ðŸ”Œ [ErrorRecovery] WebSocket Error in ${context.operation}:`, error);\r\n\r\n    if (this.shouldRetry(context)) {\r\n      const delay = this.getRetryDelay(context.retryCount);\r\n      return {\r\n        type: 'retry',\r\n        action: async () => {\r\n          await this.delay(delay);\r\n          // Retry connection logic would be handled by the calling function\r\n        }\r\n      };\r\n    }\r\n\r\n    return {\r\n      type: 'user_notification',\r\n      message: 'PC connection lost. Screenshot upload may not be available.'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if an operation should be retried\r\n   */\r\n  private shouldRetry(context: ErrorContext): boolean {\r\n    const key = `${context.operation}_${context.conversationId || 'global'}`;\r\n    const attempts = this.retryAttempts.get(key) || 0;\r\n    return attempts < this.MAX_RETRIES;\r\n  }\r\n\r\n  /**\r\n   * Get retry delay based on attempt count\r\n   */\r\n  private getRetryDelay(retryCount: number): number {\r\n    return this.RETRY_DELAYS[Math.min(retryCount, this.RETRY_DELAYS.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Increment retry count for an operation\r\n   */\r\n  incrementRetryCount(context: ErrorContext): void {\r\n    const key = `${context.operation}_${context.conversationId || 'global'}`;\r\n    const current = this.retryAttempts.get(key) || 0;\r\n    this.retryAttempts.set(key, current + 1);\r\n  }\r\n\r\n  /**\r\n   * Reset retry count for an operation\r\n   */\r\n  resetRetryCount(context: ErrorContext): void {\r\n    const key = `${context.operation}_${context.conversationId || 'global'}`;\r\n    this.retryAttempts.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Utility delay function\r\n   */\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  /**\r\n   * Display user-friendly error message\r\n   */\r\n  displayError(message: string, type: 'error' | 'warning' | 'info' = 'error'): void {\r\n    // In a real app, this would show a toast notification or modal\r\n    console.log(`[${type.toUpperCase()}] ${message}`);\r\n    \r\n    // For now, we'll use a simple alert (in production, use a proper UI component)\r\n    if (type === 'error') {\r\n      // Only show critical errors to user\r\n      console.error('User Error:', message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log error for debugging\r\n   */\r\n  logError(error: Error, context: ErrorContext, additionalInfo?: any): void {\r\n    console.error('Error Details:', {\r\n      error: error.message,\r\n      stack: error.stack,\r\n      context,\r\n      additionalInfo,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  }\r\n}\r\n\r\nexport const errorRecoveryService = new ErrorRecoveryService();\r\n","export interface GameTone {\r\n  adjectives: string[];\r\n  personality: string;\r\n  speechPattern: string;\r\n  loreStyle: string;\r\n}\r\n\r\nexport interface ImmersionContext {\r\n  gameTitle: string;\r\n  genre: string;\r\n  currentLocation?: string;\r\n  recentEvents?: string[];\r\n  playerProgress?: number;\r\n}\r\n\r\nclass CharacterImmersionService {\r\n  private gameTones: Record<string, GameTone> = {\r\n    'Action RPG': {\r\n      adjectives: ['epic', 'heroic', 'legendary', 'mystical', 'ancient'],\r\n      personality: 'wise and experienced adventurer',\r\n      speechPattern: 'speaks with the wisdom of ages and the thrill of adventure',\r\n      loreStyle: 'rich with mythology and ancient secrets'\r\n    },\r\n    'FPS': {\r\n      adjectives: ['intense', 'tactical', 'precise', 'combat-ready', 'strategic'],\r\n      personality: 'battle-hardened soldier',\r\n      speechPattern: 'communicates with military precision and combat experience',\r\n      loreStyle: 'focused on warfare, technology, and military history'\r\n    },\r\n    'Horror': {\r\n      adjectives: ['ominous', 'chilling', 'mysterious', 'haunting', 'eerie'],\r\n      personality: 'knowledgeable survivor',\r\n      speechPattern: 'speaks with caution and awareness of lurking dangers',\r\n      loreStyle: 'dark and atmospheric, filled with supernatural elements'\r\n    },\r\n    'Puzzle': {\r\n      adjectives: ['logical', 'methodical', 'analytical', 'clever', 'systematic'],\r\n      personality: 'brilliant problem-solver',\r\n      speechPattern: 'explains with clear logic and step-by-step reasoning',\r\n      loreStyle: 'intellectual and mysterious, focused on patterns and solutions'\r\n    },\r\n    'RPG': {\r\n      adjectives: ['immersive', 'narrative-driven', 'character-focused', 'epic', 'emotional'],\r\n      personality: 'storyteller and guide',\r\n      speechPattern: 'speaks like a narrator, weaving tales and character development',\r\n      loreStyle: 'deep character development and rich storytelling'\r\n    },\r\n    'Strategy': {\r\n      adjectives: ['tactical', 'strategic', 'calculated', 'methodical', 'commanding'],\r\n      personality: 'master tactician',\r\n      speechPattern: 'speaks with authority and strategic insight',\r\n      loreStyle: 'focused on warfare, politics, and grand strategy'\r\n    },\r\n    'Adventure': {\r\n      adjectives: ['exploratory', 'curious', 'adventurous', 'discoverer', 'wanderer'],\r\n      personality: 'intrepid explorer',\r\n      speechPattern: 'speaks with wonder and excitement about discovery',\r\n      loreStyle: 'filled with exploration, discovery, and world-building'\r\n    },\r\n    'Default': {\r\n      adjectives: ['helpful', 'knowledgeable', 'friendly', 'supportive', 'engaging'],\r\n      personality: 'helpful gaming companion',\r\n      speechPattern: 'speaks clearly and helpfully',\r\n      loreStyle: 'focused on gameplay and helpful information'\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the appropriate tone for a game based on its genre\r\n   */\r\n  getGameTone(genre: string): GameTone {\r\n    return this.gameTones[genre] || this.gameTones['Default'];\r\n  }\r\n\r\n  /**\r\n   * Generate immersive context for AI prompts\r\n   */\r\n  generateImmersionContext(context: ImmersionContext): string {\r\n    const tone = this.getGameTone(context.genre);\r\n    \r\n    let immersionText = `**Immersion Context for ${context.gameTitle}:**\\n`;\r\n    immersionText += `You are speaking as a ${tone.personality} who ${tone.speechPattern}.\\n`;\r\n    immersionText += `The game's lore is ${tone.loreStyle}.\\n`;\r\n    \r\n    if (context.currentLocation) {\r\n      immersionText += `The player is currently in: ${context.currentLocation}\\n`;\r\n    }\r\n    \r\n    if (context.recentEvents && context.recentEvents.length > 0) {\r\n      immersionText += `Recent events: ${context.recentEvents.join(', ')}\\n`;\r\n    }\r\n    \r\n    if (context.playerProgress !== undefined) {\r\n      immersionText += `Player progress: ${context.playerProgress}%\\n`;\r\n    }\r\n    \r\n    immersionText += `\\n**Response Guidelines:**\\n`;\r\n    immersionText += `- Use ${tone.adjectives.join(', ')} language\\n`;\r\n    immersionText += `- Maintain the ${tone.personality} personality\\n`;\r\n    immersionText += `- Focus on ${tone.loreStyle} elements\\n`;\r\n    immersionText += `- Keep responses immersive and in-character\\n`;\r\n    \r\n    return immersionText;\r\n  }\r\n\r\n  /**\r\n   * Enhance AI response with game-specific immersion\r\n   */\r\n  enhanceResponse(response: string, context: ImmersionContext): string {\r\n    \r\n    // Add immersive opening based on game genre\r\n    let enhancedResponse = response;\r\n    \r\n    if (context.genre === 'Horror') {\r\n      enhancedResponse = `*The shadows seem to whisper as you approach...*\\n\\n${response}`;\r\n    } else if (context.genre === 'Action RPG') {\r\n      enhancedResponse = `*The ancient knowledge flows through your mind...*\\n\\n${response}`;\r\n    } else if (context.genre === 'FPS') {\r\n      enhancedResponse = `*Mission briefing updated...*\\n\\n${response}`;\r\n    } else if (context.genre === 'Puzzle') {\r\n      enhancedResponse = `*The solution becomes clearer...*\\n\\n${response}`;\r\n    }\r\n    \r\n    return enhancedResponse;\r\n  }\r\n\r\n  /**\r\n   * Get genre-specific suggestions for follow-up questions\r\n   */\r\n  getGenreSuggestions(genre: string, _context: ImmersionContext): string[] {\r\n    \r\n    const baseSuggestions = [\r\n      \"Tell me more about this area\",\r\n      \"What should I do next?\",\r\n      \"Any tips for this situation?\"\r\n    ];\r\n    \r\n    const genreSpecificSuggestions: Record<string, string[]> = {\r\n      'Action RPG': [\r\n        \"What's the lore behind this location?\",\r\n        \"How do I improve my character?\",\r\n        \"What quests are available here?\",\r\n        \"Tell me about the local NPCs\"\r\n      ],\r\n      'FPS': [\r\n        \"What's the best tactical approach?\",\r\n        \"What weapons work best here?\",\r\n        \"How do I flank the enemy?\",\r\n        \"What's the mission objective?\"\r\n      ],\r\n      'Horror': [\r\n        \"What's the history of this place?\",\r\n        \"How do I survive this area?\",\r\n        \"What should I be careful of?\",\r\n        \"Tell me about the local legends\"\r\n      ],\r\n      'Puzzle': [\r\n        \"What's the pattern here?\",\r\n        \"How do I solve this step by step?\",\r\n        \"What clues am I missing?\",\r\n        \"What's the logical approach?\"\r\n      ],\r\n      'RPG': [\r\n        \"Tell me about the story so far\",\r\n        \"What choices should I make?\",\r\n        \"How do I develop my character?\",\r\n        \"What's the significance of this moment?\"\r\n      ],\r\n      'Strategy': [\r\n        \"What's the best strategy here?\",\r\n        \"How do I manage my resources?\",\r\n        \"What's the optimal build order?\",\r\n        \"How do I counter this threat?\"\r\n      ]\r\n    };\r\n    \r\n    return genreSpecificSuggestions[genre] || baseSuggestions;\r\n  }\r\n\r\n  /**\r\n   * Create immersive sub-tab content based on genre\r\n   */\r\n  createImmersiveSubTabContent(tabType: string, gameTitle: string, genre: string): string {\r\n    \r\n    const contentTemplates: Record<string, Record<string, string>> = {\r\n      'walkthrough': {\r\n        'Action RPG': `# ${gameTitle} - Walkthrough\\n\\n*The path of the hero unfolds before you...*\\n\\n## Current Objective\\n*Your quest awaits...*\\n\\n## Next Steps\\n*The adventure continues...*`,\r\n        'FPS': `# ${gameTitle} - Mission Briefing\\n\\n*Mission parameters updated...*\\n\\n## Objective\\n*Target acquired...*\\n\\n## Tactical Approach\\n*Weapons ready...*`,\r\n        'Horror': `# ${gameTitle} - Survival Guide\\n\\n*The darkness holds many secrets...*\\n\\n## Current Situation\\n*Something stirs in the shadows...*\\n\\n## Survival Tips\\n*Stay alert...*`,\r\n        'Default': `# ${gameTitle} - Walkthrough\\n\\n## Current Objective\\n*Continue your journey...*\\n\\n## Next Steps\\n*Progress forward...*`\r\n      },\r\n      'tips': {\r\n        'Action RPG': `# ${gameTitle} - Wisdom of the Ages\\n\\n*Ancient knowledge flows through these tips...*\\n\\n## Combat Mastery\\n*Master the blade and magic...*\\n\\n## Exploration Secrets\\n*Hidden treasures await...*`,\r\n        'FPS': `# ${gameTitle} - Tactical Intelligence\\n\\n*Mission-critical information...*\\n\\n## Weapon Mastery\\n*Know your arsenal...*\\n\\n## Tactical Positioning\\n*Control the battlefield...*`,\r\n        'Horror': `# ${gameTitle} - Survival Knowledge\\n\\n*The darkness teaches harsh lessons...*\\n\\n## Survival Tactics\\n*Stay alive...*\\n\\n## Environmental Awareness\\n*Trust your instincts...*`,\r\n        'Default': `# ${gameTitle} - Tips & Tricks\\n\\n## General Tips\\n*Improve your gameplay...*\\n\\n## Advanced Techniques\\n*Master the game...*`\r\n      }\r\n    };\r\n    \r\n    return contentTemplates[tabType]?.[genre] || contentTemplates[tabType]?.['Default'] || `# ${gameTitle} - ${tabType}\\n\\n*Content loading...*`;\r\n  }\r\n}\r\n\r\nexport const characterImmersionService = new CharacterImmersionService();\r\n","import { newsPrompts } from '../types';\r\n\r\nclass SuggestedPromptsService {\r\n  private readonly STORAGE_KEY = 'otakon_used_suggested_prompts';\r\n  private readonly LAST_RESET_KEY = 'otakon_suggested_prompts_last_reset';\r\n  private readonly RESET_INTERVAL_MS = 24 * 60 * 60 * 1000; // 24 hours\r\n  private usedPrompts: Set<string> = new Set();\r\n\r\n  constructor() {\r\n    this.loadUsedPrompts();\r\n    this.checkAndResetIfNeeded();\r\n  }\r\n\r\n  private loadUsedPrompts(): void {\r\n    try {\r\n      const stored = localStorage.getItem(this.STORAGE_KEY);\r\n      if (stored) {\r\n        const prompts = JSON.parse(stored);\r\n        this.usedPrompts = new Set(prompts);\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to load used suggested prompts:', error);\r\n      this.usedPrompts = new Set();\r\n    }\r\n  }\r\n\r\n  private saveUsedPrompts(): void {\r\n    try {\r\n      const prompts = Array.from(this.usedPrompts);\r\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(prompts));\r\n    } catch (error) {\r\n      console.warn('Failed to save used suggested prompts:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if 24 hours have passed since last reset and reset if needed\r\n   */\r\n  private checkAndResetIfNeeded(): void {\r\n    try {\r\n      const lastResetTime = localStorage.getItem(this.LAST_RESET_KEY);\r\n      const now = Date.now();\r\n      \r\n      if (!lastResetTime || (now - parseInt(lastResetTime)) >= this.RESET_INTERVAL_MS) {\r\n        console.log('ðŸ”„ 24 hours passed - resetting suggested prompts for fresh daily news');\r\n        this.resetUsedPrompts();\r\n        localStorage.setItem(this.LAST_RESET_KEY, now.toString());\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to check/reset suggested prompts:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a prompt as used\r\n   */\r\n  public markPromptAsUsed(prompt: string): void {\r\n    this.usedPrompts.add(prompt);\r\n    this.saveUsedPrompts();\r\n  }\r\n\r\n  /**\r\n   * Check if a prompt has been used\r\n   */\r\n  public isPromptUsed(prompt: string): boolean {\r\n    return this.usedPrompts.has(prompt);\r\n  }\r\n\r\n  /**\r\n   * Get all unused prompts from a list\r\n   */\r\n  public getUnusedPrompts(prompts: string[]): string[] {\r\n    return prompts.filter(prompt => !this.isPromptUsed(prompt));\r\n  }\r\n\r\n  /**\r\n   * Check if all prompts have been used\r\n   */\r\n  public areAllPromptsUsed(prompts: string[]): boolean {\r\n    return prompts.every(prompt => this.isPromptUsed(prompt));\r\n  }\r\n\r\n  /**\r\n   * Reset used prompts (called on app restart, login, or 24-hour interval)\r\n   */\r\n  public resetUsedPrompts(): void {\r\n    this.usedPrompts.clear();\r\n    localStorage.removeItem(this.STORAGE_KEY);\r\n    console.log('ðŸ”„ Suggested prompts reset - all 4 prompts will be available again');\r\n  }\r\n\r\n  /**\r\n   * Get count of used prompts\r\n   */\r\n  public getUsedCount(): number {\r\n    return this.usedPrompts.size;\r\n  }\r\n\r\n  /**\r\n   * Get time until next reset (in milliseconds)\r\n   */\r\n  public getTimeUntilNextReset(): number {\r\n    try {\r\n      const lastResetTime = localStorage.getItem(this.LAST_RESET_KEY);\r\n      if (!lastResetTime) {\r\n        return 0;\r\n      }\r\n      \r\n      const nextResetTime = parseInt(lastResetTime) + this.RESET_INTERVAL_MS;\r\n      return Math.max(0, nextResetTime - Date.now());\r\n    } catch (error) {\r\n      console.warn('Failed to calculate time until next reset:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get static news prompts for the \"Game Hub\" tab\r\n   */\r\n  public getStaticNewsPrompts(): string[] {\r\n    // Returns array of 4 news prompts (not shuffled to maintain consistency)\r\n    return newsPrompts;\r\n  }\r\n\r\n  /**\r\n   * Process AI-generated suggestions and format them for display\r\n   */\r\n  public processAISuggestions(suggestions: any): string[] {\r\n    console.log('ðŸ” [SuggestedPromptsService] Input suggestions:', suggestions, 'Type:', typeof suggestions);\r\n    \r\n    // Handle different types of suggestions\r\n    if (!suggestions) {\r\n      console.log('ðŸ” [SuggestedPromptsService] No suggestions provided');\r\n      return [];\r\n    }\r\n    \r\n    let suggestionsArray: string[] = [];\r\n    \r\n    if (Array.isArray(suggestions)) {\r\n      console.log('ðŸ” [SuggestedPromptsService] Suggestions is already an array');\r\n      suggestionsArray = suggestions;\r\n    } else if (typeof suggestions === 'string') {\r\n      console.log('ðŸ” [SuggestedPromptsService] Suggestions is a string, attempting to parse');\r\n      \r\n      // Clean up common formatting issues first\r\n      let cleanedSuggestions = suggestions.trim();\r\n      \r\n      // Fix malformed JSON arrays that start with [\" but might be incomplete\r\n      if (cleanedSuggestions.startsWith('[\"') && !cleanedSuggestions.endsWith('\"]')) {\r\n        // Try to fix incomplete JSON arrays\r\n        if (!cleanedSuggestions.endsWith('\"')) {\r\n          cleanedSuggestions += '\"';\r\n        }\r\n        if (!cleanedSuggestions.endsWith(']')) {\r\n          cleanedSuggestions += ']';\r\n        }\r\n        console.log('ðŸ” [SuggestedPromptsService] Fixed malformed JSON array:', cleanedSuggestions);\r\n      }\r\n      \r\n      // If it's a string, try to parse it as JSON\r\n      try {\r\n        // Try to parse as JSON array first\r\n        const parsed = JSON.parse(cleanedSuggestions);\r\n        if (Array.isArray(parsed)) {\r\n          suggestionsArray = parsed;\r\n          console.log('ðŸ” [SuggestedPromptsService] Successfully parsed as JSON array');\r\n        } else {\r\n          suggestionsArray = [suggestions];\r\n          console.log('ðŸ” [SuggestedPromptsService] Parsed as single value, wrapped in array');\r\n        }\r\n      } catch (_e) {\r\n        console.log('ðŸ” [SuggestedPromptsService] JSON parsing failed, trying delimiter splitting');\r\n        // If JSON parsing fails, try to split by common delimiters\r\n        if (cleanedSuggestions.includes('\", \"') || cleanedSuggestions.includes('\",\\n\"')) {\r\n          // Split by comma and clean up\r\n          suggestionsArray = cleanedSuggestions\r\n            .split(/\",\\s*\"/)\r\n            .map(s => s.replace(/^[\"\\s]+|[\"\\s]+$/g, ''))\r\n            .filter(s => s.length > 0);\r\n          console.log('ðŸ” [SuggestedPromptsService] Split by comma delimiters');\r\n        } else if (cleanedSuggestions.includes('\\n')) {\r\n          // Split by newlines for multi-line format\r\n          suggestionsArray = cleanedSuggestions\r\n            .split('\\n')\r\n            .map(s => s.replace(/^[\"\\s]+|[\"\\s]+$/g, ''))\r\n            .filter(s => s.length > 0);\r\n          console.log('ðŸ” [SuggestedPromptsService] Split by quote delimiters');\r\n        } else {\r\n          // Single suggestion\r\n          suggestionsArray = [suggestions];\r\n          console.log('ðŸ” [SuggestedPromptsService] Treated as single suggestion');\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log('ðŸ” [SuggestedPromptsService] Raw suggestions array:', suggestionsArray);\r\n    \r\n    // Clean and format suggestions\r\n    const result = suggestionsArray\r\n      .filter(suggestion => suggestion && typeof suggestion === 'string' && suggestion.trim().length > 0)\r\n      .map(suggestion => suggestion.trim())\r\n      .slice(0, 3); // Limit to 3 suggestions\r\n    \r\n    console.log('ðŸ” [SuggestedPromptsService] Final processed suggestions:', result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get fallback suggestions when AI doesn't provide any\r\n   * Returns news prompts for Game Hub, game-specific prompts for game tabs\r\n   */\r\n  public getFallbackSuggestions(conversationId: string, isGameHub?: boolean): string[] {\r\n    // Import GAME_HUB_ID constant for consistency\r\n    const GAME_HUB_ID = 'game-hub';\r\n    \r\n    // âœ… Explicit Game Hub check with multiple conditions\r\n    const isActuallyGameHub = isGameHub === true || \r\n      conversationId === GAME_HUB_ID || \r\n      conversationId === 'everything-else';\r\n    \r\n    if (isActuallyGameHub) {\r\n      // Game Hub: Return 4 static news prompts\r\n      return this.getStaticNewsPrompts();\r\n    }\r\n    \r\n    // âœ… Game-specific tabs: Return contextual game prompts\r\n    // These prompts work for ANY game (not news-related)\r\n    return [\r\n      \"What should I do next in this area?\",\r\n      \"Tell me about the story so far\",\r\n      \"Give me some tips for this game\",\r\n      \"What are the key mechanics I should know?\"\r\n    ];\r\n  }\r\n}\r\n\r\nexport const suggestedPromptsService = new SuggestedPromptsService();\r\n\r\n","import { Conversation, ChatMessage } from '../types';\r\n\r\nexport interface SessionSummary {\r\n  mode: 'playing' | 'planning';\r\n  gameTitle: string;\r\n  conversationId: string;\r\n  summary: string;\r\n  keyPoints: string[];\r\n  objectives: string[];\r\n  timestamp: number;\r\n}\r\n\r\nclass SessionSummaryService {\r\n  /**\r\n   * Generate a summary of a playing session for planning mode\r\n   */\r\n  async generatePlayingSessionSummary(conversation: Conversation): Promise<SessionSummary> {\r\n    const playingMessages = conversation.messages.filter(msg => \r\n      msg.role === 'assistant' && msg.content.includes('Hint:')\r\n    );\r\n\r\n    const keyPoints = this.extractKeyPoints(playingMessages);\r\n    const objectives = this.extractObjectives(playingMessages);\r\n    \r\n    const summary = `Playing session summary for ${conversation.gameTitle}:\r\n    \r\nKey Achievements:\r\n${keyPoints.map(point => `â€¢ ${point}`).join('\\n')}\r\n\r\nCurrent Objectives:\r\n${objectives.map(obj => `â€¢ ${obj}`).join('\\n')}\r\n\r\nRecent Progress:\r\n${playingMessages.slice(-3).map(msg => `- ${msg.content.substring(0, 100)}...`).join('\\n')}`;\r\n\r\n    return {\r\n      mode: 'playing',\r\n      gameTitle: conversation.gameTitle || 'Unknown Game',\r\n      conversationId: conversation.id,\r\n      summary,\r\n      keyPoints,\r\n      objectives,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a summary of a planning session for playing mode\r\n   */\r\n  async generatePlanningSessionSummary(conversation: Conversation): Promise<SessionSummary> {\r\n    const planningMessages = conversation.messages.filter(msg => \r\n      msg.role === 'assistant' && !msg.content.includes('Hint:')\r\n    );\r\n\r\n    const keyPoints = this.extractKeyPoints(planningMessages);\r\n    const objectives = this.extractObjectives(planningMessages);\r\n    \r\n    const summary = `Planning session summary for ${conversation.gameTitle}:\r\n    \r\nPlanned Strategies:\r\n${keyPoints.map(point => `â€¢ ${point}`).join('\\n')}\r\n\r\nGoals to Achieve:\r\n${objectives.map(obj => `â€¢ ${obj}`).join('\\n')}\r\n\r\nStrategic Notes:\r\n${planningMessages.slice(-3).map(msg => `- ${msg.content.substring(0, 100)}...`).join('\\n')}`;\r\n\r\n    return {\r\n      mode: 'planning',\r\n      gameTitle: conversation.gameTitle || 'Unknown Game',\r\n      conversationId: conversation.id,\r\n      summary,\r\n      keyPoints,\r\n      objectives,\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract key points from messages\r\n   */\r\n  private extractKeyPoints(messages: ChatMessage[]): string[] {\r\n    const keyPoints: string[] = [];\r\n    \r\n    messages.forEach(msg => {\r\n      // Look for specific patterns that indicate achievements or important info\r\n      if (msg.content.includes('defeated') || msg.content.includes('completed')) {\r\n        keyPoints.push('Achievement unlocked or objective completed');\r\n      }\r\n      if (msg.content.includes('found') || msg.content.includes('discovered')) {\r\n        keyPoints.push('New item or location discovered');\r\n      }\r\n      if (msg.content.includes('unlocked') || msg.content.includes('gained')) {\r\n        keyPoints.push('New ability or feature unlocked');\r\n      }\r\n    });\r\n\r\n    return keyPoints.length > 0 ? keyPoints : ['Session progress recorded'];\r\n  }\r\n\r\n  /**\r\n   * Extract objectives from messages\r\n   */\r\n  private extractObjectives(messages: ChatMessage[]): string[] {\r\n    const objectives: string[] = [];\r\n    \r\n    messages.forEach(msg => {\r\n      // Look for objective-related content\r\n      if (msg.content.includes('objective') || msg.content.includes('goal')) {\r\n        objectives.push('Continue current objective');\r\n      }\r\n      if (msg.content.includes('next') || msg.content.includes('should')) {\r\n        objectives.push('Follow recommended next steps');\r\n      }\r\n      if (msg.content.includes('explore') || msg.content.includes('investigate')) {\r\n        objectives.push('Explore new areas or investigate leads');\r\n      }\r\n    });\r\n\r\n    return objectives.length > 0 ? objectives : ['Continue game progression'];\r\n  }\r\n\r\n  /**\r\n   * Store session summary in conversation\r\n   */\r\n  async storeSessionSummary(conversationId: string, summary: SessionSummary): Promise<void> {\r\n    // Store in conversation metadata or cache\r\n    // This would integrate with your existing conversation service\r\n    console.log('Storing session summary for conversation:', conversationId, summary);\r\n  }\r\n\r\n  /**\r\n   * Get the most recent session summary\r\n   */\r\n  async getLatestSessionSummary(conversationId: string): Promise<SessionSummary | null> {\r\n    // Retrieve from conversation metadata or cache\r\n    // This would integrate with your existing conversation service\r\n    console.log('Getting latest session summary for conversation:', conversationId);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport const sessionSummaryService = new SessionSummaryService();\r\n","import { supabase } from '../lib/supabase';\r\nimport { SubTab } from '../types';\r\nimport { FEATURE_FLAGS } from '../constants';\r\nimport { safeString } from '../utils/typeHelpers';\r\n\r\n/**\r\n * SubtabsService - Abstraction layer for subtab storage\r\n * \r\n * Supports both approaches:\r\n * 1. Legacy: conversations.subtabs JSONB array\r\n * 2. Normalized: subtabs table with conversation_id FK and indexes\r\n * \r\n * Toggle via FEATURE_FLAGS.USE_NORMALIZED_SUBTABS\r\n */\r\nexport class SubtabsService {\r\n  private static instance: SubtabsService;\r\n\r\n  static getInstance(): SubtabsService {\r\n    if (!SubtabsService.instance) {\r\n      SubtabsService.instance = new SubtabsService();\r\n    }\r\n    return SubtabsService.instance;\r\n  }\r\n\r\n  /**\r\n   * Get all subtabs for a conversation\r\n   */\r\n  async getSubtabs(conversationId: string): Promise<SubTab[]> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      return this.getSubtabsFromTable(conversationId);\r\n    } else {\r\n      return this.getSubtabsFromJsonb(conversationId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set subtabs for a conversation (replaces all)\r\n   * \r\n   * MIGRATION STRATEGY: During transition period, write to BOTH table AND JSONB\r\n   * to ensure backwards compatibility while normalized table is being adopted\r\n   */\r\n  async setSubtabs(conversationId: string, subtabs: SubTab[]): Promise<boolean> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      console.error(`ðŸ”„ [SubtabsService] Writing ${subtabs.length} subtabs to BOTH table AND JSONB for conversation:`, conversationId);\r\n      \r\n      // Write to normalized table\r\n      const tableSuccess = await this.setSubtabsInTable(conversationId, subtabs);\r\n      console.error(`  âœ… Table write:`, tableSuccess ? 'SUCCESS' : 'FAILED');\r\n      \r\n      // ALSO write to JSONB for backwards compatibility (UI still reads from here)\r\n      const jsonbSuccess = await this.setSubtabsInJsonb(conversationId, subtabs);\r\n      console.error(`  âœ… JSONB write:`, jsonbSuccess ? 'SUCCESS' : 'FAILED');\r\n      \r\n      return tableSuccess && jsonbSuccess;\r\n    } else {\r\n      return this.setSubtabsInJsonb(conversationId, subtabs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single subtab to a conversation\r\n   * \r\n   * MIGRATION STRATEGY: Write to BOTH table AND JSONB during transition\r\n   */\r\n  async addSubtab(conversationId: string, subtab: SubTab): Promise<SubTab | null> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      // Add to normalized table\r\n      const tableResult = await this.addSubtabToTable(conversationId, subtab);\r\n      \r\n      // ALSO add to JSONB for backwards compatibility\r\n      await this.addSubtabToJsonb(conversationId, subtab);\r\n      \r\n      return tableResult;\r\n    } else {\r\n      return this.addSubtabToJsonb(conversationId, subtab);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a subtab in a conversation\r\n   * \r\n   * MIGRATION STRATEGY: Update in BOTH table AND JSONB during transition\r\n   */\r\n  async updateSubtab(\r\n    conversationId: string,\r\n    subtabId: string,\r\n    updates: Partial<SubTab>\r\n  ): Promise<boolean> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      // Update in normalized table\r\n      const tableSuccess = await this.updateSubtabInTable(subtabId, updates);\r\n      \r\n      // ALSO update in JSONB for backwards compatibility\r\n      const jsonbSuccess = await this.updateSubtabInJsonb(conversationId, subtabId, updates);\r\n      \r\n      return tableSuccess && jsonbSuccess;\r\n    } else {\r\n      return this.updateSubtabInJsonb(conversationId, subtabId, updates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a subtab from a conversation\r\n   */\r\n  async deleteSubtab(conversationId: string, subtabId: string): Promise<boolean> {\r\n    if (FEATURE_FLAGS.USE_NORMALIZED_SUBTABS) {\r\n      return this.deleteSubtabFromTable(subtabId);\r\n    } else {\r\n      return this.deleteSubtabFromJsonb(conversationId, subtabId);\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // NORMALIZED SUBTABS TABLE METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get subtabs from normalized subtabs table\r\n   */\r\n  private async getSubtabsFromTable(conversationId: string): Promise<SubTab[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('subtabs')\r\n        .select('*')\r\n        .eq('conversation_id', conversationId)\r\n        .order('order_index', { ascending: true });\r\n\r\n      if (error) {\r\n        console.error('Error getting subtabs from table:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data || []).map((subtab) => {\r\n        const metadata = typeof subtab.metadata === 'object' && subtab.metadata !== null ? subtab.metadata as Record<string, unknown> : {};\r\n        return {\r\n          id: subtab.id,\r\n          title: subtab.title,\r\n          content: subtab.content || '',\r\n          type: subtab.tab_type as SubTab['type'],\r\n          isNew: (metadata.isNew as boolean) || false,\r\n          status: (metadata.status as SubTab['status']) || 'loaded',\r\n          instruction: metadata.instruction as string | undefined,\r\n        };\r\n      });\r\n    } catch (error) {\r\n      console.error('Error getting subtabs from table:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set subtabs in normalized table (replaces all existing subtabs)\r\n   */\r\n  private async setSubtabsInTable(\r\n    conversationId: string,\r\n    subtabs: SubTab[]\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Delete existing subtabs for this conversation\r\n      const { error: deleteError } = await supabase\r\n        .from('subtabs')\r\n        .delete()\r\n        .eq('conversation_id', conversationId);\r\n\r\n      if (deleteError) {\r\n        console.error('Error deleting existing subtabs:', deleteError);\r\n        return false;\r\n      }\r\n\r\n      // Insert new subtabs\r\n      if (subtabs.length > 0) {\r\n        const subtabsToInsert = subtabs.map((subtab, index) => ({\r\n          id: subtab.id,\r\n          conversation_id: conversationId,\r\n          game_id: null, // Made nullable in schema migration\r\n          title: subtab.title,\r\n          content: subtab.content,\r\n          tab_type: subtab.type,\r\n          order_index: index,\r\n          metadata: {\r\n            isNew: subtab.isNew,\r\n            status: subtab.status,\r\n            instruction: subtab.instruction,\r\n          },\r\n        }));\r\n\r\n        // Types not regenerated yet, but schema migration applied (game_id nullable)\r\n        const { error: insertError } = await supabase\r\n          .from('subtabs')\r\n          .insert(subtabsToInsert as any);\r\n\r\n        if (insertError) {\r\n          console.error('Error inserting subtabs:', insertError);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error setting subtabs in table:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single subtab to the normalized table\r\n   */\r\n  private async addSubtabToTable(\r\n    conversationId: string,\r\n    subtab: SubTab\r\n  ): Promise<SubTab | null> {\r\n    try {\r\n      // Get the conversation to find game_id\r\n      const { data: conversation } = await supabase\r\n        .from('conversations')\r\n        .select('game_id')\r\n        .eq('id', conversationId)\r\n        .single();\r\n\r\n      const gameId = conversation?.game_id || '';\r\n\r\n      // Get current max order_index\r\n      const { data: existingSubtabs } = await supabase\r\n        .from('subtabs')\r\n        .select('order_index')\r\n        .eq('conversation_id', conversationId)\r\n        .order('order_index', { ascending: false })\r\n        .limit(1);\r\n\r\n      const nextOrderIndex = existingSubtabs?.[0]?.order_index ?? -1;\r\n\r\n      const { data, error } = await supabase\r\n        .from('subtabs')\r\n        .insert({\r\n          id: subtab.id,\r\n          conversation_id: conversationId,\r\n          game_id: gameId,\r\n          title: subtab.title,\r\n          content: subtab.content,\r\n          tab_type: subtab.type,\r\n          order_index: nextOrderIndex + 1,\r\n          metadata: {\r\n            isNew: subtab.isNew,\r\n            status: subtab.status,\r\n            instruction: subtab.instruction,\r\n          },\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error adding subtab to table:', error);\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        id: data.id,\r\n        title: data.title,\r\n        content: safeString(data.content),\r\n        type: data.tab_type as SubTab['type'],\r\n        isNew: typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata) \r\n          ? (data.metadata as Record<string, unknown>).isNew as boolean || false\r\n          : false,\r\n        status: (typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata)\r\n          ? (data.metadata as Record<string, unknown>).status as SubTab['status']\r\n          : undefined) || 'loaded',\r\n        instruction: typeof data.metadata === 'object' && data.metadata !== null && !Array.isArray(data.metadata)\r\n          ? (data.metadata as Record<string, unknown>).instruction as string | undefined\r\n          : undefined,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error adding subtab to table:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a subtab in the normalized table\r\n   */\r\n  private async updateSubtabInTable(\r\n    subtabId: string,\r\n    updates: Partial<SubTab>\r\n  ): Promise<boolean> {\r\n    try {\r\n      const dbUpdates: Record<string, unknown> = {};\r\n      \r\n      if (updates.title !== undefined) {\r\n        dbUpdates.title = updates.title;\r\n      }\r\n      if (updates.content !== undefined) {\r\n        dbUpdates.content = updates.content;\r\n      }\r\n      if (updates.type !== undefined) {\r\n        dbUpdates.tab_type = updates.type;\r\n      }\r\n      \r\n      // Handle metadata updates\r\n      if (updates.isNew !== undefined || updates.status !== undefined || updates.instruction !== undefined) {\r\n        // Get current metadata\r\n        const { data: current } = await supabase\r\n          .from('subtabs')\r\n          .select('metadata')\r\n          .eq('id', subtabId)\r\n          .single();\r\n\r\n        const currentMetadata = typeof current?.metadata === 'object' && current?.metadata !== null \r\n          ? (current.metadata as Record<string, unknown>)\r\n          : {};\r\n        \r\n        dbUpdates.metadata = {\r\n          ...currentMetadata,\r\n          ...(updates.isNew !== undefined && { isNew: updates.isNew }),\r\n          ...(updates.status !== undefined && { status: updates.status }),\r\n          ...(updates.instruction !== undefined && { instruction: updates.instruction }),\r\n        };\r\n      }\r\n\r\n      const { error } = await supabase\r\n        .from('subtabs')\r\n        .update(dbUpdates)\r\n        .eq('id', subtabId);\r\n\r\n      if (error) {\r\n        console.error('Error updating subtab in table:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error updating subtab in table:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a subtab from the normalized table\r\n   */\r\n  private async deleteSubtabFromTable(subtabId: string): Promise<boolean> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('subtabs')\r\n        .delete()\r\n        .eq('id', subtabId);\r\n\r\n      if (error) {\r\n        console.error('Error deleting subtab from table:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error deleting subtab from table:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // LEGACY JSONB METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get subtabs from conversations.subtabs JSONB field\r\n   */\r\n  private async getSubtabsFromJsonb(conversationId: string): Promise<SubTab[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('conversations')\r\n        .select('subtabs')\r\n        .eq('id', conversationId)\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error('Error getting subtabs from JSONB:', error);\r\n        return [];\r\n      }\r\n\r\n      return (data?.subtabs as unknown as SubTab[]) || [];\r\n    } catch (error) {\r\n      console.error('Error getting subtabs from JSONB:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set subtabs in conversations.subtabs JSONB field\r\n   */\r\n  private async setSubtabsInJsonb(\r\n    conversationId: string,\r\n    subtabs: SubTab[]\r\n  ): Promise<boolean> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('conversations')\r\n        .update({\r\n          subtabs: subtabs as unknown as never,\r\n          subtabs_order: subtabs.map((tab) => tab.id) as unknown as never, // Fixed: Use snake_case column name\r\n        })\r\n        .eq('id', conversationId);\r\n\r\n      if (error) {\r\n        console.error('Error setting subtabs in JSONB:', error);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error setting subtabs in JSONB:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single subtab to conversations.subtabs JSONB array\r\n   */\r\n  private async addSubtabToJsonb(\r\n    conversationId: string,\r\n    subtab: SubTab\r\n  ): Promise<SubTab | null> {\r\n    try {\r\n      // Get current subtabs\r\n      const currentSubtabs = await this.getSubtabsFromJsonb(conversationId);\r\n      \r\n      // Add new subtab\r\n      const updatedSubtabs = [...currentSubtabs, subtab];\r\n      \r\n      // Save back\r\n      const success = await this.setSubtabsInJsonb(conversationId, updatedSubtabs);\r\n      \r\n      return success ? subtab : null;\r\n    } catch (error) {\r\n      console.error('Error adding subtab to JSONB:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a subtab in conversations.subtabs JSONB array\r\n   */\r\n  private async updateSubtabInJsonb(\r\n    conversationId: string,\r\n    subtabId: string,\r\n    updates: Partial<SubTab>\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Get current subtabs\r\n      const currentSubtabs = await this.getSubtabsFromJsonb(conversationId);\r\n      \r\n      // Find and update subtab\r\n      const updatedSubtabs = currentSubtabs.map((subtab) =>\r\n        subtab.id === subtabId ? { ...subtab, ...updates } : subtab\r\n      );\r\n      \r\n      // Save back\r\n      return await this.setSubtabsInJsonb(conversationId, updatedSubtabs);\r\n    } catch (error) {\r\n      console.error('Error updating subtab in JSONB:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a subtab from conversations.subtabs JSONB array\r\n   */\r\n  private async deleteSubtabFromJsonb(\r\n    conversationId: string,\r\n    subtabId: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Get current subtabs\r\n      const currentSubtabs = await this.getSubtabsFromJsonb(conversationId);\r\n      \r\n      // Filter out the subtab\r\n      const updatedSubtabs = currentSubtabs.filter((subtab) => subtab.id !== subtabId);\r\n      \r\n      // Save back\r\n      return await this.setSubtabsInJsonb(conversationId, updatedSubtabs);\r\n    } catch (error) {\r\n      console.error('Error deleting subtab from JSONB:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // MIGRATION UTILITIES\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Migrate subtabs from JSONB to normalized table for a specific conversation\r\n   */\r\n  async migrateConversationSubtabs(conversationId: string): Promise<boolean> {\r\n    try {\r\n      // Get subtabs from JSONB\r\n      const subtabs = await this.getSubtabsFromJsonb(conversationId);\r\n\r\n      if (subtabs.length === 0) {\r\n        return true;\r\n      }\r\n\r\n      // Write to normalized table\r\n      const success = await this.setSubtabsInTable(conversationId, subtabs);\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error migrating subtabs:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rollback: Copy subtabs from table back to JSONB for a specific conversation\r\n   */\r\n  async rollbackConversationSubtabs(conversationId: string): Promise<boolean> {\r\n    try {\r\n      // Get subtabs from table\r\n      const subtabs = await this.getSubtabsFromTable(conversationId);\r\n\r\n      if (subtabs.length === 0) {\r\n        return true;\r\n      }\r\n\r\n      // Write to JSONB\r\n      const success = await this.setSubtabsInJsonb(conversationId, subtabs);\r\n\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error rolling back subtabs:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch migrate all conversations with subtabs\r\n   */\r\n  async migrateAllSubtabs(): Promise<{ success: number; failed: number }> {\r\n    try {\r\n      // Get all conversations with subtabs\r\n      const { data: conversations, error } = await supabase\r\n        .from('conversations')\r\n        .select('id, subtabs')\r\n        .not('subtabs', 'is', null);\r\n\r\n      if (error) {\r\n        console.error('Error fetching conversations:', error);\r\n        return { success: 0, failed: 0 };\r\n      }\r\n\r\n      let successCount = 0;\r\n      let failedCount = 0;\r\n\r\n      // Process all conversations in parallel for better performance\r\n      const migrationPromises = (conversations || [])\r\n        .filter(conv => conv.subtabs && Array.isArray(conv.subtabs) && conv.subtabs.length > 0)\r\n        .map(conv => this.migrateConversationSubtabs(conv.id));\r\n\r\n      const results = await Promise.allSettled(migrationPromises);\r\n\r\n      results.forEach(result => {\r\n        if (result.status === 'fulfilled' && result.value) {\r\n          successCount++;\r\n        } else {\r\n          failedCount++;\r\n        }\r\n      });\r\n\r\n      return { success: successCount, failed: failedCount };\r\n    } catch (error) {\r\n      console.error('Error in batch migration:', error);\r\n      return { success: 0, failed: 0 };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const subtabsService = SubtabsService.getInstance();\r\n","import { Conversation, SubTab, GameTab, insightTabsConfig, AIResponse, PlayerProfile } from '../types';\r\nimport { aiService } from './aiService';\r\nimport { ConversationService } from './conversationService';\r\nimport { profileAwareTabService, GameContext, ProfileSpecificTab } from './profileAwareTabService';\r\nimport { toastService } from './toastService';\r\nimport { subtabsService } from './subtabsService';\r\n\r\n// âœ… UUID generator utility\r\nfunction generateUUID(): string {\r\n  return globalThis.crypto?.randomUUID() || \r\n    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n      const r = Math.random() * 16 | 0;\r\n      const v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n      return v.toString(16);\r\n    });\r\n}\r\n\r\nexport interface GameTabCreationData {\r\n  gameTitle: string;\r\n  genre: string;\r\n  conversationId: string;\r\n  userId: string;\r\n  aiResponse?: AIResponse; // Optional AI response to extract insights from\r\n  playerProfile?: PlayerProfile; // Optional player profile for personalization\r\n  gameContext?: GameContext; // Optional game context (playthrough count, etc.)\r\n  isUnreleased?: boolean; // True for unreleased/upcoming games\r\n}\r\n\r\nclass GameTabService {\r\n  /**\r\n   * Create a new game-specific conversation tab (IDEMPOTENT)\r\n   * If tab already exists, returns it and optionally updates subtabs with new AI insights\r\n   */\r\n  async createGameTab(data: GameTabCreationData): Promise<Conversation> {\r\n    console.log('ðŸŽ® [GameTabService] Creating game tab:', data);\r\n\r\n    // âœ… IDEMPOTENT: Check if tab already exists\r\n    const existingConv = await ConversationService.getConversation(data.conversationId);\r\n    \r\n    if (existingConv) {\r\n      console.log('ðŸŽ® [GameTabService] Tab already exists:', existingConv.title);\r\n      \r\n      // âœ… Update subtabs if they're loading and we have new AI response\r\n      if (data.aiResponse && existingConv.subtabs?.some(tab => tab.status === 'loading' || tab.content === 'Loading...')) {\r\n        console.log('ðŸŽ® [GameTabService] Updating loading subtabs with new AI insights');\r\n        const updatedSubtabs = this.extractInsightsFromAIResponse(\r\n          data.aiResponse, \r\n          existingConv.subtabs\r\n        );\r\n        \r\n        await ConversationService.updateConversation(existingConv.id, {\r\n          subtabs: updatedSubtabs,\r\n          updatedAt: Date.now()\r\n        });\r\n        \r\n        return { ...existingConv, subtabs: updatedSubtabs };\r\n      }\r\n      \r\n      // Return existing tab as-is\r\n      return existingConv;\r\n    }\r\n\r\n    // Tab doesn't exist - create new one\r\n    console.log('ðŸŽ® [GameTabService] Creating new tab for:', data.gameTitle);\r\n    \r\n    // For unreleased games, don't generate subtabs\r\n    let subTabs: SubTab[] = [];\r\n    \r\n    if (!data.isUnreleased) {\r\n      if (data.aiResponse) {\r\n        console.error('ðŸŽ® [GameTabService] Extracting subtabs from AI response');\r\n        \r\n        // âœ… PRIORITY 1: Check if AI provided pre-filled subtab content (gamePillData.wikiContent)\r\n        if (data.aiResponse.gamePillData?.wikiContent && Object.keys(data.aiResponse.gamePillData.wikiContent).length > 0) {\r\n          console.error('ðŸŽ® [GameTabService] Found gamePillData.wikiContent with', Object.keys(data.aiResponse.gamePillData.wikiContent).length, 'tabs');\r\n          \r\n          // Convert wikiContent to SubTab array with proper UUIDs\r\n          subTabs = Object.entries(data.aiResponse.gamePillData.wikiContent).map(([tabId, content]) => ({\r\n            id: generateUUID(), // âœ… Generate proper UUID instead of using string tabId\r\n            title: this.formatTabTitle(tabId),\r\n            type: this.determineTabType(tabId),\r\n            content: content,\r\n            isNew: false,\r\n            status: 'loaded' as const\r\n          }));\r\n          console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'subtabs from gamePillData.wikiContent');\r\n        }\r\n        // âœ… PRIORITY 2: Check for progressiveInsightUpdates\r\n        else if (data.aiResponse.progressiveInsightUpdates && data.aiResponse.progressiveInsightUpdates.length > 0) {\r\n          console.error('ðŸŽ® [GameTabService] Found progressiveInsightUpdates with', data.aiResponse.progressiveInsightUpdates.length, 'updates');\r\n          \r\n          subTabs = data.aiResponse.progressiveInsightUpdates.map(update => ({\r\n            id: generateUUID(), // âœ… Generate proper UUID\r\n            title: update.title,\r\n            type: this.determineTabType(update.tabId),\r\n            content: update.content,\r\n            isNew: false,\r\n            status: 'loaded' as const\r\n          }));\r\n          console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'subtabs from progressiveInsightUpdates');\r\n        }\r\n        // âœ… PRIORITY 3: Try to extract INSIGHT_UPDATE tags from AI content\r\n        else {\r\n          const extractedSubtabs = this.extractInsightsFromAIResponse(data.aiResponse, []);\r\n          \r\n          if (extractedSubtabs.length > 0) {\r\n            subTabs = extractedSubtabs;\r\n            console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'subtabs from INSIGHT_UPDATE tags');\r\n          } else {\r\n            // âœ… FALLBACK: Create template subtabs and populate them via background AI call\r\n            subTabs = this.generateInitialSubTabs(data.genre || 'Default', data.playerProfile);\r\n            console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'template subtabs (will populate via background AI using conversation context)');\r\n          }\r\n        }\r\n      } else {\r\n        // No AI response - create template subtabs\r\n        subTabs = this.generateInitialSubTabs(data.genre || 'Default', data.playerProfile);\r\n        console.error('ðŸŽ® [GameTabService] Created', subTabs.length, 'initial template subtabs (no AI response)');\r\n      }\r\n    } else {\r\n      console.error('ðŸŽ® [GameTabService] Creating unreleased game tab (no subtabs, Discuss mode only)');\r\n    }\r\n    \r\n    // Create the conversation\r\n    const conversation: Conversation = {\r\n      id: data.conversationId,\r\n      title: data.gameTitle,\r\n      messages: [],\r\n      createdAt: Date.now(),\r\n      updatedAt: Date.now(),\r\n      isActive: false,\r\n      gameId: data.gameTitle.toLowerCase().replace(/\\s+/g, '-'),\r\n      gameTitle: data.gameTitle,\r\n      genre: data.genre,\r\n      subtabs: subTabs,\r\n      subtabsOrder: subTabs.map(tab => tab.id),\r\n      isActiveSession: false,\r\n      activeObjective: '',\r\n      gameProgress: 0,\r\n      isUnreleased: data.isUnreleased || false // Mark if unreleased\r\n    };\r\n\r\n    // Save to database\r\n    await ConversationService.addConversation(conversation);\r\n\r\n    // Save subtabs using the subtabsService (handles both JSONB and normalized approaches)\r\n    if (subTabs.length > 0) {\r\n      console.error('ðŸŽ® [GameTabService] Saving', subTabs.length, 'subtabs for conversation:', conversation.id);\r\n      console.error('ðŸŽ® [GameTabService] Subtabs:', JSON.stringify(subTabs, null, 2));\r\n      await subtabsService.setSubtabs(conversation.id, subTabs);\r\n    } else {\r\n      console.error('ðŸŽ® [GameTabService] No subtabs to save for conversation:', conversation.id);\r\n    }\r\n\r\n    // Generate AI insights in background (non-blocking)\r\n    // Only generate if we didn't already get them from the response\r\n    if (!data.aiResponse) {\r\n      this.generateInitialInsights(conversation, data.playerProfile, data.aiResponse).catch(error => \r\n        console.error('Background insight generation failed:', error)\r\n      );\r\n    } else {\r\n      // If some subtabs still have \"Loading...\" content, generate insights for them in background\r\n      const needsInsights = conversation.subtabs?.some(tab => tab.content === 'Loading...');\r\n      if (needsInsights) {\r\n        // âœ… CRITICAL: Pass aiResponse so the AI has context from the screenshot\r\n        this.generateInitialInsights(conversation, data.playerProfile, data.aiResponse).catch(error => \r\n          console.error('Background insight generation failed:', error)\r\n        );\r\n      }\r\n    }\r\n\r\n    // Return immediately without waiting for insights\r\n    return conversation;\r\n  }\r\n\r\n  /**\r\n   * Generate initial sub-tabs based on game genre and player profile\r\n   * Note: Currently unused - tab generation now handled via Edge Function\r\n   */\r\n  // @ts-ignore - Kept for future reference\r\n  private generateInitialSubTabs(\r\n    genre: string,\r\n    playerProfile?: PlayerProfile,\r\n    gameContext?: GameContext\r\n  ): SubTab[] {\r\n    // Get base genre tabs\r\n    const config = insightTabsConfig[genre] || insightTabsConfig['Default'];\r\n    let baseTabs: ProfileSpecificTab[] = config.map(tabConfig => ({\r\n      ...tabConfig,\r\n      priority: 'medium' as const,\r\n      isProfileSpecific: false\r\n    }));\r\n    \r\n    // If player profile exists, add profile-specific tabs\r\n    if (playerProfile) {\r\n      console.error('ðŸŽ® [GameTabService] Generating profile-specific tabs for:', playerProfile.playerFocus);\r\n      const profileTabs = profileAwareTabService.generateProfileSpecificTabs(\r\n        playerProfile,\r\n        gameContext\r\n      );\r\n      \r\n      // Merge base tabs with profile-specific tabs\r\n      baseTabs = [...baseTabs, ...profileTabs];\r\n      \r\n      // Prioritize tabs based on profile\r\n      baseTabs = profileAwareTabService.prioritizeTabsForProfile(baseTabs, playerProfile);\r\n    }\r\n    \r\n    // Convert to SubTab format with proper UUIDs\r\n    return baseTabs.map(tabConfig => ({\r\n      id: generateUUID(), // âœ… Generate proper UUID\r\n      title: tabConfig.title,\r\n      type: tabConfig.type,\r\n      content: 'Loading...',\r\n      isNew: true,\r\n      status: 'loading' as const,\r\n      instruction: tabConfig.instruction\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Extract subtab insights from AI response tags\r\n   * âœ… NEW: Creates subtabs dynamically based on actual AI insights, not templates\r\n   */\r\n  private extractInsightsFromAIResponse(aiResponse: AIResponse, existingSubtabs: SubTab[]): SubTab[] {\r\n    console.error('ðŸ¤– [GameTabService] Extracting dynamic insights from AI response');\r\n    \r\n    // Check if AI provided INSIGHT_UPDATE tags\r\n    const insightUpdates = aiResponse.otakonTags.get('INSIGHT_UPDATE');\r\n    \r\n    if (insightUpdates) {\r\n      console.error('ðŸ¤– [GameTabService] Found INSIGHT_UPDATE:', insightUpdates);\r\n      \r\n      // Check if subtab already exists\r\n      const existingTab = existingSubtabs.find(tab => tab.id === insightUpdates.id);\r\n      \r\n      if (existingTab) {\r\n        // Update existing subtab\r\n        return existingSubtabs.map(tab => \r\n          tab.id === insightUpdates.id\r\n            ? {\r\n                ...tab,\r\n                content: insightUpdates.content,\r\n                isNew: true,\r\n                status: 'loaded' as const\r\n              }\r\n            : tab\r\n        );\r\n      } else {\r\n        // âœ… Create new subtab dynamically with proper UUID\r\n        const newTab: SubTab = {\r\n          id: generateUUID(), // âœ… Generate proper UUID\r\n          title: this.formatTabTitle(insightUpdates.id),\r\n          type: this.determineTabType(insightUpdates.id),\r\n          content: insightUpdates.content,\r\n          isNew: true,\r\n          status: 'loaded' as const\r\n        };\r\n        return [...existingSubtabs, newTab];\r\n      }\r\n    }\r\n    \r\n    // No specific insight tags - return existing subtabs unchanged\r\n    return existingSubtabs;\r\n  }\r\n\r\n  /**\r\n   * Format subtab ID into readable title\r\n   */\r\n  private formatTabTitle(tabId: string): string {\r\n    return tabId\r\n      .split('_')\r\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\r\n      .join(' ');\r\n  }\r\n\r\n  /**\r\n   * Determine tab type based on ID\r\n   */\r\n  private determineTabType(tabId: string): 'chat' | 'walkthrough' | 'tips' | 'strategies' | 'story' | 'characters' | 'items' {\r\n    if (tabId.includes('story')) {\r\n      return 'story';\r\n    }\r\n    if (tabId.includes('character')) {\r\n      return 'characters';\r\n    }\r\n    if (tabId.includes('strategy') || tabId.includes('tips')) {\r\n      return 'tips';\r\n    }\r\n    if (tabId.includes('boss')) {\r\n      return 'strategies';\r\n    }\r\n    if (tabId.includes('quest') || tabId.includes('walkthrough')) {\r\n      return 'walkthrough';\r\n    }\r\n    if (tabId.includes('item')) {\r\n      return 'items';\r\n    }\r\n    return 'chat';\r\n  }\r\n\r\n  /**\r\n   * Generate initial AI insights for all sub-tabs\r\n   * This runs in the background and updates the conversation when complete\r\n   */\r\n  private async generateInitialInsights(\r\n    conversation: Conversation,\r\n    playerProfile?: PlayerProfile,\r\n    aiResponse?: AIResponse // âœ… NEW: AI response from screenshot analysis\r\n  ): Promise<void> {\r\n    const conversationId = conversation.id;\r\n    const gameTitle = conversation.gameTitle;\r\n    console.error(`ðŸ¤– [GameTabService] ðŸ”„ [${conversationId}] Generating initial insights for: ${gameTitle}`);\r\n\r\n    try {\r\n      // âœ… SAFETY CHECK: Verify conversation still exists before starting expensive AI call\r\n      const preCheckConversations = await ConversationService.getConversations(true);\r\n      if (!preCheckConversations[conversationId]) {\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] âš ï¸ Conversation no longer exists, aborting insight generation`);\r\n        return; // Early exit - user may have deleted tab or switched games\r\n      }\r\n\r\n      // âœ… CRITICAL: Use AI response content as context (not conversation.messages which is empty at creation time!)\r\n      // Priority 1: Use AI response content (from screenshot analysis)\r\n      // Priority 2: Use conversation messages (if migrated already)\r\n      let conversationContext = '';\r\n      \r\n      if (aiResponse?.content) {\r\n        conversationContext = `AI Analysis: ${aiResponse.content}`;\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] Using AI response as context (${aiResponse.content.length} chars)`);\r\n      } else if (conversation.messages.length > 0) {\r\n        conversationContext = conversation.messages\r\n          .map(msg => `${msg.role === 'user' ? 'User' : 'AI'}: ${msg.content}`)\r\n          .join('\\n\\n');\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] Using messages as context (${conversation.messages.length} msgs)`);\r\n      } else {\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] âš ï¸ No context available`);\r\n      }\r\n      \r\n      console.error(`ðŸ¤– [GameTabService] [${conversationId}] ðŸš€ Calling AI generateInitialInsights...`);\r\n      const insights = await aiService.generateInitialInsights(\r\n        gameTitle || 'Unknown Game',\r\n        conversation.genre || 'Action RPG',\r\n        playerProfile,\r\n        conversationContext\r\n      );\r\n      console.error(`ðŸ¤– [GameTabService] [${conversationId}] ðŸ“¥ AI returned:`, Object.keys(insights).length, 'insights');\r\n\r\n      // âœ… SAFETY CHECK: Verify conversation STILL exists after AI call\r\n      const postAICheck = await ConversationService.getConversations(true);\r\n      if (!postAICheck[conversationId]) {\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] âš ï¸ Conversation deleted during AI call, discarding results`);\r\n        return;\r\n      }\r\n\r\n      // âœ… Check if insights were actually generated (not empty object from error fallback)\r\n      const hasInsights = insights && Object.keys(insights).length > 0;\r\n      if (!hasInsights) {\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] âŒ Empty insights, using fallback`);\r\n      } else {\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] âœ… Got ${Object.keys(insights).length} insights:`, Object.keys(insights));\r\n      }\r\n\r\n      // âœ… CRITICAL FIX: Read fresh conversation data from DB before updating\r\n      const conversations = await ConversationService.getConversations(true);\r\n      const freshConversation = conversations[conversationId];\r\n      \r\n      if (!freshConversation) {\r\n        console.error(`ðŸ¤– [GameTabService] [${conversationId}] âš ï¸ Conversation not found, may have been deleted`);\r\n        return;\r\n      }\r\n\r\n      // ðŸ”¥ MAP insight keys to subtab IDs\r\n      // AI returns keys like \"story_so_far\" but subtabs have UUID ids\r\n      // We need to map based on subtab type\r\n      const typeToKeyMap: Record<string, string> = {\r\n        'story': 'story_so_far',\r\n        'walkthrough': 'quest_log',\r\n        'strategies': 'build_optimization', // First strategies tab\r\n        'tips': 'hidden_paths'\r\n      };\r\n      \r\n      console.error('ðŸ¤– [GameTabService] Building content mapping for subtabs...');\r\n      \r\n      // Update sub-tabs with generated content OR meaningful fallback\r\n      const updatedSubTabs = freshConversation.subtabs?.map(subTab => {\r\n        let content: string = '';\r\n        \r\n        // Map subtab type to insight key\r\n        const insightKey = typeToKeyMap[subTab.type];\r\n        \r\n        // For multiple tabs of same type, use alternate keys\r\n        if (subTab.type === 'strategies' && subTab.title.includes('Boss')) {\r\n          const bossKey = 'boss_strategy';\r\n          if (hasInsights && insights[bossKey]) {\r\n            content = insights[bossKey];\r\n            console.error(`ðŸ¤– [GameTabService] Subtab \"${subTab.title}\" using AI content from key \"${bossKey}\" (${content.length} chars)`);\r\n          }\r\n        }\r\n        \r\n        if (!content && hasInsights && insightKey && insights[insightKey]) {\r\n          // Use AI-generated content\r\n          content = insights[insightKey];\r\n          console.error(`ðŸ¤– [GameTabService] Subtab \"${subTab.title}\" using AI content from key \"${insightKey}\" (${content.length} chars)`);\r\n        }\r\n        \r\n        if (!content) {\r\n          // âœ… IMPROVED FALLBACK: Use the actual AI response from initial message\r\n          // The AI already analyzed the screenshot - use that content!\r\n          \r\n          // Extract the relevant part from conversation context based on tab type\r\n          let fallbackContent = conversationContext;\r\n          \r\n          // Try to extract specific sections if they exist in the AI response\r\n          if (subTab.type === 'story' && conversationContext.includes('Lore:')) {\r\n            const loreMatch = conversationContext.match(/Lore:(.*?)(?=\\n\\n|\\n[A-Z]|$)/s);\r\n            fallbackContent = loreMatch ? loreMatch[1].trim() : conversationContext;\r\n          } else if (subTab.type === 'strategies' && conversationContext.includes('Analysis:')) {\r\n            const analysisMatch = conversationContext.match(/Analysis:(.*?)(?=\\n\\n|\\n[A-Z]|$)/s);\r\n            fallbackContent = analysisMatch ? analysisMatch[1].trim() : conversationContext;\r\n          } else if (subTab.type === 'tips' && conversationContext.includes('Hint:')) {\r\n            const hintMatch = conversationContext.match(/Hint:(.*?)(?=\\n\\n|\\n[A-Z]|$)/s);\r\n            fallbackContent = hintMatch ? hintMatch[1].trim() : conversationContext;\r\n          }\r\n          \r\n          content = `## ${subTab.title}\\n\\n${fallbackContent}`;\r\n          \r\n          console.error(`ðŸ¤– [GameTabService] Subtab \"${subTab.title}\" using fallback content from AI response (${content.length} chars)`);\r\n          console.error(`ðŸ¤– [GameTabService] Preview:`, content.substring(0, 150) + '...');\r\n        }\r\n        \r\n        return {\r\n          ...subTab,\r\n          content,\r\n          isNew: false,\r\n          status: 'loaded' as const\r\n        };\r\n      }) || [];\r\n\r\n      // ðŸ”¥ CRITICAL FIX: Dual-write to both normalized table AND JSONB\r\n      // The initial subtab creation uses setSubtabs (dual-write), but updates must too!\r\n      console.error('ðŸ¤– [GameTabService] Updating subtabs with content...');\r\n      const subtabsDebug = updatedSubTabs.map(s => ({\r\n        id: s.id,\r\n        title: s.title,\r\n        status: s.status,\r\n        contentLength: s.content?.length || 0,\r\n        isNew: s.isNew\r\n      }));\r\n      console.error('ðŸ¤– [GameTabService] Subtabs to save:', subtabsDebug);\r\n      console.error('ðŸ¤– [GameTabService] ALL statuses:', updatedSubTabs.map(s => s.status));\r\n      \r\n      // âœ… FIX: Clear cache BEFORE write to prevent stale reads during write\r\n      console.error('ðŸ¤– [GameTabService] ðŸ—‘ï¸ Clearing cache BEFORE subtabs write...');\r\n      ConversationService.clearCache();\r\n      \r\n      await subtabsService.setSubtabs(conversation.id, updatedSubTabs);\r\n      console.error('ðŸ¤– [GameTabService] âœ… Subtabs dual-write complete (table + JSONB)');\r\n      \r\n      // âœ… FIX: Clear cache AGAIN after write\r\n      ConversationService.clearCache();\r\n      \r\n      // âœ… FIX: Wait 500ms to ensure database write fully propagates\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n      \r\n      // âœ… VERIFICATION: Read back immediately to confirm write\r\n      const verifyConversations = await ConversationService.getConversations(true); // skipCache\r\n      const verifyConv = verifyConversations[conversation.id];\r\n      if (verifyConv) {\r\n        console.error('ðŸ¤– [GameTabService] ðŸ” VERIFICATION: Read back subtabs after write:', \r\n          verifyConv.subtabs?.map(s => ({ title: s.title, status: s.status })) || 'NO SUBTABS');\r\n      } else {\r\n        console.error('ðŸ¤– [GameTabService] âš ï¸ VERIFICATION: Could not find conversation after write!');\r\n      }\r\n      \r\n      // Also update conversation metadata (last updated time, etc.)\r\n      await ConversationService.updateConversation(conversation.id, {\r\n        updatedAt: Date.now()\r\n      });\r\n      console.error('ðŸ¤– [GameTabService] âœ… Conversation metadata updated');\r\n\r\n    } catch (error) {\r\n      console.error('ðŸ¤– [GameTabService] âŒ Failed to generate initial insights:', error);\r\n      toastService.warning('Failed to load game insights. You can still chat about the game!');\r\n      \r\n      // âœ… CRITICAL FIX: Read fresh conversation before updating error state\r\n      try {\r\n        const conversations = await ConversationService.getConversations(true); // skipCache = true\r\n        const freshConversation = conversations[conversation.id];\r\n        \r\n        if (!freshConversation) {\r\n          console.error('ðŸ¤– [GameTabService] Conversation not found for error update:', conversation.id);\r\n          return;\r\n        }\r\n        \r\n        // Set error state for sub-tabs\r\n        const errorSubTabs = freshConversation.subtabs?.map(subTab => ({\r\n          ...subTab,\r\n          content: `Failed to load ${subTab.title} content. Please try again later.`,\r\n          isNew: false,\r\n          status: 'error' as const\r\n        })) || [];\r\n\r\n        // ðŸ”¥ CRITICAL FIX: Dual-write error state too!\r\n        await subtabsService.setSubtabs(conversation.id, errorSubTabs);\r\n        await ConversationService.updateConversation(conversation.id, {\r\n          updatedAt: Date.now()\r\n        });\r\n      } catch (updateError) {\r\n        console.error('ðŸ¤– [GameTabService] Failed to update error state:', updateError);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a specific sub-tab content\r\n   */\r\n  async updateSubTabContent(\r\n    conversationId: string, \r\n    subTabId: string, \r\n    content: string\r\n  ): Promise<void> {\r\n    console.error('ðŸ“ [GameTabService] Updating sub-tab content:', { conversationId, subTabId });\r\n\r\n    try {\r\n      // Get current conversation\r\n      const conversations = await ConversationService.getConversations();\r\n      const conversation = conversations[conversationId];\r\n      \r\n      if (!conversation || !conversation.subtabs) {\r\n        throw new Error('Conversation or sub-tabs not found');\r\n      }\r\n\r\n      // Update the specific sub-tab\r\n      const updatedSubTabs = conversation.subtabs.map(tab => \r\n        tab.id === subTabId \r\n          ? { ...tab, content, isNew: false, status: 'loaded' as const }\r\n          : tab\r\n      );\r\n\r\n      // ðŸ”¥ CRITICAL FIX: Dual-write for individual subtab updates too!\r\n      await subtabsService.setSubtabs(conversationId, updatedSubTabs);\r\n      await ConversationService.updateConversation(conversationId, {\r\n        updatedAt: Date.now()\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to update sub-tab content:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get game tab by conversation ID\r\n   */\r\n  async getGameTab(conversationId: string): Promise<GameTab | null> {\r\n    try {\r\n      const conversations = await ConversationService.getConversations();\r\n      const conversation = conversations[conversationId];\r\n      \r\n      if (!conversation || !conversation.gameTitle) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        id: conversation.id,\r\n        title: conversation.title,\r\n        gameId: conversation.gameId || conversation.gameTitle.toLowerCase().replace(/\\s+/g, '-'),\r\n        gameTitle: conversation.gameTitle,\r\n        genre: conversation.genre || 'Unknown',\r\n        subtabs: conversation.subtabs || [],\r\n        createdAt: conversation.createdAt,\r\n        updatedAt: conversation.updatedAt,\r\n        isActiveSession: conversation.isActiveSession || false\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to get game tab:', error);\r\n      toastService.error('Failed to load game tab.');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a conversation is a game tab\r\n   */\r\n  isGameTab(conversation: Conversation): boolean {\r\n    return !conversation.isGameHub && !!conversation.gameTitle;\r\n  }\r\n\r\n  /**\r\n   * Generate a unique conversation ID for a game\r\n   * Note: Removed timestamp to ensure consistent IDs for the same game\r\n   */\r\n  generateGameConversationId(gameTitle: string): string {\r\n    const sanitized = gameTitle.toLowerCase().replace(/[^a-z0-9\\s-]/g, '').replace(/\\s+/g, '-');\r\n    return `game-${sanitized}`;\r\n  }\r\n\r\n  /**\r\n   * Update subtabs from AI response (progressive updates)\r\n   * This allows AI to update existing subtabs based on new information\r\n   */\r\n  async updateSubTabsFromAIResponse(\r\n    conversationId: string,\r\n    updates: Array<{ tabId: string; title: string; content: string }>\r\n  ): Promise<void> {\r\n    console.error(`ðŸ“ [GameTabService] [${conversationId}] Updating subtabs from AI response:`, updates.length);\r\n\r\n    try {\r\n      // âœ… RACE CONDITION SAFEGUARD: Get fresh conversation data\r\n      const conversations = await ConversationService.getConversations(true);\r\n      const conversation = conversations[conversationId];\r\n      \r\n      if (!conversation || !conversation.subtabs) {\r\n        console.error(`ðŸ“ [GameTabService] [${conversationId}] âš ï¸ Conversation or subtabs not found, aborting update`);\r\n        return;\r\n      }\r\n\r\n      // Update the specific subtabs with linear progression (append, not overwrite)\r\n      let updatedCount = 0;\r\n      const updatedSubTabs = conversation.subtabs.map(tab => {\r\n        const update = updates.find(u => u.tabId === tab.id);\r\n        if (update) {\r\n          updatedCount++;\r\n          console.error(`ðŸ“ [GameTabService] [${conversationId}] Updating subtab: ${tab.id} - ${update.title}`);\r\n          \r\n          // âœ… LINEAR PROGRESSION: Append new content with timestamp separator\r\n          const timestamp = new Date().toLocaleString();\r\n          const separator = '\\n\\n---\\n**Updated: ' + timestamp + '**\\n\\n';\r\n          \r\n          // Only append if there's existing content (not \"Loading...\")\r\n          const shouldAppend = tab.content && \r\n                               tab.content.trim().length > 0 && \r\n                               tab.content !== 'Loading...' &&\r\n                               tab.status === 'loaded';\r\n          \r\n          const newContent = shouldAppend\r\n            ? tab.content + separator + update.content  // âœ… Append to existing\r\n            : update.content;  // First update or loading state\r\n          \r\n          return {\r\n            ...tab,\r\n            title: update.title || tab.title, // Update title if provided\r\n            content: newContent,  // âœ… Accumulated history\r\n            isNew: true, // Mark as new to show indicator\r\n            status: 'loaded' as const\r\n          };\r\n        }\r\n        return tab;\r\n      });\r\n\r\n      // Only update if something changed\r\n      if (updatedCount === 0) {\r\n        console.error(`ðŸ“ [GameTabService] [${conversationId}] âš ï¸ No subtabs matched for update`);\r\n        return;\r\n      }\r\n\r\n      // Update conversation with new subtab content\r\n      await ConversationService.updateConversation(conversationId, {\r\n        subtabs: updatedSubTabs,\r\n        updatedAt: Date.now()\r\n      });\r\n\r\n      console.error(`ðŸ“ [GameTabService] [${conversationId}] âœ… Updated ${updatedCount} subtabs successfully`);\r\n    } catch (error) {\r\n      console.error(`ðŸ“ [GameTabService] [${conversationId}] âŒ Failed to update subtabs:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport const gameTabService = new GameTabService();\r\n","import { StorageService } from './storageService';\r\nimport { User, Usage, UserTier } from '../types';\r\nimport { STORAGE_KEYS, TIER_LIMITS, USER_TIERS } from '../constants';\r\nimport { supabase } from '../lib/supabase';\r\nimport { jsonToRecord, safeParseDate, safeNumber } from '../utils/typeHelpers';\r\n\r\nexport class UserService {\r\n  static getCurrentUser(): User | null {\r\n    return StorageService.get(STORAGE_KEYS.USER, null);\r\n  }\r\n\r\n  static setCurrentUser(user: User): void {\r\n    StorageService.set(STORAGE_KEYS.USER, user);\r\n  }\r\n\r\n  static createUser(email: string, tier: UserTier = USER_TIERS.FREE): User {\r\n    const now = Date.now();\r\n    const limits = TIER_LIMITS[tier];\r\n    \r\n    return {\r\n      id: `user_${now}`,\r\n      authUserId: `user_${now}`,\r\n      email,\r\n      tier,\r\n      hasProfileSetup: false,\r\n      hasSeenSplashScreens: false,\r\n      hasSeenHowToUse: false,\r\n      hasSeenFeaturesConnected: false,\r\n      hasSeenProFeatures: false,\r\n      pcConnected: false,\r\n      pcConnectionSkipped: false,\r\n      onboardingCompleted: false,\r\n      hasWelcomeMessage: false,\r\n      isNewUser: true,\r\n      hasUsedTrial: false,\r\n      lastActivity: now,\r\n      preferences: {},\r\n      // Add these required fields from User interface\r\n      textCount: 0,\r\n      imageCount: 0,\r\n      textLimit: limits.text,\r\n      imageLimit: limits.image,\r\n      totalRequests: 0,\r\n      lastReset: now,\r\n      usage: {\r\n        textCount: 0,\r\n        imageCount: 0,\r\n        textLimit: limits.text,\r\n        imageLimit: limits.image,\r\n        totalRequests: 0,\r\n        lastReset: now,\r\n        tier,\r\n      },\r\n      appState: {},\r\n      profileData: {},\r\n      onboardingData: {},\r\n      behaviorData: {},\r\n      feedbackData: {},\r\n      usageData: {},\r\n      createdAt: now,\r\n      updatedAt: now,\r\n    };\r\n  }\r\n\r\n  static updateUser(updates: Partial<User>): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const updatedUser = {\r\n      ...currentUser,\r\n      ...updates,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    this.setCurrentUser(updatedUser);\r\n  }\r\n\r\n  static updateUsage(usage: Partial<Usage>): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    this.updateUser({\r\n      usage: {\r\n        ...currentUser.usage,\r\n        ...usage,\r\n      },\r\n    });\r\n  }\r\n\r\n  static resetUsage(): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const limits = TIER_LIMITS[currentUser.tier];\r\n    this.updateUsage({\r\n      textCount: 0,\r\n      imageCount: 0,\r\n      totalRequests: 0,\r\n      lastReset: Date.now(),\r\n      textLimit: limits.text,\r\n      imageLimit: limits.image,\r\n    });\r\n  }\r\n\r\n  static canMakeRequest(type: 'text' | 'image'): boolean {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return false;\r\n    }\r\n\r\n    const { usage } = currentUser;\r\n    if (type === 'text') {\r\n      return usage.textCount < usage.textLimit;\r\n    } else {\r\n      return usage.imageCount < usage.imageLimit;\r\n    }\r\n  }\r\n\r\n  static incrementUsage(type: 'text' | 'image'): void {\r\n    const currentUser = this.getCurrentUser();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const updates: Partial<Usage> = {\r\n      totalRequests: currentUser.usage.totalRequests + 1,\r\n    };\r\n\r\n    if (type === 'text') {\r\n      updates.textCount = currentUser.usage.textCount + 1;\r\n    } else {\r\n      updates.imageCount = currentUser.usage.imageCount + 1;\r\n    }\r\n\r\n    this.updateUsage(updates);\r\n  }\r\n\r\n  static logout(): void {\r\n    StorageService.remove(STORAGE_KEYS.USER);\r\n  }\r\n\r\n  /**\r\n   * âœ… FIX 8: Get current user with Supabase sync\r\n   * Falls back to localStorage if Supabase unavailable\r\n   */\r\n  static async getCurrentUserAsync(): Promise<User | null> {\r\n    try {\r\n      // 1. Check localStorage first (fast path)\r\n      const cached = StorageService.get<User | null>(STORAGE_KEYS.USER, null);\r\n      \r\n      // 2. Get current auth session\r\n      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();\r\n      if (authError || !authUser) {\r\n        return cached;\r\n      }\r\n      \r\n      // 3. Fetch latest from Supabase (source of truth)\r\n      const { data: dbUser, error: dbError } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('auth_user_id', authUser.id)\r\n        .single();\r\n      \r\n      if (dbError || !dbUser) {\r\n        console.error('Failed to fetch user from Supabase:', dbError);\r\n        return cached; // Fallback to cached\r\n      }\r\n      \r\n      // 4. Map database user to User type\r\n      const user: User = {\r\n        id: dbUser.id,\r\n        authUserId: dbUser.auth_user_id,\r\n        email: dbUser.email,\r\n        tier: dbUser.tier as UserTier,\r\n        \r\n        // Query limits from database\r\n        textCount: dbUser.text_count || 0,\r\n        imageCount: dbUser.image_count || 0,\r\n        textLimit: safeNumber(dbUser.text_limit),\r\n        imageLimit: safeNumber(dbUser.image_limit),\r\n        totalRequests: dbUser.total_requests || 0,\r\n        lastReset: safeParseDate(dbUser.last_reset),\r\n        \r\n        // Onboarding flags\r\n        hasProfileSetup: dbUser.has_profile_setup || false,\r\n        hasSeenSplashScreens: dbUser.has_seen_splash_screens || false,\r\n        hasSeenHowToUse: dbUser.has_seen_how_to_use || false,\r\n        hasSeenFeaturesConnected: dbUser.has_seen_features_connected || false,\r\n        hasSeenProFeatures: dbUser.has_seen_pro_features || false,\r\n        pcConnected: dbUser.pc_connected || false,\r\n        pcConnectionSkipped: dbUser.pc_connection_skipped || false,\r\n        onboardingCompleted: dbUser.onboarding_completed || false,\r\n        hasWelcomeMessage: dbUser.has_welcome_message || false,\r\n        isNewUser: dbUser.is_new_user || false,\r\n        hasUsedTrial: dbUser.has_used_trial || false,\r\n        \r\n        // Other fields\r\n        lastActivity: safeParseDate(dbUser.updated_at),\r\n        preferences: jsonToRecord(dbUser.preferences),\r\n        \r\n        // Legacy nested usage (for backward compatibility)\r\n        usage: {\r\n          textCount: dbUser.text_count || 0,\r\n          imageCount: dbUser.image_count || 0,\r\n          textLimit: safeNumber(dbUser.text_limit),\r\n          imageLimit: safeNumber(dbUser.image_limit),\r\n          totalRequests: dbUser.total_requests || 0,\r\n          lastReset: safeParseDate(dbUser.last_reset),\r\n          tier: dbUser.tier as UserTier,\r\n        },\r\n        \r\n        appState: jsonToRecord(dbUser.app_state),\r\n        profileData: jsonToRecord(dbUser.profile_data),\r\n        onboardingData: jsonToRecord(dbUser.onboarding_data),\r\n        behaviorData: jsonToRecord(dbUser.behavior_data),\r\n        feedbackData: jsonToRecord(dbUser.feedback_data),\r\n        usageData: jsonToRecord(dbUser.usage_data),\r\n        \r\n        createdAt: safeParseDate(dbUser.created_at),\r\n        updatedAt: safeParseDate(dbUser.updated_at),\r\n      };\r\n      \r\n      // 5. Update cache\r\n      StorageService.set(STORAGE_KEYS.USER, user);\r\n      \r\n      return user;\r\n    } catch (error) {\r\n      console.error('Error in getCurrentUserAsync:', error);\r\n      // Fallback to cached user\r\n      return StorageService.get<User | null>(STORAGE_KEYS.USER, null);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * âœ… FIX 8: Set current user with Supabase sync\r\n   * Updates localStorage immediately (optimistic update)\r\n   * Syncs to Supabase in background\r\n   */\r\n  static async setCurrentUserAsync(user: User): Promise<void> {\r\n    try {\r\n      // 1. Update localStorage immediately (optimistic update)\r\n      StorageService.set(STORAGE_KEYS.USER, user);\r\n      \r\n      // 2. Sync to Supabase\r\n      const { error } = await supabase\r\n        .from('users')\r\n        .update({\r\n          tier: user.tier,\r\n          text_count: user.textCount,\r\n          image_count: user.imageCount,\r\n          text_limit: user.textLimit,\r\n          image_limit: user.imageLimit,\r\n          total_requests: user.totalRequests,\r\n          last_reset: new Date(user.lastReset).toISOString(),\r\n          \r\n          // Onboarding flags\r\n          has_profile_setup: user.hasProfileSetup,\r\n          has_seen_splash_screens: user.hasSeenSplashScreens,\r\n          has_seen_how_to_use: user.hasSeenHowToUse,\r\n          has_seen_features_connected: user.hasSeenFeaturesConnected,\r\n          has_seen_pro_features: user.hasSeenProFeatures,\r\n          pc_connected: user.pcConnected,\r\n          pc_connection_skipped: user.pcConnectionSkipped,\r\n          onboarding_completed: user.onboardingCompleted,\r\n          has_welcome_message: user.hasWelcomeMessage,\r\n          has_used_trial: user.hasUsedTrial,\r\n          \r\n          // Data objects\r\n          preferences: user.preferences,\r\n          profile_data: user.profileData,\r\n          app_state: user.appState,\r\n          onboarding_data: user.onboardingData,\r\n          behavior_data: user.behaviorData,\r\n          feedback_data: user.feedbackData,\r\n          usage_data: user.usageData,\r\n          \r\n          updated_at: new Date().toISOString(),\r\n        })\r\n        .eq('auth_user_id', user.authUserId);\r\n      \r\n      if (error) {\r\n        console.error('Failed to sync user to Supabase:', error);\r\n        // Don't throw - optimistic update already done\r\n        // User will sync on next getCurrentUserAsync()\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in setCurrentUserAsync:', error);\r\n      // Don't throw - localStorage update succeeded\r\n    }\r\n  }\r\n\r\n  /**\r\n   * âœ… FIX 8: Update usage with Supabase sync\r\n   */\r\n  static async updateUsageAsync(usage: Partial<Usage>): Promise<void> {\r\n    const currentUser = await this.getCurrentUserAsync();\r\n    if (!currentUser) {\r\n      return;\r\n    }\r\n\r\n    const updatedUser = {\r\n      ...currentUser,\r\n      usage: {\r\n        ...currentUser.usage,\r\n        ...usage,\r\n      },\r\n      // Also update top-level fields\r\n      textCount: usage.textCount ?? currentUser.textCount,\r\n      imageCount: usage.imageCount ?? currentUser.imageCount,\r\n      totalRequests: usage.totalRequests ?? currentUser.totalRequests,\r\n      lastReset: usage.lastReset ?? currentUser.lastReset,\r\n      updatedAt: Date.now(),\r\n    };\r\n\r\n    await this.setCurrentUserAsync(updatedUser);\r\n  }\r\n}\r\n\r\n\r\n","import { Conversation, SubTab } from '../types';\r\n\r\n/**\r\n * Tab Management Service (Command Centre)\r\n * \r\n * Handles parsing and execution of @ commands for managing subtabs.\r\n * Based on the old build's Command Centre feature.\r\n * \r\n * Command Formats:\r\n * - @<tab_name> <instruction>: Update tab with new content\r\n * - @<tab_name> \\modify <instruction>: Modify/rename tab\r\n * - @<tab_name> \\delete: Delete tab\r\n */\r\n\r\nexport interface TabCommand {\r\n  type: 'update' | 'modify' | 'delete';\r\n  tabId: string;\r\n  tabName: string;\r\n  instruction: string;\r\n}\r\n\r\nclass TabManagementService {\r\n  /**\r\n   * Check if message contains a tab management command\r\n   */\r\n  public hasTabCommand(message: string): boolean {\r\n    // Check for @ followed by word characters\r\n    return /^@\\w+/.test(message.trim());\r\n  }\r\n\r\n  /**\r\n   * Parse tab command from user message\r\n   * Returns null if no valid command found\r\n   */\r\n  public parseTabCommand(message: string, conversation: Conversation): TabCommand | null {\r\n    const trimmedMessage = message.trim();\r\n    \r\n    if (!this.hasTabCommand(trimmedMessage)) {\r\n      return null;\r\n    }\r\n\r\n    // Extract command parts: @<tab_name> [\\\\modify|\\\\delete] [instruction]\r\n    const commandMatch = trimmedMessage.match(/^@(\\w+)\\s*(\\\\modify|\\\\delete)?\\s*(.*)$/);\r\n    \r\n    if (!commandMatch) {\r\n      return null;\r\n    }\r\n\r\n    const [, tabName, modifier, instruction] = commandMatch;\r\n    \r\n    // Find matching subtab (case-insensitive, fuzzy match)\r\n    const matchingTab = this.findMatchingTab(tabName, conversation.subtabs || []);\r\n    \r\n    if (!matchingTab) {\r\n      console.warn(`Tab \"${tabName}\" not found in conversation`);\r\n      return null;\r\n    }\r\n\r\n    // Determine command type\r\n    let commandType: 'update' | 'modify' | 'delete';\r\n    if (modifier === '\\\\delete') {\r\n      commandType = 'delete';\r\n    } else if (modifier === '\\\\modify') {\r\n      commandType = 'modify';\r\n    } else {\r\n      commandType = 'update';\r\n    }\r\n\r\n    return {\r\n      type: commandType,\r\n      tabId: matchingTab.id,\r\n      tabName: matchingTab.title,\r\n      instruction: instruction.trim()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find matching subtab by name (fuzzy match)\r\n   * Handles variations like \"story_so_far\", \"story so far\", \"story\", etc.\r\n   */\r\n  private findMatchingTab(searchName: string, subtabs: SubTab[]): SubTab | null {\r\n    const normalizedSearch = this.normalizeTabName(searchName);\r\n    \r\n    // First try exact match\r\n    let match = subtabs.find(tab => \r\n      this.normalizeTabName(tab.id) === normalizedSearch ||\r\n      this.normalizeTabName(tab.title) === normalizedSearch\r\n    );\r\n    \r\n    if (match) {\r\n      return match;\r\n    }\r\n    \r\n    // Then try partial match (search term is contained in tab name)\r\n    match = subtabs.find(tab => \r\n      this.normalizeTabName(tab.id).includes(normalizedSearch) ||\r\n      this.normalizeTabName(tab.title).includes(normalizedSearch)\r\n    );\r\n    \r\n    if (match) {\r\n      return match;\r\n    }\r\n    \r\n    // Finally try reversed partial match (tab name is contained in search term)\r\n    match = subtabs.find(tab => \r\n      normalizedSearch.includes(this.normalizeTabName(tab.id)) ||\r\n      normalizedSearch.includes(this.normalizeTabName(tab.title))\r\n    );\r\n    \r\n    return match || null;\r\n  }\r\n\r\n  /**\r\n   * Normalize tab name for comparison\r\n   */\r\n  private normalizeTabName(name: string): string {\r\n    return name\r\n      .toLowerCase()\r\n      .replace(/[_\\s-]+/g, '')  // Remove separators\r\n      .replace(/[^a-z0-9]/g, ''); // Remove special chars\r\n  }\r\n\r\n  /**\r\n   * Get available tab names for autocomplete\r\n   */\r\n  public getAvailableTabNames(conversation: Conversation): string[] {\r\n    if (!conversation.subtabs || conversation.subtabs.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    return conversation.subtabs.map(tab => ({\r\n      id: tab.id,\r\n      title: tab.title,\r\n      // Create multiple search variations\r\n      variations: [\r\n        tab.id,\r\n        tab.title,\r\n        tab.id.replace(/_/g, ' '),\r\n        tab.title.toLowerCase()\r\n      ]\r\n    }))\r\n    // Return primary names (tab IDs for consistency)\r\n    .map(tab => tab.id);\r\n  }\r\n\r\n  /**\r\n   * Format command for display in autocomplete\r\n   */\r\n  public formatTabSuggestion(tabId: string, _tabTitle: string): string {\r\n    return `@${tabId}`;\r\n  }\r\n\r\n  /**\r\n   * Get command help text\r\n   */\r\n  public getCommandHelp(): string {\r\n    return `\r\n**Tab Commands:**\r\nâ€¢ @<tab> <text> - Update tab with new info\r\nâ€¢ @<tab> \\\\modify <text> - Modify/rename tab\r\nâ€¢ @<tab> \\\\delete - Delete tab\r\n\r\nExample: @story_so_far The player defeated the first boss\r\n    `.trim();\r\n  }\r\n\r\n  /**\r\n   * Validate command before sending to AI\r\n   */\r\n  public validateCommand(command: TabCommand): { valid: boolean; error?: string } {\r\n    switch (command.type) {\r\n      case 'update':\r\n        if (!command.instruction) {\r\n          return { valid: false, error: 'Update command requires content. Example: @story_so_far The player...' };\r\n        }\r\n        break;\r\n      \r\n      case 'modify':\r\n        if (!command.instruction) {\r\n          return { valid: false, error: 'Modify command requires instructions. Example: @tips \\\\modify Change to combat strategies' };\r\n        }\r\n        break;\r\n      \r\n      case 'delete':\r\n        // Delete doesn't need instruction\r\n        break;\r\n    }\r\n\r\n    return { valid: true };\r\n  }\r\n\r\n  /**\r\n   * Get user-friendly description of command\r\n   */\r\n  public describeCommand(command: TabCommand): string {\r\n    switch (command.type) {\r\n      case 'update':\r\n        return `Updating \"${command.tabName}\" with: ${command.instruction}`;\r\n      case 'modify':\r\n        return `Modifying \"${command.tabName}\": ${command.instruction}`;\r\n      case 'delete':\r\n        return `Deleting \"${command.tabName}\"`;\r\n    }\r\n  }\r\n}\r\n\r\nexport const tabManagementService = new TabManagementService();\r\n\r\n","let synth: SpeechSynthesis;\r\nlet voices: SpeechSynthesisVoice[] = [];\r\nlet isInitialized = false;\r\nlet currentText = '';\r\nlet wakeLock: any = null;\r\nlet audioContext: AudioContext | null = null;\r\nlet silentAudio: HTMLAudioElement | null = null;\r\nlet isBackgroundPlayback = false;\r\n\r\nconst SPEECH_RATE_KEY = 'otakonSpeechRate';\r\n\r\n// Request Wake Lock to keep screen awake during TTS\r\nconst requestWakeLock = async () => {\r\n    try {\r\n        if ('wakeLock' in navigator) {\r\n            wakeLock = await (navigator as any).wakeLock.request('screen');\r\n            wakeLock.addEventListener('release', () => {\r\n                console.log('Wake Lock released - attempting to reacquire...');\r\n                // Automatically reacquire if TTS is still speaking\r\n                if (synth && synth.speaking && !isBackgroundPlayback) {\r\n                    requestWakeLock();\r\n                }\r\n            });\r\n        }\r\n    } catch (err) {\r\n        console.warn('Wake Lock not supported or failed:', err);\r\n    }\r\n};\r\n\r\n// Release Wake Lock when TTS stops\r\nconst releaseWakeLock = async () => {\r\n    try {\r\n        if (wakeLock !== null) {\r\n            await wakeLock.release();\r\n            wakeLock = null;\r\n        }\r\n    } catch (err) {\r\n        console.warn('Wake Lock release failed:', err);\r\n    }\r\n};\r\n\r\n// Initialize Audio Context with silent audio to maintain background session\r\nconst initAudioContext = () => {\r\n    try {\r\n        if (!audioContext) {\r\n            audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n        }\r\n        \r\n        if (!silentAudio) {\r\n            silentAudio = new Audio();\r\n            // Extremely short silent audio file (base64 encoded WAV)\r\n            silentAudio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\r\n            silentAudio.loop = true;\r\n            silentAudio.volume = 0.01; // Very low volume\r\n            \r\n            // Connect to audio context to keep it active\r\n            if (audioContext) {\r\n                const source = audioContext.createMediaElementSource(silentAudio);\r\n                source.connect(audioContext.destination);\r\n            }\r\n        }\r\n    } catch (err) {\r\n        console.warn('Audio Context initialization failed:', err);\r\n    }\r\n};\r\n\r\n// Start silent audio to maintain audio session\r\nconst startSilentAudio = async () => {\r\n    try {\r\n        if (silentAudio && audioContext) {\r\n            if (audioContext.state === 'suspended') {\r\n                await audioContext.resume();\r\n            }\r\n            await silentAudio.play();\r\n        }\r\n    } catch (err) {\r\n        console.warn('Silent audio playback failed:', err);\r\n    }\r\n};\r\n\r\n// Stop silent audio when TTS is complete\r\nconst stopSilentAudio = () => {\r\n    try {\r\n        if (silentAudio) {\r\n            silentAudio.pause();\r\n            silentAudio.currentTime = 0;\r\n        }\r\n    } catch (err) {\r\n        console.warn('Silent audio stop failed:', err);\r\n    }\r\n};\r\n\r\n// Function to populate voices, returns a promise that resolves when voices are loaded.\r\nconst populateVoiceList = (): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        if (!synth) {\r\n            return reject(new Error(\"Speech synthesis not initialized.\"));\r\n        }\r\n        voices = synth.getVoices();\r\n        if (voices.length > 0) {\r\n            resolve();\r\n            return;\r\n        }\r\n        synth.onvoiceschanged = () => {\r\n            voices = synth.getVoices();\r\n            resolve();\r\n        };\r\n        // Fallback timeout in case onvoiceschanged never fires\r\n        setTimeout(() => {\r\n            if (voices.length === 0) {\r\n                console.warn(\"TTS voices did not load within a reasonable time.\");\r\n                voices = synth.getVoices(); // Try one last time\r\n            }\r\n            resolve();\r\n        }, 1000);\r\n    });\r\n};\r\n\r\nconst cancel = () => {\r\n    if (synth && synth.speaking) {\r\n        synth.cancel();\r\n    }\r\n    currentText = '';\r\n    if ('mediaSession' in navigator && navigator.mediaSession.playbackState !== 'none') {\r\n        navigator.mediaSession.playbackState = 'paused';\r\n    }\r\n    // Release wake lock and stop silent audio\r\n    releaseWakeLock();\r\n    stopSilentAudio();\r\n    // Dispatch event for UI updates\r\n    window.dispatchEvent(new CustomEvent('otakon:ttsStopped'));\r\n};\r\n\r\nconst pause = () => {\r\n    if (synth && synth.speaking && !synth.paused) {\r\n        synth.pause();\r\n        if ('mediaSession' in navigator) {\r\n            navigator.mediaSession.playbackState = 'paused';\r\n        }\r\n        window.dispatchEvent(new CustomEvent('otakon:ttsPaused'));\r\n    }\r\n};\r\n\r\nconst resume = () => {\r\n    if (synth && synth.paused) {\r\n        synth.resume();\r\n        if ('mediaSession' in navigator) {\r\n            navigator.mediaSession.playbackState = 'playing';\r\n        }\r\n        window.dispatchEvent(new CustomEvent('otakon:ttsResumed'));\r\n    }\r\n};\r\n\r\nconst restart = async () => {\r\n    if (currentText) {\r\n        cancel();\r\n        await speak(currentText);\r\n    }\r\n};\r\n\r\nconst isSpeaking = (): boolean => {\r\n    return synth ? synth.speaking : false;\r\n};\r\n\r\nconst cancelAndDisableHandsFree = () => {\r\n    cancel();\r\n    window.dispatchEvent(new CustomEvent('otakon:disableHandsFree'));\r\n};\r\n\r\nconst setupMediaSession = () => {\r\n    if ('mediaSession' in navigator) {\r\n        navigator.mediaSession.setActionHandler('play', () => { /* Let audio play naturally */ });\r\n        navigator.mediaSession.setActionHandler('pause', cancelAndDisableHandsFree);\r\n        navigator.mediaSession.setActionHandler('stop', cancelAndDisableHandsFree);\r\n    }\r\n};\r\n\r\n// Handle visibility change to maintain audio in background\r\nconst handleVisibilityChange = async () => {\r\n    if (document.hidden) {\r\n        // Screen locked or app backgrounded\r\n        isBackgroundPlayback = true;\r\n        console.log('App backgrounded - maintaining TTS audio');\r\n        // Keep silent audio playing to maintain audio session\r\n        if (synth && synth.speaking) {\r\n            await startSilentAudio();\r\n        }\r\n    } else {\r\n        // Screen unlocked or app foregrounded\r\n        isBackgroundPlayback = false;\r\n        console.log('App foregrounded - resuming normal operation');\r\n        // Reacquire wake lock if TTS is still speaking\r\n        if (synth && synth.speaking) {\r\n            await requestWakeLock();\r\n        }\r\n    }\r\n};\r\n\r\nconst init = async () => {\r\n    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {\r\n        if (isInitialized) {\r\n          return;\r\n        }\r\n        isInitialized = true;\r\n        synth = window.speechSynthesis;\r\n        await populateVoiceList();\r\n        setupMediaSession();\r\n        // Initialize audio context for background playback\r\n        initAudioContext();\r\n        // Setup visibility change listener for background playback\r\n        document.addEventListener('visibilitychange', handleVisibilityChange);\r\n        // On some browsers (like Chrome on desktop), getVoices() is empty until speak() is called.\r\n        // This empty utterance is a workaround to trigger the onvoiceschanged event.\r\n        if (synth.getVoices().length === 0) {\r\n            synth.speak(new SpeechSynthesisUtterance(''));\r\n        }\r\n    } else {\r\n        console.warn(\"Speech Synthesis not supported in this browser.\");\r\n    }\r\n};\r\n\r\nconst getAvailableVoices = (): SpeechSynthesisVoice[] => {\r\n    return voices.filter(v => v.lang.startsWith('en-'));\r\n};\r\n\r\nconst speak = async (text: string): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            if (!synth) {\r\n                console.error(\"Text-to-Speech is not available on this browser.\");\r\n                return reject(new Error(\"Text-to-Speech is not available on this browser.\"));\r\n            }\r\n            \r\n            if (!text.trim()) {\r\n                return resolve();\r\n            }\r\n\r\n            cancel(); // Cancel any ongoing speech\r\n\r\n            currentText = text; // Store for restart functionality\r\n            const utterance = new SpeechSynthesisUtterance(text);\r\n            \r\n            const storedRate = localStorage.getItem(SPEECH_RATE_KEY);\r\n            utterance.rate = storedRate ? parseFloat(storedRate) : 0.94; // Use stored rate or default to 94%\r\n            \r\n            const preferredVoiceURI = localStorage.getItem('otakonPreferredVoiceURI');\r\n            \r\n            const availableVoices = getAvailableVoices();\r\n            let voiceToUse: SpeechSynthesisVoice | undefined;\r\n\r\n            if (preferredVoiceURI) {\r\n                voiceToUse = availableVoices.find(v => v.voiceURI === preferredVoiceURI);\r\n            }\r\n            \r\n            // If no preferred voice is set or the saved one is no longer available\r\n            if (!voiceToUse && availableVoices.length > 0) {\r\n                // Prioritize voices with \"Female\" in the name as a default.\r\n                const femaleVoice = availableVoices.find(v => v.name.toLowerCase().includes('female'));\r\n                if (femaleVoice) {\r\n                    voiceToUse = femaleVoice;\r\n                } else {\r\n                    // As a fallback, use the first available voice.\r\n                    voiceToUse = availableVoices[0];\r\n                }\r\n            }\r\n\r\n            if (voiceToUse) {\r\n                utterance.voice = voiceToUse;\r\n            }\r\n\r\n            utterance.onstart = async () => {\r\n                // Request wake lock and start silent audio for background playback\r\n                await requestWakeLock();\r\n                await startSilentAudio();\r\n                \r\n                // Notify service worker that TTS started\r\n                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\r\n                    navigator.serviceWorker.controller.postMessage({\r\n                        type: 'TTS_STARTED'\r\n                    });\r\n                }\r\n                \r\n                if ('mediaSession' in navigator) {\r\n                    navigator.mediaSession.playbackState = 'playing';\r\n                    navigator.mediaSession.metadata = new MediaMetadata({\r\n                        title: text.length > 50 ? text.substring(0, 50) + '...' : text,\r\n                        artist: 'Your AI Gaming Companion',\r\n                        album: 'Otakon',\r\n                        artwork: [\r\n                            { src: '/Otagon/icon-192.png', sizes: '192x192', type: 'image/png' },\r\n                            { src: '/Otagon/icon-512.png', sizes: '512x512', type: 'image/png' }\r\n                        ]\r\n                    });\r\n                }\r\n                window.dispatchEvent(new CustomEvent('otakon:ttsStarted'));\r\n            };\r\n\r\n            utterance.onend = () => {\r\n                currentText = '';\r\n                if ('mediaSession' in navigator) {\r\n                    navigator.mediaSession.playbackState = 'paused';\r\n                }\r\n                // Notify service worker that TTS stopped\r\n                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\r\n                    navigator.serviceWorker.controller.postMessage({\r\n                        type: 'TTS_STOPPED'\r\n                    });\r\n                }\r\n                // Release wake lock and stop silent audio when TTS completes\r\n                releaseWakeLock();\r\n                stopSilentAudio();\r\n                window.dispatchEvent(new CustomEvent('otakon:ttsStopped'));\r\n                resolve();\r\n            };\r\n            \r\n            utterance.onerror = (e) => {\r\n                console.error(\"SpeechSynthesis Utterance Error\", e);\r\n                cancel();\r\n                reject(e);\r\n            };\r\n\r\n            synth.speak(utterance);\r\n        } catch (error) {\r\n            console.error(\"TTS Error:\", error);\r\n            reject(error);\r\n        }\r\n    });\r\n};\r\n\r\nexport const ttsService = {\r\n    init,\r\n    getAvailableVoices,\r\n    speak,\r\n    cancel,\r\n    pause,\r\n    resume,\r\n    restart,\r\n    isSpeaking,\r\n};\r\n\r\n\r\n","/* eslint-disable no-console */\r\nimport { ConversationService } from './conversationService';\r\nimport { ChatMessage, Conversations } from '../types';\r\n\r\n/**\r\n * Message Routing Service\r\n * Handles atomic message migration between tabs to prevent race conditions\r\n */\r\nexport class MessageRoutingService {\r\n  /**\r\n   * Atomically migrate messages from one conversation to another\r\n   * This prevents race conditions by doing all operations in a single transaction\r\n   */\r\n  static async migrateMessagesAtomic(\r\n    messageIds: string[],\r\n    fromConversationId: string,\r\n    toConversationId: string\r\n  ): Promise<void> {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ“¦ [MessageRouting] Starting atomic migration:', {\r\n        messageIds,\r\n        from: fromConversationId,\r\n        to: toConversationId\r\n      });\r\n    }\r\n\r\n    // âœ… FIX: Use cached data (in-memory) which has the most recent state\r\n    // Including the newly created game tab AND the game-hub with its messages\r\n    // skipCache=true was causing issues because game-hub might not be synced to Supabase yet\r\n    const conversations = await ConversationService.getConversations(false); // Use cache\r\n    \r\n    const fromConv = conversations[fromConversationId];\r\n    const toConv = conversations[toConversationId];\r\n    \r\n    if (!fromConv) {\r\n      console.error('ðŸ“¦ [MessageRouting] Source conversation not found:', fromConversationId);\r\n      console.error('ðŸ“¦ [MessageRouting] Available conversations:', Object.keys(conversations));\r\n      throw new Error(`Source conversation ${fromConversationId} not found`);\r\n    }\r\n    \r\n    if (!toConv) {\r\n      console.error('ðŸ“¦ [MessageRouting] Destination conversation not found:', toConversationId);\r\n      console.error('ðŸ“¦ [MessageRouting] Available conversations:', Object.keys(conversations));\r\n      throw new Error(`Destination conversation ${toConversationId} not found`);\r\n    }\r\n    \r\n    // Get messages to move\r\n    const messagesToMove = fromConv.messages.filter(m => messageIds.includes(m.id));\r\n    \r\n    if (messagesToMove.length === 0) {\r\n      console.warn('âš ï¸ [MessageRouting] No messages found to migrate');\r\n      return;\r\n    }\r\n    \r\n    // Check for duplicates in destination (prevent duplicate messages)\r\n    const messagesToAdd = messagesToMove.filter(msg => \r\n      !toConv.messages.some(existing => existing.id === msg.id)\r\n    );\r\n    \r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('ðŸ“¦ [MessageRouting] Migration details:', {\r\n        found: messagesToMove.length,\r\n        toAdd: messagesToAdd.length,\r\n        duplicatesSkipped: messagesToMove.length - messagesToAdd.length\r\n      });\r\n    }\r\n    \r\n    // ATOMIC UPDATE: Modify both conversations in a single object\r\n    const updatedConversations: Conversations = {\r\n      ...conversations,\r\n      [toConversationId]: {\r\n        ...toConv,\r\n        messages: [...toConv.messages, ...messagesToAdd],\r\n        updatedAt: Date.now()\r\n      },\r\n      [fromConversationId]: {\r\n        ...fromConv,\r\n        messages: fromConv.messages.filter(m => !messageIds.includes(m.id)),\r\n        updatedAt: Date.now()\r\n      }\r\n    };\r\n    \r\n    // Single write operation\r\n    await ConversationService.setConversations(updatedConversations);\r\n    \r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('âœ… [MessageRouting] Migration complete:', {\r\n        migrated: messagesToAdd.length,\r\n        fromMessages: updatedConversations[fromConversationId].messages.length,\r\n        toMessages: updatedConversations[toConversationId].messages.length\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a message should be routed to a different tab based on game detection\r\n   */\r\n  static shouldRouteMessage(\r\n    currentTabId: string,\r\n    targetGameTabId: string | null,\r\n    isGameHub: boolean\r\n  ): boolean {\r\n    // Don't route if no target game detected\r\n    if (!targetGameTabId) {\r\n      return false;\r\n    }\r\n    \r\n    // Don't route if already in the target tab\r\n    if (currentTabId === targetGameTabId) {\r\n      return false;\r\n    }\r\n    \r\n    // Route if currently in Game Hub and game detected\r\n    if (isGameHub && targetGameTabId) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Duplicate check for messages before adding\r\n   */\r\n  static messageExists(messages: ChatMessage[], messageId: string): boolean {\r\n    return messages.some(m => m.id === messageId);\r\n  }\r\n}\r\n","import { Conversation, ChatMessage } from '../types';\r\nimport { aiService } from './aiService';\r\n\r\ninterface SummarizationResult {\r\n  summary: string;\r\n  wordCount: number;\r\n  messagesIncluded: number;\r\n  originalWordCount: number;\r\n}\r\n\r\n/**\r\n * Context Summarization Service\r\n * Keeps conversation context manageable by summarizing message history to 300-word limit\r\n */\r\nclass ContextSummarizationService {\r\n  private readonly MAX_WORDS = 300;\r\n  private readonly RECENT_MESSAGE_COUNT = 8; // Keep last 8 messages unsummarized for context continuity\r\n\r\n  /**\r\n   * Count words in text\r\n   */\r\n  private countWords(text: string): number {\r\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\r\n  }\r\n\r\n  /**\r\n   * Calculate total word count of messages\r\n   */\r\n  private getTotalWordCount(messages: ChatMessage[]): number {\r\n    return messages.reduce((total, msg) => {\r\n      const contentWords = this.countWords(msg.content);\r\n      return total + contentWords;\r\n    }, 0);\r\n  }\r\n\r\n  /**\r\n   * Check if conversation needs summarization\r\n   */\r\n  shouldSummarize(conversation: Conversation): boolean {\r\n    if (!conversation.messages || conversation.messages.length <= this.RECENT_MESSAGE_COUNT) {\r\n      return false; // Too few messages to benefit from summarization\r\n    }\r\n\r\n    const totalWords = this.getTotalWordCount(conversation.messages);\r\n    console.log(`ðŸ“Š [ContextSummarization] Total words in conversation: ${totalWords}`);\r\n\r\n    // Summarize if exceeding 3x the target (900 words) to keep context manageable\r\n    return totalWords > this.MAX_WORDS * 3;\r\n  }\r\n\r\n  /**\r\n   * Split messages into \"to summarize\" and \"to keep\"\r\n   */\r\n  private splitMessages(messages: ChatMessage[]): { toSummarize: ChatMessage[]; toKeep: ChatMessage[] } {\r\n    if (messages.length <= this.RECENT_MESSAGE_COUNT) {\r\n      return { toSummarize: [], toKeep: messages };\r\n    }\r\n\r\n    const splitIndex = messages.length - this.RECENT_MESSAGE_COUNT;\r\n    return {\r\n      toSummarize: messages.slice(0, splitIndex),\r\n      toKeep: messages.slice(splitIndex)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a concise summary of older messages\r\n   */\r\n  async summarizeMessages(\r\n    messages: ChatMessage[], \r\n    gameTitle?: string,\r\n    genre?: string\r\n  ): Promise<SummarizationResult> {\r\n    console.log(`ðŸ“ [ContextSummarization] Summarizing ${messages.length} messages`);\r\n\r\n    const originalWordCount = this.getTotalWordCount(messages);\r\n\r\n    // Build context for summarization\r\n    const conversationText = messages\r\n      .map(msg => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)\r\n      .join('\\n\\n');\r\n\r\n    const contextInfo = gameTitle && genre\r\n      ? `This is a conversation about \"${gameTitle}\" (${genre}).`\r\n      : 'This is a general conversation.';\r\n\r\n    const summaryPrompt = `${contextInfo}\r\n\r\nPlease provide a concise summary of the following conversation history. Focus on:\r\n- Key topics discussed\r\n- Important decisions or choices made\r\n- Game progress or story developments (if applicable)\r\n- User preferences or interests mentioned\r\n\r\nKeep the summary under ${this.MAX_WORDS} words while preserving essential context.\r\n\r\nConversation to summarize:\r\n${conversationText}\r\n\r\nProvide ONLY the summary, no additional commentary.`;\r\n\r\n    try {\r\n      // Create a temporary conversation for summarization\r\n      const tempConversation: Conversation = {\r\n        id: 'temp-summary',\r\n        title: 'Summary Request',\r\n        messages: [{ \r\n          id: 'summary-msg-' + Date.now(),\r\n          role: 'user', \r\n          content: summaryPrompt, \r\n          timestamp: Date.now() \r\n        }],\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n        isActive: false,\r\n        isGameHub: false\r\n      };\r\n\r\n      // Get AI summary using getChatResponse\r\n      // Create minimal user object for summarization\r\n      const summaryUser = {\r\n        id: 'system',\r\n        email: 'system@otakon.ai',\r\n        profileData: null\r\n      } as any;\r\n\r\n      const response = await aiService.getChatResponse(\r\n        tempConversation,\r\n        summaryUser,\r\n        summaryPrompt,\r\n        false, // Not active session\r\n        false // No images\r\n      );\r\n\r\n      const summary = response.content.trim();\r\n      const summaryWordCount = this.countWords(summary);\r\n\r\n      console.log(`âœ… [ContextSummarization] Summary generated: ${summaryWordCount} words (reduced from ${originalWordCount})`);\r\n\r\n      return {\r\n        summary,\r\n        wordCount: summaryWordCount,\r\n        messagesIncluded: messages.length,\r\n        originalWordCount\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('âŒ [ContextSummarization] Failed to generate summary:', error);\r\n      \r\n      // Fallback: Create simple concatenated summary\r\n      const fallbackSummary = messages\r\n        .slice(0, 5) // Take first 5 messages\r\n        .map(msg => msg.content.substring(0, 100)) // Truncate each\r\n        .join(' ... ')\r\n        .substring(0, this.MAX_WORDS * 6); // Rough word limit\r\n\r\n      return {\r\n        summary: `[Previous conversation context] ${fallbackSummary}`,\r\n        wordCount: this.countWords(fallbackSummary),\r\n        messagesIncluded: messages.length,\r\n        originalWordCount\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply summarization to conversation\r\n   * Returns updated conversation with summarized history\r\n   */\r\n  async applyContextSummarization(conversation: Conversation): Promise<Conversation> {\r\n    if (!this.shouldSummarize(conversation)) {\r\n      console.log('ðŸ“Š [ContextSummarization] No summarization needed');\r\n      return conversation;\r\n    }\r\n\r\n    console.log('ðŸ”„ [ContextSummarization] Applying context summarization...');\r\n\r\n    const { toSummarize, toKeep } = this.splitMessages(conversation.messages);\r\n\r\n    if (toSummarize.length === 0) {\r\n      return conversation; // Nothing to summarize\r\n    }\r\n\r\n    // Generate summary of older messages\r\n    const summaryResult = await this.summarizeMessages(\r\n      toSummarize,\r\n      conversation.gameTitle,\r\n      conversation.genre\r\n    );\r\n\r\n    // Create summary message\r\n    const summaryMessage: ChatMessage = {\r\n      id: 'summary-' + Date.now(),\r\n      role: 'system',\r\n      content: summaryResult.summary,\r\n      timestamp: toSummarize[toSummarize.length - 1].timestamp,\r\n      metadata: {\r\n        isSummary: true,\r\n        messagesIncluded: summaryResult.messagesIncluded,\r\n        originalWordCount: summaryResult.originalWordCount,\r\n        summaryWordCount: summaryResult.wordCount\r\n      }\r\n    };\r\n\r\n    // Build new message array: [summary] + [recent messages]\r\n    const updatedMessages = [summaryMessage, ...toKeep];\r\n\r\n    // Store text-only summary (max 500 words) for persistence\r\n    const textOnlySummary = summaryResult.summary.replace(/!\\[.*?\\]\\(data:image\\/.*?\\)/g, '');\r\n    const words = textOnlySummary.split(/\\s+/).filter(w => w.length > 0);\r\n    const cappedSummary = words.length > 500 \r\n      ? words.slice(0, 500).join(' ') + '...'\r\n      : textOnlySummary;\r\n\r\n    console.log(`âœ… [ContextSummarization] Context optimized: ${conversation.messages.length} messages â†’ ${updatedMessages.length} (${summaryResult.originalWordCount} words â†’ ${summaryResult.wordCount} + recent)`);\r\n\r\n    return {\r\n      ...conversation,\r\n      messages: updatedMessages,\r\n      contextSummary: cappedSummary,  // Store persistent summary (500 word cap)\r\n      lastSummarizedAt: Date.now(),   // Track when summarization occurred\r\n      updatedAt: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get context-aware message history for AI\r\n   * Ensures context stays under limit before sending to AI\r\n   */\r\n  async getOptimizedContext(conversation: Conversation): Promise<ChatMessage[]> {\r\n    if (!this.shouldSummarize(conversation)) {\r\n      return conversation.messages;\r\n    }\r\n\r\n    const optimizedConversation = await this.applyContextSummarization(conversation);\r\n    return optimizedConversation.messages;\r\n  }\r\n\r\n  /**\r\n   * Estimate if next message will trigger summarization\r\n   */\r\n  willTriggerSummarization(conversation: Conversation): boolean {\r\n    const totalWords = this.getTotalWordCount(conversation.messages);\r\n    // Will trigger if we're at 80% of the threshold\r\n    return totalWords > (this.MAX_WORDS * 3 * 0.8);\r\n  }\r\n}\r\n\r\nexport const contextSummarizationService = new ContextSummarizationService();\r\n"],"names":["CacheService","__publicField","key","value","ttl","cacheType","userId","expires","error","supabase","memoryOnly","memoryItem","supabaseRequest","data","expiresAt","memoryDeleted","now","entries","item","b","context","memory","gameId","user","conversationId","conversation","cacheService","ErrorService","userMessage","operation","time","message","ToastService","listener","type","options","id","toast","index","t","promise","messages","dismiss","result","successMessage","errorMessage","toastService","isScreenLocked","showAINotification","messagePreview","conversationName","preview","notification","isScreenLockedOrHidden","_OnboardingService","status","profileData","defaultValue","hasSeenSplashScreens","hasSeenHowToUse","hasSeenFeaturesConnected","hasSeenProFeatures","pcConnected","pcConnectionSkipped","step","action","reason","progressError","userError","totalUsers","completedUsers","dropoffData","dropoffByStep","record","eventData","OnboardingService","onboardingService","ws","SERVER_ADDRESS","reconnectAttempts","maxBackoffMs","sendQueue","lastCode","handlers","heartbeatTimer","shouldReconnect","HEARTBEAT_MS","connect","code","onOpen","onMessage","onError","onClose","fullUrl","e","payload","event","base","jitter","delay","send","disconnect","WaitlistService","email","source","insertData","insertError","existing","checkError","count","stats","entry","StorageService","ChatMemoryService","summary","_userId","chatMemoryService","parseOtakonTags","rawContent","tags","tagRegex","cleanContent","match","tagName","tagValue","_ProfileAwareTabService","profile","gameContext","tabs","hintStyle","instructions","_profile","a","priorityOrder","modifiers","playerFocus","spoilerTolerance","preferredTone","ProfileAwareTabService","profileAwareTabService","OTAKON_TAG_DEFINITIONS","COMMAND_CENTRE_INSTRUCTIONS","getGeneralAssistantPrompt","getGameCompanionPrompt","isActiveSession","playerProfile","subtabContext","_a","tab","recentMessages","m","historicalContext","profileContext","_b","getScreenshotAnalysisPrompt","_conversation","_user","getPromptForPersona","hasImages","ErrorRecoveryService","retryCount","current","ms","resolve","additionalInfo","errorRecoveryService","CharacterImmersionService","genre","tone","immersionText","response","enhancedResponse","_context","baseSuggestions","tabType","gameTitle","contentTemplates","characterImmersionService","SuggestedPromptsService","stored","prompts","lastResetTime","prompt","nextResetTime","newsPrompts","suggestions","suggestionsArray","cleanedSuggestions","parsed","s","suggestion","isGameHub","suggestedPromptsService","SessionSummaryService","playingMessages","msg","keyPoints","objectives","point","obj","planningMessages","sessionSummaryService","_SubtabsService","subtabs","tableSuccess","jsonbSuccess","subtab","tableResult","subtabId","updates","metadata","deleteError","subtabsToInsert","existingSubtabs","nextOrderIndex","safeString","dbUpdates","currentMetadata","updatedSubtabs","conversations","successCount","failedCount","migrationPromises","conv","SubtabsService","subtabsService","generateUUID","c","r","GameTabService","existingConv","ConversationService","subTabs","tabId","content","update","extractedSubtabs","_c","baseTabs","insightTabsConfig","tabConfig","profileTabs","aiResponse","insightUpdates","newTab","word","conversationContext","insights","aiService","hasInsights","freshConversation","typeToKeyMap","updatedSubTabs","subTab","insightKey","bossKey","fallbackContent","loreMatch","analysisMatch","hintMatch","subtabsDebug","verifyConv","errorSubTabs","updateError","subTabId","updatedCount","separator","newContent","gameTabService","UserService","STORAGE_KEYS","tier","USER_TIERS","limits","TIER_LIMITS","currentUser","updatedUser","usage","cached","authUser","authError","dbUser","dbError","safeNumber","safeParseDate","jsonToRecord","TabManagementService","trimmedMessage","commandMatch","tabName","modifier","instruction","matchingTab","commandType","searchName","normalizedSearch","name","_tabTitle","command","tabManagementService","synth","voices","isInitialized","currentText","wakeLock","audioContext","silentAudio","isBackgroundPlayback","SPEECH_RATE_KEY","requestWakeLock","err","releaseWakeLock","initAudioContext","startSilentAudio","stopSilentAudio","populateVoiceList","reject","cancel","pause","resume","restart","speak","isSpeaking","cancelAndDisableHandsFree","setupMediaSession","handleVisibilityChange","init","getAvailableVoices","v","text","utterance","storedRate","preferredVoiceURI","availableVoices","voiceToUse","femaleVoice","ttsService","MessageRoutingService","messageIds","fromConversationId","toConversationId","fromConv","toConv","messagesToMove","messagesToAdd","updatedConversations","currentTabId","targetGameTabId","messageId","ContextSummarizationService","total","contentWords","totalWords","splitIndex","originalWordCount","conversationText","summaryPrompt","tempConversation","summaryUser","summaryWordCount","fallbackSummary","toSummarize","toKeep","summaryResult","updatedMessages","textOnlySummary","words","w","cappedSummary","contextSummarizationService"],"mappings":"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"}